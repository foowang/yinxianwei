<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS应用开发之网络通讯 | 一枝红杏出墙来</title>
  <meta name="author" content="尹现伟">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="一枝红杏出墙来"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="shortcut icon">
  <link rel="alternate" href="/atom.xml" title="一枝红杏出墙来" type="application/atom+xml">
  <link rel="stylesheet" href="/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
  

</head>


<body>
  <header id="header" class="inner"><div id="nav-top">
  <div class="alignleft main-title">
    <h1>一枝红杏出墙来</h1>
    <h2></h2>
  </div>
  <nav id="main-nav" class="alignright">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title category">iOS应用开发之网络通讯</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-10-09T09:37:00.000Z"><a href="/2014/10/09/iOS 向服务器提交Byte数组格式图片/">10月 9 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/10/09/iOS 向服务器提交Byte数组格式图片/">iOS 向服务器提交Byte数组格式图片</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>];</div><div class="line"> NSData *data = UIImagePNGRepresentation(image);</div><div class="line"> <span class="built_in">NSString</span> *byteArray = [data base64Encoding];</div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/uiimage/">uiimage</a>, <a href="/tags/bytearray/">bytearray</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-09-13T07:14:00.000Z"><a href="/2014/09/13/用 AFNetworking 通过 POST 方式发送数据/">9月 13 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/09/13/用 AFNetworking 通过 POST 方式发送数据/">用 AFNetworking 通过 POST 方式发送数据</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>AFNetworking进行POST请求中 发送json数据有些特别 。<br><strong>AFNetworking 版本为 2.0.2</strong><br>POST 发送数据有两种形式：<br>1、发送纯文本的内容<br>2、发送的 body 部分带有文件（图片，音频或者其他二进制数据）<br>对应的 Content-Type 有两种：<br>1、application/x-www-form-urlencoded<br>2、multipart/form-data<br>传统的使用 POST 的方式发送数据用于上传文件，AFNetworking 中提供了直接的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span><span class="variable">.manager</span> POST:post_url parameters:params</div><div class="line">constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) {</div><div class="line">    <span class="comment">// 直接以 key value 的形式向 formData 中追加二进制数据</span></div><div class="line">    [formData appendPartWithFormData:[str dataUsingEncoding:NSUTF8StringEncoding] </div><div class="line">              name:<span class="string">@"key1"</span>];</div><div class="line">    [formData appendPartWithFileData:imgData name:<span class="string">@"imagefile"</span> </div><div class="line">              fileName:<span class="string">@"img.jpg"</span> mimeType:<span class="string">@"image/jpeg"</span>];</div><div class="line">    }</div><div class="line">success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) {</div><div class="line">    <span class="comment">// 成功后的处理</span></div><div class="line">}</div><div class="line">failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) {</div><div class="line">    <span class="comment">// 失败后的处理</span></div><div class="line">}];</div></pre></td></tr></table></figure>

<p>使用 POST 方式发送纯文本内容：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (NSMutableURLRequest *)postRequestWithURL:(<span class="built_in">NSString</span> *)url content:(<span class="built_in">NSString</span> *)text</div><div class="line">{</div><div class="line">    NSMutableURLRequest *request =</div><div class="line">        [[NSMutableURLRequest alloc] initWithURL:url];</div><div class="line">    [request setHTTPMethod:<span class="string">@"POST"</span>];</div><div class="line">    [request setValue:<span class="string">@"application/x-www-form-urlencoded"</span> </div><div class="line">             forHTTPHeaderField:<span class="string">@"Contsetent-Type"</span>];</div><div class="line">    [request setHTTPBody:<span class="number">1</span>];</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">}</div><div class="line"> </div><div class="line">NSOperation *operation =</div><div class="line">[<span class="keyword">self</span><span class="variable">.manager</span> HTTPRequestOperationWithRequest:request</div><div class="line">success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) {</div><div class="line">    <span class="comment">// 成功后的处理</span></div><div class="line">}</div><div class="line">failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) {</div><div class="line">    <span class="comment">// 失败后的处理</span></div><div class="line">}];</div><div class="line">[<span class="keyword">self</span><span class="variable">.manager</span><span class="variable">.operationQueue</span> addOperation:operation];</div></pre></td></tr></table></figure>


<p>其中 self.manager 为 AFHTTPRequestOperationManager 实例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];</div><div class="line"> </div><div class="line"><span class="comment">// 对于网站成功返回 JSON 格式的数据但是却在 failure 回调中显示的，</span></div><div class="line"><span class="comment">// 是因为服务器返回数据的网页中 content type 没有设置为 text/json</span></div><div class="line"><span class="comment">// 对于我们公司的服务器返回的 content type 为 text/html 所以我设置为如下这样，</span></div><div class="line"><span class="comment">// 对于不同的情况可以根据自己的情况设置合适的接受的 content type 的类型</span></div><div class="line">_manager<span class="variable">.responseSerializer</span><span class="variable">.acceptableContentTypes</span> = [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"text/html"</span>];</div></pre></td></tr></table></figure>


<p>本文转自：<a href="http://www.iliunian.com/2879.html" target="_blank" rel="external">http://www.iliunian.com/2879.html</a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/AFNetworking/">AFNetworking</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-26T06:16:00.000Z"><a href="/2014/02/26/IOS离线缓存致内存和本地的方法/">2月 26 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/26/IOS离线缓存致内存和本地的方法/">IOS离线缓存致内存和本地的方法</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>缓存由四个文件组成。</p>
<p>FlashDiskCacheManager.h<br>FlashDiskCacheManager.m</p>
<p>这个类是以单例的模式提供的，您可以在您想要缓存的地方来share</p>
<p>URLCacheElement.h<br>URLCacheElement.m</p>
<p>这个类您永远都不要使用，每一个缓存就是一个URLCacheElement的对象，然后归档到文件中，实现磁盘缓存。</p>
<p>具体见FlashDiskCacheManager类的注释部分。</p>
<p>FlashDiskCacheManager.h</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="copy" target="_blank" rel="external">copy</a>1. //  </p>
<ol>
<li>//  FlashDiskCacheManager.h  </li>
<li>//    </li>
<li>//  </li>
<li>//  Created by jeffrey on 10-12-21.  </li>
<li>//  Copyright 2010 AppUFO. All rights reserved.  </li>
<li>//  </li>
<li><h1 id="import_">import <foundation foundation.h=""></foundation></h1>
</li>
<li><h1 id="import_“URLCacheElement-h”">import “URLCacheElement.h”</h1>
</li>
<li>@interface FlashDiskCacheManager : NSObject  </li>
<li>{  </li>
<li>/<strong> 存储已经缓存的url </strong>/  </li>
<li>NSMutableDictionary* urlDictionary;  </li>
<li></li>
<li>NSKeyedUnarchiver* reader;  </li>
<li>}  </li>
<li>@property (nonatomic, retain) NSMutableDictionary *urlDictionary;  </li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>设置保存时间 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(void) setMinStoreInterval:(double)interval;  </li>
</ul>
</li>
<li><ul>
<li>(FlashDiskCacheManager*) sharedManager;  </li>
</ul>
</li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>获取缓存的对象 如果为nil，则缓存已经失效，或者无缓存 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(URLCacheElement<em>) cachedForWithURL:(NSURL</em>)url;  </li>
</ul>
</li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>缓存请求1 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(void) cachedWithURLResponse:(NSCachedURLResponse*) cachedResponse;  </li>
</ul>
</li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>缓存请求2 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(void) cachedWithData:(NSData<em>)data theUrl:(NSURL</em>)url;  </li>
</ul>
</li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>写入闪存 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(void) storeToDisk;  </li>
</ul>
</li>
<li>@end  </li>
</ol>
<p>FlashDiskCacheManager.m</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="copy" target="_blank" rel="external">copy</a>1. //  </p>
<ol>
<li>//  FlashDiskCacheManager.m  </li>
<li>//    </li>
<li>//  </li>
<li>//  Created by jeffrey on 10-12-21.  </li>
<li>//  Copyright 2010 AppUFO. All rights reserved.  </li>
<li><h1 id="import_“FlashDiskCacheManager-h”">import “FlashDiskCacheManager.h”</h1>
</li>
<li></li>
<li>@implementation FlashDiskCacheManager  </li>
<li>@synthesize urlDictionary;  </li>
<li>static FlashDiskCacheManager* defaultManager = nil;  </li>
<li>/<strong> 存储实效时间 </strong>/  </li>
<li>static NSTimeInterval minStoreInterval = 10 <em> 60 </em> 60;  </li>
<li><ul>
<li>(void) setMinStoreInterval:(double)interval  </li>
</ul>
</li>
<li>{  </li>
<li>minStoreInterval = interval;  </li>
<li>}  </li>
<li><ul>
<li>(FlashDiskCacheManager*) sharedManager  </li>
</ul>
</li>
<li>{  </li>
<li>@synchronized(self)  </li>
<li>{  </li>
<li>if (defaultManager == nil)  </li>
<li>{  </li>
<li>defaultManager = [[self alloc] init];  </li>
<li>}  </li>
<li>return defaultManager;  </li>
<li>}  </li>
<li>}  </li>
<li><ul>
<li>(id) init  </li>
</ul>
</li>
<li>{  </li>
<li>self = [super init];  </li>
<li>if (self)  </li>
<li>{  </li>
<li>NSArray* path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  </li>
<li>self.urlDictionary = [[NSMutableDictionary alloc] init];  </li>
<li>[urlDictionary release];  </li>
<li></li>
<li>//解档  </li>
<li>for (NSInteger index = 0; index &lt; 100000; ++index)  </li>
<li>{  </li>
<li>NSString* document = [path objectAtIndex:0];  </li>
<li>document = [document stringByAppendingPathComponent:[NSString stringWithFormat:@”cache%d”, index]];  </li>
<li>if ([[NSFileManager defaultManager] fileExistsAtPath:document])  </li>
<li>{  </li>
<li>NSMutableData* data = [[NSMutableData alloc] initWithContentsOfFile:document];  </li>
<li>reader = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];  </li>
<li>URLCacheElement* element = [reader decodeObjectForKey:[NSString stringWithFormat:@”cache%d”, index]];  </li>
<li>[reader finishDecoding];  </li>
<li>NSURL* urlKey = [[NSURL alloc] initWithString:element.name];  </li>
<li>NSTimeInterval now = [element.date timeIntervalSinceNow];  </li>
<li></li>
<li>if (fabs(now) - minStoreInterval &gt; 0)  </li>
<li>{  </li>
<li>[data release];  </li>
<li>[urlKey release];  </li>
<li>[reader release];  </li>
<li>continue;  </li>
<li>}  </li>
<li></li>
<li>[urlDictionary setObject:element forKey:urlKey];  </li>
<li>[data release];  </li>
<li>[urlKey release];  </li>
<li>[reader release];  </li>
<li>}  </li>
<li>else  </li>
<li>{  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>return self;  </li>
<li>}  </li>
<li>return nil;  </li>
<li>}  </li>
<li><ul>
<li>(URLCacheElement<em>) cachedForWithURL:(NSURL</em>)url  </li>
</ul>
</li>
<li>{  </li>
<li>URLCacheElement* element =  [urlDictionary objectForKey:url];  </li>
<li>if (element == nil)  </li>
<li>{  </li>
<li>return nil;  </li>
<li>}  </li>
<li></li>
<li>NSTimeInterval now = [element.date timeIntervalSinceNow];  </li>
<li>if (fabs(now) - minStoreInterval &gt; 0)  </li>
<li>{  </li>
<li>[self.urlDictionary removeObjectForKey:url];  </li>
<li>return nil;  </li>
<li>}  </li>
<li>return element;  </li>
<li>}  </li>
<li><ul>
<li>(void) cachedWithURLResponse:(NSCachedURLResponse*) cachedResponse  </li>
</ul>
</li>
<li>{  </li>
<li>NSURLResponse* response = [cachedResponse response];  </li>
<li></li>
<li>//要存储的url  </li>
<li>NSURL* url = [response URL];  </li>
<li></li>
<li>//要存储的数据  </li>
<li>NSData* data = [cachedResponse data];  </li>
<li></li>
<li>//存储的时间  </li>
<li>NSDate* date = [NSDate date];  </li>
<li></li>
<li>// 存储的用户信息  </li>
<li>NSDictionary* user = [cachedResponse userInfo];  </li>
<li></li>
<li>URLCacheElement* element = [[URLCacheElement alloc] initWithData:data :date :user];  </li>
<li>[self.urlDictionary setObject:element forKey:url];  </li>
<li></li>
<li>[element release];  </li>
<li>}  </li>
<li><ul>
<li>(void) cachedWithData:(NSData<em>)data theUrl:(NSURL</em>)url  </li>
</ul>
</li>
<li>{  </li>
<li>//存储的时间  </li>
<li>NSDate* date = [NSDate date];  </li>
<li></li>
<li>// 存储的用户信息  </li>
<li>NSDictionary* user = nil;  </li>
<li></li>
<li>URLCacheElement* element = [[URLCacheElement alloc] initWithData:data :date :user];  </li>
<li>[self.urlDictionary setObject:element forKey:url];  </li>
<li></li>
<li>[element release];    </li>
<li>}  </li>
<li><ul>
<li>(void) storeToDisk  </li>
</ul>
</li>
<li>{  </li>
<li>NSArray* path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  </li>
<li>NSArray* arrayOfKeys = [urlDictionary allKeys];  </li>
<li></li>
<li>//归档  </li>
<li>for (NSInteger index = 0; index &lt; [arrayOfKeys count]; ++index)  </li>
<li>{  </li>
<li>NSURL<em> url = (NSURL</em>)[arrayOfKeys objectAtIndex:index];  </li>
<li>NSString* name = [url absoluteString];  </li>
<li></li>
<li>//初始化路径  </li>
<li>NSString* document = [path objectAtIndex:0];  </li>
<li>document = [document stringByAppendingPathComponent:[NSString stringWithFormat:@”cache%d”, index]];  </li>
<li></li>
<li>NSMutableData* tData = [[NSMutableData alloc] init];  </li>
<li>NSKeyedArchiver* write = [[NSKeyedArchiver alloc] initForWritingWithMutableData:tData];  </li>
<li>URLCacheElement* element = [urlDictionary objectForKey:[arrayOfKeys objectAtIndex:index]];  </li>
<li></li>
<li>//记录这个缓存的名字  </li>
<li>element.name = name;  </li>
<li></li>
<li>[write encodeObject:element forKey:[NSString stringWithFormat:@”cache%d”, index]];  </li>
<li></li>
<li>[write finishEncoding];  </li>
<li>[tData writeToFile:document atomically:YES];  </li>
<li></li>
<li>[tData release];  </li>
<li>[write release];  </li>
<li>}  </li>
<li>}  </li>
<li><ul>
<li>(void) dealloc  </li>
</ul>
</li>
<li>{  </li>
<li>[super dealloc];  </li>
<li>[urlDictionary release];  </li>
<li>}  </li>
<li>@end  </li>
</ol>
<p>URLCacheElement.h</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="copy" target="_blank" rel="external">copy</a>1. //  </p>
<ol>
<li>//  URLCacheElement.h  </li>
<li>//    </li>
<li>//  </li>
<li>//  Created by jeffrey on 10-12-21.  </li>
<li>//  Copyright 2010 AppUFO. All rights reserved.  </li>
<li>//  </li>
<li><h1 id="import_-1">import <foundation foundation.h=""></foundation></h1>
</li>
<li><h1 id="define_KData_@”urlData”">define KData @”urlData”</h1>
</li>
<li><h1 id="define_KUserInfo_@”userInfo”">define KUserInfo @”userInfo”</h1>
</li>
<li><h1 id="define_KDate_@”date”">define KDate @”date”</h1>
</li>
<li><h1 id="define_KName_@”name”">define KName @”name”</h1>
</li>
<li>@interface URLCacheElement : NSObject<nscoding, nscopying="">  </nscoding,></li>
<li>{  </li>
<li>/<strong> url存储的数据 </strong>/  </li>
<li>NSData* data;  </li>
<li></li>
<li>/<strong> 存储的用户信息 </strong>/  </li>
<li>NSDictionary* userInfo;  </li>
<li></li>
<li>/<strong> 存储的时间 </strong>/  </li>
<li>NSDate* date;  </li>
<li></li>
<li>NSString* name;  </li>
<li>}  </li>
<li><ul>
<li>(id) initWithData:(NSData<em>)indata :(NSDate</em>)indate :(NSDictionary*)inuserInfo;  </li>
</ul>
</li>
<li>@property (nonatomic, retain) NSData *data;  </li>
<li>@property (nonatomic, retain) NSDictionary *userInfo;  </li>
<li>@property (nonatomic, retain) NSDate *date;  </li>
<li>@property (nonatomic, retain) NSString *name;  </li>
<li>@end  </li>
</ol>
<p>URLCacheElement.m</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="copy" target="_blank" rel="external">copy</a>1. //  </p>
<ol>
<li>//  URLCacheElement.m  </li>
<li>//    </li>
<li>//  </li>
<li>//  Created by jeffrey on 10-12-21.  </li>
<li>//  Copyright 2010 AppUFO. All rights reserved.  </li>
<li><h1 id="import_“URLCacheElement-h”-1">import “URLCacheElement.h”</h1>
</li>
<li></li>
<li>@implementation URLCacheElement  </li>
<li>@synthesize data;  </li>
<li>@synthesize date;  </li>
<li>@synthesize userInfo;  </li>
<li>@synthesize name;  </li>
<li><ul>
<li>(id) initWithData:(NSMutableData<em>)indata :(NSDate</em>)indate :(NSMutableDictionary*)inuserInfo  </li>
</ul>
</li>
<li>{  </li>
<li>self = [super init];  </li>
<li>if (self)  </li>
<li>{  </li>
<li>self.data = indata;  </li>
<li>self.date = indate;  </li>
<li>self.userInfo = inuserInfo;  </li>
<li>return self;  </li>
<li>}  </li>
<li>return nil;  </li>
<li>}  </li>
<li></li>
<li><ul>
<li>(id) initWithCoder:(NSCoder *)aDecoder  </li>
</ul>
</li>
<li>{  </li>
<li>self = [super init];  </li>
<li>if (self)  </li>
<li>{  </li>
<li>self.data = [aDecoder decodeObjectForKey:KData];  </li>
<li>self.date = [aDecoder decodeObjectForKey:KDate];  </li>
<li>self.userInfo = [aDecoder decodeObjectForKey:KUserInfo];  </li>
<li>self.name = [aDecoder decodeObjectForKey:KName];  </li>
<li>return self;  </li>
<li>}  </li>
<li>return nil;  </li>
<li>}  </li>
<li></li>
<li><ul>
<li>(void) encodeWithCoder:(NSCoder *)aCoder  </li>
</ul>
</li>
<li>{  </li>
<li>[aCoder encodeObject:data forKey:KData];  </li>
<li>[aCoder encodeObject:date forKey:KDate];  </li>
<li>[aCoder encodeObject:userInfo forKey:KUserInfo];  </li>
<li>[aCoder encodeObject:name forKey:KName];  </li>
<li>}  </li>
<li><ul>
<li>(id) copyWithZone:(NSZone *)zone  </li>
</ul>
</li>
<li>{  </li>
<li>URLCacheElement *copy = [[[self class] allocWithZone:zone] init];  </li>
<li></li>
<li>self.data = [data copy];  </li>
<li>self.date = [date copy];  </li>
<li>self.userInfo = [userInfo copy];  </li>
<li>name = [name copy];  </li>
<li></li>
<li>return copy;  </li>
<li>}  </li>
<li><ul>
<li>(void) dealloc  </li>
</ul>
</li>
<li>{  </li>
<li>[super dealloc];  </li>
<li>}  </li>
<li>@end  </li>
</ol>
<p>本文转自:<a href="http://blog.csdn.net/windows_star/article/details/6117392" target="_blank" rel="external">http://blog.csdn.net/windows_star/article/details/6117392</a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/缓存/">缓存</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-26T02:07:00.000Z"><a href="/2014/02/26/如何改进iOS App的离线使用体验/">2月 26 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/26/如何改进iOS App的离线使用体验/">如何改进iOS App的离线使用体验</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <h2 id="App_Store中的App分析">App Store中的App分析</h2>
<p>App已经与我们形影不离了，不管在地铁上、公交上还是在会场你总能看到很多人拿出来手机，刷一刷微博，看看新闻。<br>据不完全统计有近一半的用户在非Wifi环境打开App，以下为一个典型iPhone和Android App（50W+用户）的友盟后台数据：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726375773.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726382086.jpg" alt="1" title="1"></a><br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726391398.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726403250.jpg" alt="2" title="2"></a><br>3G、2G的数据连接往往不稳定（特别在公交或者地铁上），这时打开一些App就会像这样：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726451850.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172647539.png" alt="IMG_2159" title="IMG_2159"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726512651.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726521091.png" alt="IMG_2163" title="IMG_2163"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101727107846.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172713863.png" alt="IMG_2160" title="IMG_2160"></a><br>当然也会有一些体验很好的App，在离线状态下也能顺畅使用：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172726622.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101727298830.png" alt="IMG_2149" title="IMG_2149"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101727449787.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172750588.png" alt="IMG_2150" title="IMG_2150"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728085325.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728128767.png" alt="IMG_2161" title="IMG_2161"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728301279.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728369845.png" alt="IMG_2162" title="IMG_2162"></a><br>甚至提供了离线阅读功能：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172846151.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728494804.png" alt="IMG_2158" title="IMG_2158"></a></p>
<h2 id="如何做？">如何做？</h2>
<p>打开过的文章、下载过的音频、查看过的图片我们都希望Cache到本地，下次不用再向服务器请求。<br>首先，我们为了最快让用户看到内容，会在ViewDidLoad加载Cache数据，如：<br>1234<code>-
 (``void``)viewDidLoad
 {</code> <code>``[self
 getArticleList:0 length:SECTION_LENGTH useCacheFirst:YES];``}</code>然后在viewDidAppear中向服务器请求最新数据，如<br>12345678<code>-
 (``void``)viewDidAppear:(``BOOL``)animated
 {`` </code> <code>``[super
 viewDidAppear:animated];</code> <code>``//...</code> <code>``[self
 getArticleList:0 length:SECTION_LENGTH useCacheFirst:NO]``}</code>当然这里的getArticleList接口有useCacheFirst参数，我们需要网络请求模块能够支持这一点，下面就介绍这些库和工具。（借助一些工具很容易能做到这些，而不用自己造轮子。遵循“凡事都应该最简单，而不过于简陋”的原则，这里整理一下，方便项目中使用）。</p>
<h3 id="1-NSMutableURLRequest">1.NSMutableURLRequest</h3>
<p>Sample(参考麒麟的文章《<a href="http://www.cnblogs.com/zhuqil/archive/2011/07/30/2122127.html" target="_blank" rel="external">iOS开发之缓存（一）：内存缓存</a>》来使用NSURLCache)：<br>1234567891011121314151617181920212223242526272829303132<code>NSString
 *paramURLAsString= @``&quot;[http://www.baidu.com/](http://www.baidu.com/)&quot;``;``if</code> <code>([paramURLAsString
 length] == 0){``    ``NSLog(@``&quot;Nil
 or empty URL is given&quot;``);``    ``return``;``}``NSURLCache
 *urlCache = [NSURLCache sharedURLCache];``/*
 设置缓存的大小为1M*/``[urlCache
 setMemoryCapacity:1*1024*1024];`` ``//创建一个nsurl``NSURL
 *url = [NSURL URLWithString:paramURLAsString];``    ``//创建一个请求``NSMutableURLRequest
 *request =``[NSMutableURLRequest`` ``requestWithURL:url`` ``cachePolicy:NSURLRequestUseProtocolCachePolicy`` ``timeoutInterval:60.0f];`` ``//从请求中获取缓存输出``NSCachedURLResponse
 *response =``[urlCache
 cachedResponseForRequest:request];``//判断是否有缓存``if</code> <code>(response
 != nil){``    ``NSLog(@``&quot;如果有缓存输出，从缓存中获取数据&quot;``);``    ``[request
 setCachePolicy:NSURLRequestReturnCacheDataDontLoad];``}``self.connection
 = nil;``/*
 创建NSURLConnection*/``NSURLConnection
 *newConnection =``[[NSURLConnection
 alloc] initWithRequest:request``                                ``delegate:self``                        ``startImmediately:YES];``self.connection
 = newConnection;``[newConnection
 release];</code>但是NSMutableURLRequest使用起来不够简便，在实际项目中我很少用它，而基本使用ASIHTTPRequest来代替。</p>
<h3 id="2-ASIHTTPRequest">2.ASIHTTPRequest</h3>
<p>你可以从这里找到它的介绍：<a href="http://allseeing-i.com/ASIHTTPRequest/" target="_blank" rel="external">http://allseeing-i.com/ASIHTTPRequest/</a>，在5.0/4.0及之前iOS版本，ASIHTTPRequest基本是主力的<br> HTTP requests library，它本身也是Github中的开源项目，但是从iOS 5.0之后逐渐停止维护了。未来的项目可以使用<strong><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a></strong>或者<strong><a href="https://github.com/MugunthKumar/MKNetworkKit" target="_blank" rel="external">MKNetworkKit</a></strong>代替ASIHTTPRequest。<br>ASIHTTPRequest的简介如下：</p>
<blockquote>
<p>ASIHTTPRequest is an easy to use wrapper around the CFNetwork API that makes some of the more tedious aspects of communicating with web servers easier. It is written in Objective-C and works in both Mac OS X and<br> iPhone applications.<br>It is suitable performing basic HTTP requests and interacting with REST-based services (GET / POST / PUT / DELETE). The included ASIFormDataRequest subclass makes it easy to submit POST data and files using<a href="http://en.wikipedia.org/wiki/MIME#Form_Data" target="_blank" rel="external">multipart/form-data</a>.<br>ASIHTTPRequest库API设计的简单易用，并且支持block、queue、gzip等丰富的功能，这是该开源项目如此受欢迎的主要原因。<br>ASIHTTPRequest库中提供了ASIWebPageRequest组件用于请求网页，并且能把网页中的外部资源一并请求下来，但是我在实际项目中使用后发现有严重Bug，所以不建议使用。<br>ASIHTTPRequest库的介绍中也提到了它可以支持REST-based service，但是与Restfull API打交道我们往往使用下面介绍的的RestKit。<br>Sample：<br>12345678910111213141516171819202122232425262728293031323334353637383940<code>NSMutableString
 *requestedUrl = [[NSMutableString alloc] initWithString:self.url];</code> <code>//如果优先使用本地数据``ASICachePolicy
 policy = _useCacheFirst ? ASIOnlyLoadIfNotCachedCachePolicy ``    ``:
 (ASIAskServerIfModifiedCachePolicy | ASIFallbackToCacheIfLoadFailsCachePolicy);</code> <code>asiRequest
 = [ASIHTTPRequest requestWithURL:``                   ``[NSURL
 URLWithString:[requestedUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]]];</code> <code>[asiRequest
 setDownloadCache:[ASIDownloadCache sharedCache]];``[asiRequest
 setCachePolicy:policy];``[asiRequest
 setCacheStoragePolicy:ASICachePermanentlyCacheStoragePolicy];</code> <code>//
 Connection``if</code> <code>(_connectionType
 == ConnectionTypeAsynchronously) {`` </code> <code>``[asiRequest
 setDelegate:self];``    ``[asiRequest
 startAsynchronous];`` </code> <code>``//
 Tell we&#39;re receiving.``    ``if</code> <code>(!_canceled
 &amp;&amp; [_delegate respondsToSelector:@selector(downloaderDidStart:)])``        ``[_delegate
 downloaderDidStart:self];``}``else``{``    ``[asiRequest
 startSynchronous];`` </code> <code>``NSError
 *error = [asiRequest error];`` </code> <code>``if</code> <code>(!error)
``    ``{``        ``[self
 requestFinished:asiRequest];``    ``}``    ``else``    ``{``        ``[self
 requestFailed:asiRequest];``    ``}``}</code> <code>[requestedUrl
 release];</code> </p>
<h3 id="3-RestKit">3.RestKit</h3>
<p>官方网站：<a href="http://restkit.org/" target="_blank" rel="external">http://restkit.org/</a>，Github开源项目，与 Restfull<br> API 的 Web服务打交道，这个库非常便捷，它也提供了很完整的Cache机制。<br>Sample：<br>123456789101112<code>+
 (``void``)setCachePolicy:(``BOOL``)useCacheFirst``{``    ``RKObjectManager*
 objectManager = [RKObjectManager sharedManager];`` </code> <code>``if</code> <code>(useCacheFirst)
 {``        ``objectManager.client.cachePolicy
 = RKRequestCachePolicyEnabled; ``//使用本地Cache，如果没有Cache请求服务器``    ``}``    ``else``    ``{``        ``objectManager.client.cachePolicy
 = RKRequestCachePolicyLoadIfOffline|RKRequestCachePolicyTimeout; ``//离线或者超时时使用本地Cache``    ``}``}</code>123456789101112<code>+
 (``BOOL``)getHomeTimeline:(NSInteger)maxId
``                 ``length:(NSInteger)length``               ``delegate:(id&lt;RKObjectLoaderDelegate&gt;)delegate``          ``useCacheFirst:(``BOOL``)useCacheFirst``{``    ``if</code> <code>(delegate
 == nil)``        ``return</code> <code>NO;`` </code> <code>``[iKnowAPI
 setCachePolicy:useCacheFirst];</code> <code>``//...``}</code>Cache请求只是RestKit最基本的功能，RestKit真正强大的地方在于处理与RESTful web services交互时的相关工作非常简便（<a href="https://github.com/RestKit/RestKit/wiki" target="_blank" rel="external">https://github.com/RestKit/RestKit/wiki</a>），RestKit还可以Cache<br> data model到Core Data中：<br>Core Data support. Building on top of the object mapping layer, RestKit provides integration with Apple’s Core Data framework. This support allows RestKit to persist remotely loaded objects directly back into a local<br> store, either as a fast local cache or a primary data store that is periodically synced with the cloud. RestKit can populate Core Data associations for you, allowing natural property based traversal of your data model. It also provides a nice API on top of<br> the Core Data primitives that simplifies configuration and querying use cases through an implementation of the Active Record access pattern.<br>但实际上RKRequestCachePolicy已经解决了大部分Cache需求。</p>
</blockquote>
<h3 id="4-SDWebImage">4.SDWebImage</h3>
<p>SDWebImage是Github开源项目：<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a>，它用于方便的请求、Cache网络图片，并且请求完毕后交由UIImageView显示。</p>
<blockquote>
<p>Asynchronous image downloader with cache support with an UIImageView category.<br>SDWebImage作为UIImageView的一个Category提供的，所以使用起来非常简单：<br>123<code>//
 Here we use the new provided setImageWithURL: method to load the web image``[imageView
 setImageWithURL:[NSURL URLWithString:@``&quot;[http://www.domain.com/path/to/image.jpg](http://www.domain.com/path/to/image.jpg)&quot;``]``               ``placeholderImage:[UIImage
 imageNamed:@``&quot;placeholder.png&quot;``]];</code>AFNetworking也提供了类似功能（<a href="http://afnetworking.github.com/AFNetworking/Categories/UIImageView+AFNetworking.html" target="_blank" rel="external">UIImageView+AFNetworking</a>）：<br>12<code>UIImageView
 *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0.0f, 0.0f, 100.0f, 100.0f)];``[imageView
 setImageWithURL:[NSURL URLWithString:@``&quot;[http://i.imgur.com/r4uwx.jpg](http://i.imgur.com/r4uwx.jpg)&quot;``]
 placeholderImage:[UIImage imageNamed:@``&quot;placeholder-avatar&quot;``]];</code> </p>
<h3 id="5-UIWebView中的图片Cache">5.UIWebView中的图片Cache</h3>
<p>如果你使用UIWebView来展示内容，在离线情况下如果也想能显示的话需要实现2点：</p>
<ul>
<li>Cache Html页面</li>
<li>Cache 图片等元素</li>
</ul>
</blockquote>
<p>使用上面介绍的网络组件来Cache Html页面比较便捷，之后使用webView loadHTMLString即可加载本地Html页面，而Cache图片需要更换NSURLCache公共实例为自定义的NSURLCache（UIWebView使用的即是+[NSURLCache sharedURLCache]）：<br>12345<code>//设置使用自定义Cache机制``LocalSubstitutionCache
 *cache = [[[LocalSubstitutionCache alloc] init] autorelease];``[cache
 setMemoryCapacity:4 * 1024 * 1024];``[cache
 setDiskCapacity:10 * 1024 * 1024];``[NSURLCache
 setSharedURLCache:cache];</code>自定义NSURLCache：<br>12345678910<code>#import
 &lt;Foundation/Foundation.h&gt;</code> <code>@interface
 LocalSubstitutionCache : NSURLCache``{``    ``NSMutableDictionary
 *cachedResponses;``}</code> <code>+
 (NSString *)pathForURL:(NSURL*)url;</code> <code>@end</code>详细的见NewsReader中的LocalSubstitutionCache.h/.m和WebViewController.m中的viewDidLoad，<a href="http://www.cnblogs.com/wangkewei/archive/2012/09/29/2708373.html" target="_blank" rel="external">News<br> Reader开源项目</a>这里参考的是：<a href="http://cocoawithlove.com/2010/09/substituting-local-data-for-remote.html" target="_blank" rel="external">http://cocoawithlove.com/2010/09/substituting-local-data-for-remote.html</a></p>
<h2 id="NewsReader中的介绍">NewsReader中的介绍</h2>
<h4 id="《iOS_News_Reader开源项目》这篇文章介绍到的开源项目改进了离线使用体验：">《<a href="http://www.cnblogs.com/wangkewei/archive/2012/09/29/2708373.html" target="_blank" rel="external">iOS News Reader开源项目</a>》这篇文章介绍到的开源项目改进了离线使用体验：</h4>
<p><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172859401.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101729043286.png" alt="IMG_2155" title="IMG_2155"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101729141291.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172918928.png" alt="IMG_2156" title="IMG_2156"></a><br>在没有网络的情况下使用已经Cache过的所有数据：文章、图片、音频等等，用到的主要方案已经在上面介绍了，详细的请看源码：<a href="https://github.com/cubewang/NewsReader" target="_blank" rel="external">https://github.com/cubewang/NewsReader</a>。<br>NewsReader项目因为历史演进的原因已经有些庞大了，需要进一步重构，在之后的项目中我们的客户端结构更精简。<br>另外欢迎加QQ群讨论：161561752<br>作者: 王克伟<br>出处: <a href="http://wangkewei.cnblogs.com/" target="_blank" rel="external">http://wangkewei.cnblogs.com/</a><br>版权声明: 本文的版权归作者与博客园共有。转载时须注明本文的详细链接，否则作者将保留追究其法律责任的权利。<br>您可以从<a href="http://www.cnblogs.com/wangkewei/archive/2009/10/15/1583745.html" target="_blank" rel="external">这里</a>更方便的找到我的文章。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-14T07:26:00.000Z"><a href="/2014/02/14/AFNetworking/">2月 14 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/14/AFNetworking/">AFNetworking</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>谷歌翻译</p>
<p>AFNetworking是为iOS和Mac OS X。它是建立在之上的愉快的网络库<a href="http://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=http://developer.apple.com/library/mac/&amp;usg=ALkJrhiuvZMlMsRypqYF71FfZwK2ZOzkGg#documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">基金会的URL加载系统</a> ，延长内置到可可的功能强大的高级网络抽象。 它有一个模块化的架构，设计精良，功能丰富的API，是一个欢乐的使用。<br>也许，最重要的功能，但是，是谁使用，每天贡献AFNetworking开发商惊人的社群。 AFNetworking一些权力在iPhone，iPad和Mac的最流行和广受好评的应用程序。<br>选择AFNetworking你的下一个项目，或迁移在你现有的项目 -你很高兴你没有！<br><strong>如何开始</strong></p>
<ul>
<li><a href="https://github.com/AFNetworking/AFNetworking/archive/master.zip" target="_blank" rel="external">下载AFNetworking</a>并尝试了包括Mac和iPhone应用程序的例子</li>
<li>阅读<a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=https://github.com/AFNetworking/AFNetworking/wiki/Getting-Started-with-AFNetworking&amp;usg=ALkJrhga207v_1meSZiL2EcgdRYqKCHTtg" target="_blank" rel="external">“入门”指南</a> ， <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-FAQ&amp;usg=ALkJrhjCmRFlSt9Zq1NWiZNz-BXgnfObzA" target="_blank" rel="external">常见问题</a> ，或<a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=https://github.com/AFNetworking/AFNetworking/wiki&amp;usg=ALkJrhhwTRR2yWVbforsMlQ4ZfcyVCbukQ" target="_blank" rel="external">对维基的其他文章</a></li>
<li>退房的<a href="http://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=http://cocoadocs.org/docsets/AFNetworking/2.0.0/&amp;usg=ALkJrhgaLywg4BOy7WoITC7XljNLm9P6Zw" target="_blank" rel="external">文档</a>进行全面审视所有的API提供AFNetworking</li>
<li>有问题吗？ <a href="http://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=http://stackoverflow.com/questions/tagged/afnetworking&amp;usg=ALkJrhgdhdymQnvL2gqHd8oMQY_Ht1fuVg" target="_blank" rel="external">堆栈溢出</a>是找到答案的最佳场所</li>
</ul>
<p><strong>安装与**</strong>CocoaPods<strong><br><a href="http://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=http://cocoapods.org/&amp;usg=ALkJrhiBjkx5qeHG3VXjZ4XK0htUc76LWg" target="_blank" rel="external">CocoaPods</a>是一个依赖经理的Objective-C，它能够自动并简化使用像AFNetworking的第三方库在项目的进程。 请参阅<a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=https://github.com/AFNetworking/AFNetworking/wiki/Getting-Started-with-AFNetworking&amp;usg=ALkJrhga207v_1meSZiL2EcgdRYqKCHTtg" target="_blank" rel="external">“入门”指南获取更多信息</a> 。
</strong>Podfile<strong><br>  平台：IOS，’7 .0’<br> 荚“AFNetworking”，“～&gt; 2.0”
</strong>2.0<strong><br>AFNetworking 2.0是一个重大更新的框架。 建设2年的发展，这个新版本引入了强大的新功能，同时提供了一个简单的升级路径，为现有的用户。
</strong>阅读<strong>[</strong>AFNetworking<br> 2.0<strong>**迁移指南</strong>](<a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide&amp;usg=ALkJrhgtuqdTdrxhouBTSdfN4JhiTtRiJg)**为建筑和****API****的变化的概述。**" target="_blank" rel="external">https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide&amp;usg=ALkJrhgtuqdTdrxhouBTSdfN4JhiTtRiJg)**为建筑和****API****的变化的概述。**</a><br><strong>最新消息</strong></p>
<ul>
<li>重构架构</li>
<li>支持NSURLSession</li>
<li>序列化模块</li>
<li>扩大的UIKit扩展</li>
<li>实时功能与<a href="http://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=http://rocket.github.io/&amp;usg=ALkJrhgx_MW9YPH6vUtxnPdqDLQgjADJ8g" target="_blank" rel="external">火箭</a></li>
</ul>
<p><strong>要求</strong><br>AFNetworking 2.0和更高要求的Xcode 5，确定目标的的iOS 6.0及以上版本，或Mac OS 10.8山狮（ <a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=https://developer.apple.com/library/mac/&amp;usg=ALkJrhgz1YE1BT4I-xQlHmYjVxid4WmTTA#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html" target="_blank" rel="external">64位与现代可可运行时</a> ）及以上。<br>对于与iOS 5或Mac OS X 10.7的兼容性，请使用<a href="https://github.com/AFNetworking/AFNetworking/tree/1.x" target="_blank" rel="external">最新的1.x的版本</a> 。<br>对于与iOS 4.3或Mac OS X 10.6的兼容性，请使用<a href="https://github.com/AFNetworking/AFNetworking/tree/0.10.x" target="_blank" rel="external">最新的0.10.x版本</a> 。<br><strong>建筑</strong><br><strong>NSURLConnection**</strong>的**</p>
<ul>
<li>AFURLConnectionOperation</li>
<li>AFHTTPRequestOperation</li>
<li>AFHTTPRequestOperationManager</li>
</ul>
<p><strong>NSURLSession**</strong>（<strong><strong>iOS</strong></strong>的<strong><strong>7 / Mac OS X</strong></strong>的<strong><strong>10.9</strong></strong>）**</p>
<ul>
<li>AFURLSessionManager</li>
<li>AFHTTPSessionManager</li>
</ul>
<p><strong>序列化</strong></p>
<ul>
<li><afurlrequestserialization>- AFHTTPRequestSerializer</afurlrequestserialization></li>
<li>AFJSONRequestSerializer</li>
<li>AFPropertyListRequestSerializer</li>
</ul>
<ul>
<li><afurlresponseserialization>- AFHTTPResponseSerializer</afurlresponseserialization></li>
<li>AFJSONResponseSerializer</li>
<li>AFXMLParserResponseSerializer</li>
<li>AFXMLDocumentResponseSerializer （Mac OS X中）</li>
<li>AFPropertyListResponseSerializer</li>
<li>AFImageResponseSerializer</li>
<li>AFCompoundResponseSerializer</li>
</ul>
<p><strong>附加功能</strong></p>
<ul>
<li>AFSecurityPolicy</li>
<li>AFNetworkReachabilityManager</li>
</ul>
<p><strong>用法</strong><br><strong>HTTP**</strong>请求营运经理<strong><br>AFHTTPRequestOperationManager封装与Web应用程序进行通信通过HTTP，包括要求制作，响应序列化，网络可达性监控和安全性，以及要求经营管理的常见模式。
</strong>GET<strong>**请求</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line">[manager GET:<span class="string">@"http://example.com/resources.json"</span> parameters:<span class="literal">nil</span> success:^(AFHTTPRequestOperation*operation, <span class="keyword">id</span> responseObject) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line">} failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span>*error) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">}];</div></pre></td></tr></table></figure>

<p><strong>POST**</strong>的<strong><strong>URL</strong></strong>格式编码的请求**</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line"><span class="built_in">NSDictionary</span> *parameters = @{<span class="string">@"foo"</span>:<span class="string">@"bar"</span>};</div><div class="line">[manager POST:<span class="string">@"http://example.com/resources.json"</span> parameters:parameters success:^(AFHTTPRequestOperation*operation, <span class="keyword">id</span> responseObject) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line">} failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span>*error) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">}];</div></pre></td></tr></table></figure>

<p><strong>POST**</strong>多部分请求**</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line"><span class="built_in">NSDictionary</span> *parameters = @{<span class="string">@"foo"</span>:<span class="string">@"bar"</span>};</div><div class="line"><span class="built_in">NSURL</span> *filePath = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.png"</span>];</div><div class="line">[manager POST:<span class="string">@"http://example.com/resources.json"</span> parameters:parameters constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) {</div><div class="line">    [formData appendPartWithFileURL:filePath name:<span class="string">@"image"</span> error:<span class="literal">nil</span>];</div><div class="line">} success:^(AFHTTPRequestOperation *operation,<span class="keyword">id</span> responseObject) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Success: %@"</span>, responseObject);</div><div class="line">} failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span>*error) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">}];</div></pre></td></tr></table></figure>

<p><strong>AFURLSessionManager</strong><br>AFURLSessionManager创建和管理一个NSURLSession根据指定的对象NSURLSessionConfiguration对象，这符合<nsurlsessiontaskdelegate> ， <nsurlsessiondatadelegate> ， <nsurlsessiondownloaddelegate>和<nsurlsessiondelegate> 。<br><strong>创建下载任务</strong></nsurlsessiondelegate></nsurlsessiondownloaddelegate></nsurlsessiondatadelegate></nsurlsessiontaskdelegate></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"></div><div class="line">NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span>*(<span class="built_in">NSURL</span> *targetPath, NSURLResponse *response) {</div><div class="line">    <span class="built_in">NSURL</span> *documentsDirectoryPath = [<span class="built_in">NSURL</span> fileURLWithPath:[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,<span class="literal">YES</span>) firstObject]];</div><div class="line">    <span class="keyword">return</span> [documentsDirectoryPath URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">} completionHandler:^(NSURLResponse *response, <span class="built_in">NSURL</span>*filePath, <span class="built_in">NSError</span> *error) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">}];</div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>

<p><strong>创建上传任务</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *filePath = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.png"</span>];</div><div class="line">NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:<span class="literal">nil</span> completionHandler:^(NSURLResponse*response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span>*error) {</div><div class="line">    <span class="keyword">if</span> (error) {</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Success: %@ %@"</span>, response, responseObject);</div><div class="line">    }</div><div class="line">}];</div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>

<p><strong>创建上传任务的多部分请求，与进展</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span> URLString:<span class="string">@"http://example.com/upload"</span> parameters:<span class="literal">nil</span> constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) {</div><div class="line">        [formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.jpg"</span>] name:<span class="string">@"file"</span> fileName:<span class="string">@"filename.jpg"</span> mimeType:<span class="string">@"image/jpeg"</span> error:<span class="literal">nil</span>];</div><div class="line">    } error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">    NSProgress *progress = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&progress completionHandler:^(NSURLResponse*response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span>*error) {</div><div class="line">        <span class="keyword">if</span> (error) {</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">        }</div><div class="line">    }];</div><div class="line"></div><div class="line">    [uploadTask resume];</div></pre></td></tr></table></figure>

<p><strong>创建数据任务</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"></div><div class="line">NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse*response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span>*error) {</div><div class="line">    <span class="keyword">if</span> (error) {</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">    }</div><div class="line">}];</div><div class="line">[dataTask resume];</div></pre></td></tr></table></figure>

<p><strong>请求序列化</strong><br>请求序列化创建URL字符串，编码参数作为一个查询字符串或HTTP主体请求。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *URLString = <span class="string">@"http://example.com"</span>;</div><div class="line"><span class="built_in">NSDictionary</span> *parameters = @{<span class="string">@"foo"</span>:<span class="string">@"bar"</span>, <span class="string">@"baz"</span>: @[@<span class="number">1</span>,@<span class="number">2</span>, @<span class="number">3</span>]};</div></pre></td></tr></table></figure>

<p><strong>查询字符串参数编码</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> [[AFHTTPRequestSerializer serializer] requestWithMethod:<span class="string">@"GET"</span> URLString:URLString parameters:parameters];</div><div class="line">GET http:<span class="comment">//example.com?foo=bar&baz[]=1&baz[]=2&baz[]=3</span></div></pre></td></tr></table></figure>

<p><strong>URL**</strong>，表单参数编码**</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[AFHTTPRequestSerializer serializer] requestWithMethod:<span class="string">@"POST"</span> URLString:URLString parameters:parameters];</div><div class="line"></div><div class="line">POST http:<span class="comment">//example.com/</span></div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">foo=bar&baz[]=<span class="number">1</span>&baz[]=<span class="number">2</span>&baz[]=<span class="number">3</span></div></pre></td></tr></table></figure>

<p><strong>JSON**</strong>编码参数**</p>
<hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[AFJSONRequestSerializer serializer] requestWithMethod:<span class="string">@"POST"</span> URLString:URLString parameters:parameters];</div><div class="line">POST http:<span class="comment">//example.com/</span></div><div class="line">Content-Type: application/json</div><div class="line"></div><div class="line">{<span class="string">"foo"</span>: <span class="string">"bar"</span>, <span class="string">"baz"</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]}</div></pre></td></tr></table></figure>

<p><strong>网络可达性管理</strong><br>AFNetworkReachabilityManager监控领域的可达性，并为WWAN和WiFi网络接口的地址。<br><strong>共享网络可达性</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> [[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reachability: %@"</span>, AFStringFromNetworkReachabilityStatus(status));</div><div class="line">}];</div></pre></td></tr></table></figure>

<p><strong>与基本**</strong>URL<strong><strong>的</strong></strong>HTTP<strong>**经理</strong><br>当baseURL提供，网络可达性的作用范围是该基地URL的主机。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  <span class="built_in">NSURL</span> *baseURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/"</span>];</div><div class="line">AFHTTPRequestOperationManager *manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:baseURL];</div><div class="line"></div><div class="line">NSOperationQueue *operationQueue = manager<span class="variable">.operationQueue</span>;</div><div class="line">[manager<span class="variable">.reachabilityManager</span> setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {</div><div class="line">    <span class="keyword">switch</span> (status) {</div><div class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWWAN:</div><div class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWiFi:</div><div class="line">            [operationQueue setSuspended:<span class="literal">NO</span>];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusNotReachable:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            [operationQueue setSuspended:<span class="literal">YES</span>];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">}];</div></pre></td></tr></table></figure>

<p><strong>安全策略</strong><br>AFSecurityPolicy评估对固定X.509证书和通过安全连接的公共密钥服务器信任。<br>新增固定SSL证书到你的应用有助于防止人在这方面的中间人攻击和其他安全漏洞。 应用程序处理敏感的客户数据或财务信息我们强烈建议路线在使用SSL钉扎配置和启用HTTPS连接的所有通信。<br><strong>使无效的**</strong>SSL<strong>**证书</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line">manager<span class="variable">.securityPolicy</span><span class="variable">.allowInvalidCertificates</span> =<span class="literal">YES</span>; <span class="comment">// 不建议在生产</span></div></pre></td></tr></table></figure>

<p><strong>AFHTTPRequestOperation</strong><br>AFHTTPRequestOperation是的一个子类AFURLConnectionOperation使用HTTP或HTTPS协议请求。 它封装的接受状态代码和内容类型，这决定了请求的成功或失败的概念。<br>虽然AFHTTPRequestOperationManager通常是去提出要求的最佳途径， AFHTTPRequestOperation可以单独使用。<br><strong>GET **</strong>with <strong>**AFHTTPRequestOperation</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/resources/123.json"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line">AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];</div><div class="line">op<span class="variable">.responseSerializer</span> = [AFJSONResponseSerializer serializer];</div><div class="line">[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation*operation, <span class="keyword">id</span> responseObject) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line">} failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span>*error) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">}];</div><div class="line">[[NSOperationQueue mainQueue] addOperation:op];</div></pre></td></tr></table></figure>

<p><strong>操作的批处理</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *mutableOperations = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> filesToUpload) {</div><div class="line">    <span class="built_in">NSURLRequest</span> *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span> URLString:<span class="string">@"http://example.com/upload"</span> parameters:<span class="literal">nil</span> constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) {</div><div class="line">        [formData appendPartWithFileURL:fileURL name:<span class="string">@"images[]"</span> error:<span class="literal">nil</span>];</div><div class="line">    }];</div><div class="line"></div><div class="line">    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];</div><div class="line"></div><div class="line">    [mutableOperations addObject:operation];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *operations = [AFURLConnectionOperation batchOfRequestOperations:@[...] progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu of %lu complete"</span>, numberOfFinishedOperations, totalNumberOfOperations);</div><div class="line">} completionBlock:^(<span class="built_in">NSArray</span> *operations) {</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"All operations in batch complete"</span>);</div><div class="line">}];</div><div class="line">[[NSOperationQueue mainQueue] addOperations:operations waitUntilFinished:<span class="literal">NO</span>];</div></pre></td></tr></table></figure>

<p><strong>单元测试</strong><br>AFNetworking包括一套内部的测试子目录中的单元测试。 为了运行单元测试，你必须通过CocoaPods安装测试的依赖关系：<br> $ cd Tests<br> $ pod install<br>一旦测试的依赖安装，你可以通过在Xcode的’的iOS测试“和”OS X的测试“计划，执行测试套件。<br><strong>使用**</strong>xctool**<br>测试也可以通过命令行或在一个持续集成环境中运行<a href="https://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=https://github.com/facebook/xctool&amp;usg=ALkJrhh4GfmYPHkGwnNuhhM4ZAaZUQimtA" target="_blank" rel="external">xctool</a> ，它可以安装<a href="http://translate.googleusercontent.com/translate_c?act=url&amp;depth=1&amp;hl=zh-CN&amp;ie=UTF8&amp;prev=_t&amp;rurl=translate.google.com.hk&amp;sl=en&amp;tl=zh-CN&amp;u=http://brew.sh/&amp;usg=ALkJrhgZ5Ck7uZtrBWPhQ0ujWkOqvbg1ZA" target="_blank" rel="external">自制软件</a> ：<br> $ brew update<br> $ brew install xctool —HEAD<br>一旦xctool安装，你可以通过执行该套件rake test 。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/AFNetworking/">AFNetworking</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2013-09-02T00:54:00.000Z"><a href="/2013/09/02/上传下载和文件操作/">9月 2 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/02/上传下载和文件操作/">上传下载和文件操作</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>POST上传</p>
<pre><code><span class="comment">//1.生成url   后面不跟参数</span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSURL *url = [NSURL URLWithString:@"http://127.0.0.1:8080/UD/u?command=1"];</div></pre></td></tr></table></figure>

<pre><code><span class="comment">//2.生成可变的请求</span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];</div></pre></td></tr></table></figure>

<pre><code><span class="comment">//3.超时事件 </span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[request setTimeoutInterval:20];</div></pre></td></tr></table></figure>

<pre><code><span class="comment">//4.POST请求</span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[request setHTTPMethod:@"POST"];</div></pre></td></tr></table></figure>

<pre><code>//<span class="number">5.</span>设置Content-Type 在服务器可获得<span class="command"><span class="keyword">command</span></span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[request addValue:@"multipart/form-data" forHTTPHeaderField:@"Content-Type"];</div></pre></td></tr></table></figure>

<pre><code>//<span class="number">5.1</span>用沙盒目录下工程资源路径获得<span class="typedef"><span class="keyword">data</span></span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//    NSString *path = [[NSBundle mainBundle] pathForResource:@"2" ofType:@"jpg"];</div><div class="line">//    NSData *data = [NSData dataWithContentsOfFile:path];</div></pre></td></tr></table></figure>

<pre><code><span class="comment">//6.获取工程的image</span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    UIImage *image = [UIImage imageNamed:@"2.jpg"];</div><div class="line">//    UIImagePNGRepresentation(<#uiimage *image#="">);</#uiimage></div><div class="line">    //7.将image以JPEG格式压缩为data</div><div class="line">    NSData *data = UIImageJPEGRepresentation(image, 0.5);</div></pre></td></tr></table></figure>

<pre><code><span class="comment">//8.将数据添加至请求</span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[request setHTTPBody:data];</div></pre></td></tr></table></figure>

<pre><code>//<span class="number">8.1</span>将<span class="typedef"><span class="keyword">data</span>追加在请求数据中</span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//    NSInputStream *inputStream = [[NSInputStream alloc] initWithFileAtPath:path];</div><div class="line">//    [request setHTTPBodyStream:inputStream];</div></pre></td></tr></table></figure>

<pre><code><span class="comment">//9.发起请求,上传文件</span>
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[NSURLConnection connectionWithRequest:request delegate:self];</div></pre></td></tr></table></figure>

<p>服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">String command = request.getParameter("command");</div><div class="line">        System.out.println("-----------" + command);</div><div class="line"></div><div class="line">        //获得当前数据的长度（其实就是图片数据的大小）</div><div class="line">         int length = request.getContentLength();</div><div class="line">        //创建一个字节数组，用来存放接收到的图片数据</div><div class="line">         byte []buffer = new byte[length];</div><div class="line"></div><div class="line">        //获得servlet的输入流（输入通道）</div><div class="line">        ServletInputStream input = request.getInputStream();</div><div class="line"></div><div class="line"></div><div class="line">        for(int i=0; i<length; i++)<="" div=""><div class="line">        {</div><div class="line">            //从输入通道中读取数据，每次读一个字节</div><div class="line">            buffer[i] = (byte) input.read();</div><div class="line">        }</div><div class="line"></div><div class="line">        //FileInputStream  文件的输入流是读取牟高峰路径下的文件信息的</div><div class="line"></div><div class="line">        //创建一个文件的输出流，把内存中的数据写到本地</div><div class="line">        FileOutputStream output = new FileOutputStream("/Users/wxg/Desktop/test.jpg");</div><div class="line">        output.write(buffer);</div><div class="line">        //写完之后要关闭输出流</div><div class="line">        output.close();</div><div class="line"></div><div class="line">        out.println("文件上传成功");</div></length;></div></pre></td></tr></table></figure>

<p>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//获得沙盒目录Documents文件路径  返回添加文件夹路径</div><div class="line">-(NSString *)getFilePathWith:(NSString *)aPath</div><div class="line">{</div><div class="line">    return [NSHomeDirectory() stringByAppendingPathComponent:[NSString stringWithFormat:@"Documents/%@", aPath]];</div><div class="line">}</div><div class="line">- (void)viewDidLoad {</div><div class="line">    [super viewDidLoad];</div><div class="line">//1.文件管理器创建</div><div class="line">    NSFileManager *manager = [NSFileManager defaultManager];</div><div class="line">    //2.判断路径下是否有该文件夹</div><div class="line">    if (![manager fileExistsAtPath:[self getFilePathWith:@"Download"]])</div><div class="line">        {</div><div class="line">        //2.1创建文件夹</div><div class="line">        //        路径  过渡目录  描述信息  错误信息</div><div class="line">        [manager createDirectoryAtPath:[self getFilePathWith:@"Download"] withIntermediateDirectories:YES attributes:nil error:nil];</div><div class="line">    }</div><div class="line">    //3.生成文件目录</div><div class="line">    NSString *path = [self getFilePathWith:@"Download/test.dmg"];</div><div class="line">    //4.判断路径下是否有该文件</div><div class="line">    if (![manager fileExistsAtPath:path]) {</div><div class="line">        //4.1创建文件</div><div class="line">//        创建一个文件  文件路径  内容  描述信息</div><div class="line">        [manager createFileAtPath:path contents:nil attributes:nil];</div><div class="line">    }</div><div class="line">    //5.</div><div class="line">    _handel = [[NSFileHandle fileHandleForWritingAtPath:path] retain];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>xcode 文件操作</p>
<p>对文件的操作是一项很基本的人际交互过程，这里简单总结一下常用的文件操作内容<br>1.沙盒的概念<br>沙盒是iPhone开发中的一个特有的概念，指的是程序运行时的存储空间范围。<br>出于对安全的考虑，苹果把iPhone中运行的程序限定在一个文件夹内，用户的任何操作都只能在这个文件夹内完成，绝不允许用户访问这个文件夹外的任何文件夹，这个限定文件夹就是“沙盒”。<br>可以这样理解，你的程序就像被关在一个装满沙子的盒子里面，无论你的程序怎么折腾，也不过是在沙子上留下点痕迹而已，就算出了再大的问题，用手一抹就恢复原状了。</p>
<p>2.获取路径<br>沙盒中默认有三个目录Documents、Library和tmp。而我们通常把文件存储在Documents中。获取其路径的方法如下：<br>//获取Document文件夹路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSArray*path=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES);</div><div class="line">NSString *pathDocuments=[path objectAtIndex:0];</div></pre></td></tr></table></figure>

<p>可以看到，第一次获取的地址其实是一个数组，我们取出其中的第一项才是我们想要获取的路径。那么当然可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *pathDocuments=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];</div></pre></td></tr></table></figure>

<p>3.创建文件与将内容写入文件<br>我们之前获取的路径是目录的路径，所以我们需要手动为其补全为文件路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSString *createFileName=@"new.txt";//文件名</div><div class="line">NSString *createPath=[NSString stringWithFormat:@"%@/%@",pathDocuments,createFileName];//用文件名补全路径</div><div class="line">if ([[NSFileManager defaultManager] fileExistsAtPath:createPath])//判断文件是否已存在</div><div class="line">{</div><div class="line">NSLog(@"文件已存在！");</div><div class="line">}</div><div class="line">else</div><div class="line">{</div><div class="line">NSData *data = [@"这里是新文件的内容" dataUsingEncoding:NSUTF8StringEncoding];//新文件的初始数据</div><div class="line">[[NSFileManager defaultManager] createFileAtPath:createPath contents:data attributes:nil];//创建文件</div><div class="line">}</div></pre></td></tr></table></figure>

<p>多种对象类型都有直接写入文件的方法<br>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[userInfoDict writeToFile:filePath atomically:YES];</div></pre></td></tr></table></figure>

<p>4.删除文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *deletePath=[NSString stringWithFormat:@"%@/%@",pathDocuments,fileName];//补全文件名</div><div class="line">NSLog(@"%@",deletePath);</div><div class="line">NSError *error;</div><div class="line">[fileManager removeItemAtPath:deletePath error:&error];</div></pre></td></tr></table></figure>

<p>5.读取文件<br>多种类型的对象创建时都可以直接从文件获取数据，但是切记要用完整路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSArray *readArray=[NSArray arrayWithContentsOfFile:filePath];</div><div class="line">NSDictionary *readDict=[NSDictionary dictionaryWithContentsOfFile:filePath];</div><div class="line">UIImage *readImage=[UIImage imageWithContentsOfFile:filePath];</div></pre></td></tr></table></figure>

<p>6.获取文件信息<br>获取文件信息是fileManager的一个方法，信息包括文件的创建时间，修改时间，是否隐藏扩展名，以及文件大小等属性。<br>使用方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSFileManager *fileMng=[[NSFileManager alloc] init];</div><div class="line">NSDictionary *attrDict=[fileMng attributesOfItemAtPath:filePath error:NULL];</div></pre></td></tr></table></figure>

<p>文件信息保存在attrDict中</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/存储/">存储</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/iphone开发/">iphone开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2013-08-29T00:38:00.000Z"><a href="/2013/08/29/服务器临时存储数据/">8月 29 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/08/29/服务器临时存储数据/">服务器临时存储数据</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//关键字class声明一个类  class相当于oc中的@interface</span></div><div class="line"><span class="comment">//类名 Uesr 当前看似没有继承关系 其实是继承自Object，凡是继承自Object的类，继承关系可以不写</span></div><div class="line"><span class="comment">//继承不是oc中的“：”而是extends</span></div><div class="line"><span class="comment">//java类的声明和实现在一个文件中，而且在类中无论什么地方都可以声明变量</span></div><div class="line"></div><div class="line"><span class="comment">//public 共有的 在所有类中可用</span></div><div class="line"><span class="comment">//private 私有的 只有在本类中可用</span></div><div class="line"><span class="comment">//protected 受保护的  在同一个包中可用，在子类中可用</span></div><div class="line">public class User1 {</div><div class="line"></div><div class="line"><span class="comment">//    属性一般声明为私有的</span></div><div class="line"><span class="comment">//    提供get set 方法类取值 赋值</span></div><div class="line">    private String name;</div><div class="line">    private String psw;</div><div class="line">    private String tname;</div><div class="line">    private String email;</div><div class="line"></div><div class="line"><span class="comment">//    int age;</span></div><div class="line"><span class="comment">//    boolean sex;</span></div><div class="line"><span class="comment">//    float height;</span></div><div class="line"></div><div class="line"><span class="comment">//    无参构造函数  构造函数没有返回值 函数名即类名</span></div><div class="line">    public User1() {</div><div class="line">    }</div><div class="line"></div><div class="line">    public User1(String name, String psw) {</div><div class="line">        <span class="keyword">this</span><span class="variable">.name</span> = name;</div><div class="line">        <span class="keyword">this</span><span class="variable">.psw</span> = psw;</div><div class="line">    }</div><div class="line"></div><div class="line">    public User1(String name, String psw, String tname, String email) {</div><div class="line">        <span class="keyword">this</span><span class="variable">.name</span> = name;</div><div class="line">        <span class="keyword">this</span><span class="variable">.psw</span> = psw;</div><div class="line">        <span class="keyword">this</span><span class="variable">.tname</span> = tname;</div><div class="line">        <span class="keyword">this</span><span class="variable">.email</span> = email;</div><div class="line">    }</div><div class="line"><span class="comment">//哈希表创建</span></div><div class="line">public class a extends HttpServlet {</div><div class="line">    </div><div class="line">    </div><div class="line">Hashtable hastable;</div><div class="line"></div><div class="line">    public a()</div><div class="line">    {</div><div class="line">        hastable = new Hashtable();</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">//trim()去空格的</span></div><div class="line">        String command = request<span class="variable">.getParameter</span>(<span class="string">"command"</span>)<span class="variable">.trim</span>();</div><div class="line"><span class="comment">//数据类型转换</span></div><div class="line">Integer<span class="variable">.parseInt</span>(command)</div><div class="line"></div><div class="line"><span class="comment">//从哈希表中根据键值取出一个对象</span></div><div class="line">User aUser = (User) members<span class="variable">.get</span>(name);</div><div class="line"></div><div class="line"><span class="comment">//创建一个对象,向哈希表添加,以name为key user为values</span></div><div class="line">User user = new User(name,psw,truename,email);</div><div class="line">                    members<span class="variable">.put</span>(name, user);</div><div class="line">                   </div><div class="line"><span class="comment">// members.put(key, values)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//比较字符串是否相同  .equals</span></div><div class="line">psw<span class="variable">.equals</span>(user<span class="variable">.getPsw</span>()</div><div class="line"></div><div class="line"><span class="comment">//获得哈希表所有的key</span></div><div class="line">Enumeration enumer = members<span class="variable">.keys</span>();</div><div class="line"></div><div class="line"><span class="comment">//一直运行到哈希表最后一个对象,运行keys的长度的次数</span></div><div class="line"><span class="keyword">while</span> (enumer<span class="variable">.hasMoreElements</span>())</div><div class="line">                    {</div><div class="line">            <span class="comment">//取出当前哈希表对象的key</span></div><div class="line">            String key = (String) enumer<span class="variable">.nextElement</span>();</div><div class="line">            <span class="comment">//xml方式回送数据,以自定义标签对的形式返回数据</span></div><div class="line">            </div><div class="line">                User tempUser = (User) members<span class="variable">.get</span>(key);</div><div class="line">    </div><div class="line">                                <span class="keyword">out</span><span class="variable">.println</span>(<span class="string">"&lt;user&gt;"</span>);</div><div class="line">                            <span class="keyword">out</span><span class="variable">.println</span>(<span class="string">"&lt;name&gt;"</span> + tempUser<span class="variable">.getName</span>() +<span class="string">"&lt;/name&gt;"</span>);</div><div class="line">                            <span class="keyword">out</span><span class="variable">.println</span>(<span class="string">"&lt;tname&gt;"</span> + tempUser<span class="variable">.getTruename</span>() +<span class="string">"&lt;/tname&gt;"</span>);</div><div class="line">                            <span class="keyword">out</span><span class="variable">.println</span>(<span class="string">"&lt;email&gt;"</span> + tempUser<span class="variable">.getEmail</span>() +<span class="string">"&lt;/email&gt;"</span>);</div><div class="line">                            <span class="keyword">out</span><span class="variable">.println</span>(<span class="string">"&lt;/user&gt;"</span>);</div><div class="line"></div><div class="line"></div><div class="line">        }</div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2013-08-29T00:35:00.000Z"><a href="/2013/08/29/IOS之同步请求、异步请求、GET请求、POST请求/">8月 29 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/08/29/IOS之同步请求、异步请求、GET请求、POST请求/">IOS之同步请求、异步请求、GET请求、POST请求</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>1、同步请求可以从因特网请求数据，一旦发送同步请求，程序将停止用户交互，直至服务器返回数据完成，才可以进行下一步操作，<br>2、异步请求不会阻塞主线程，而会建立一个新的线程来操作，用户发出异步请求后，依然可以对UI进行操作，程序可以继续运行<br>3、GET请求，将参数直接写在访问路径上。操作简单，不过容易被外界看到，安全性不高，地址最多255字节；<br>4、POST请求，将参数放到body里面。POST请求操作相对复杂，需要将参数和地址分开，不过安全性高，参数放在body里面，不易被捕获。</p>
<p>1、同步GET请求<br>第一步，创建URL</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:@[http:<span class="comment">//api.hudong.com/iphonexml.do?type=focus-c](http://api.hudong.com/iphonexml.do?type=focus-c)];</span></div></pre></td></tr></table></figure>

<p>第二步，通过URL创建网络请求</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:<span class="number">10</span>];</div></pre></td></tr></table></figure>

<p>//NSURLRequest初始化方法第一个参数：请求访问路径，第二个参数：缓存协议，第三个参数：网络请求超时时间（秒）</p>
<p>其中缓存协议是个枚举类型包含：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSURLRequestUseProtocolCachePolicy（基础策略）</div><div class="line">NSURLRequestReloadIgnoringLocalCacheData（忽略本地缓存）</div><div class="line"> NSURLRequestReturnCacheDataElseLoad（首先使用缓存，如果没有本地缓存，才从原地址下载）</div><div class="line">NSURLRequestReturnCacheDataDontLoad（使用本地缓存，从不下载，如果本地没有缓存，则请求失败，此策略多用于离线操作）</div><div class="line">NSURLRequestReloadIgnoringLocalAndRemoteCacheData（无视任何缓存策略，无论是本地的还是远程的，总是从原地址重新下载）</div><div class="line">NSURLRequestReloadRevalidatingCacheData（如果本地缓存是有效的则不下载，其他任何情况都从原地址重新下载）</div></pre></td></tr></table></figure>

<p>第三步，连接服务器</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSData *received = [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc]initWithData:received encoding:NSUTF8StringEncoding];</div></pre></td></tr></table></figure>

<p>2、同步POST请求<br>第一步，创建URL</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:@[http:<span class="comment">//api.hudong.com/iphonexml.do](http://api.hudong.com/iphonexml.do)];</span></div></pre></td></tr></table></figure>

<p>第二步，创建请求</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:<span class="number">10</span>];</div><div class="line"> [request setHTTPMethod:<span class="string">@"POST"</span>];<span class="comment">//设置请求方式为POST，默认为GET</span></div><div class="line"> <span class="built_in">NSString</span> *str = <span class="string">@"type=focus-c"</span>;<span class="comment">//设置参数</span></div><div class="line">NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line"> [request setHTTPBody:data];</div></pre></td></tr></table></figure>

<p>第三步，连接服务器</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> NSData *received = [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSString</span> *str1 = [[<span class="built_in">NSString</span> alloc]initWithData:received encoding:NSUTF8StringEncoding];</div></pre></td></tr></table></figure>

<p>3、异步GET请求</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一步，创建url</span></div><div class="line">  <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://api.hudong.com/iphonexml.do?type=focus-c"</span>];</div><div class="line"><span class="comment">//第二步，创建请求</span></div><div class="line"><span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:<span class="number">10</span>];</div><div class="line"><span class="comment">//第三步，连接服务器</span></div><div class="line"> <span class="built_in">NSURLConnection</span> *connection = [[<span class="built_in">NSURLConnection</span> alloc]initWithRequest:request delegate:<span class="keyword">self</span>];</div></pre></td></tr></table></figure>

<p>4、异步POST请求</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一步，创建url</span></div><div class="line"> <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://api.hudong.com/iphonexml.do"</span>];</div><div class="line"><span class="comment">//第二步，创建请求</span></div><div class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:<span class="number">10</span>];</div><div class="line">[request setHTTPMethod:<span class="string">@"POST"</span>];</div><div class="line"><span class="built_in">NSString</span> *str = <span class="string">@"type=focus-c"</span>;</div><div class="line">  NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line">[request setHTTPBody:data];</div><div class="line"> </div><div class="line"><span class="comment">//第三步，连接服务器</span></div><div class="line"><span class="built_in">NSURLConnection</span> *connection = [[<span class="built_in">NSURLConnection</span> alloc]initWithRequest:request delegate:<span class="keyword">self</span>];</div></pre></td></tr></table></figure>

<p>5、异步请求的代理方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//接收到服务器回应的时候调用此方法</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(NSURLResponse *)response</div><div class="line">{</div><div class="line">     NSHTTPURLResponse *res = (NSHTTPURLResponse *)response;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[res allHeaderFields]);</div><div class="line">    <span class="keyword">self</span><span class="variable">.receiveData</span> = [NSMutableData data];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//接收到服务器传输数据的时候调用，此方法根据数据大小执行若干次</span></div><div class="line">-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(NSData *)data</div><div class="line">{</div><div class="line">    [<span class="keyword">self</span><span class="variable">.receiveData</span> appendData:data];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//数据传完之后调用此方法</span></div><div class="line">-(<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</div><div class="line">{</div><div class="line">    <span class="built_in">NSString</span> *receiveStr = [[<span class="built_in">NSString</span> alloc]initWithData:<span class="keyword">self</span><span class="variable">.receiveData</span> encoding:NSUTF8StringEncoding];</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,receiveStr);</div><div class="line">}</div></pre></td></tr></table></figure>



      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  
    <form>
      <input id="st-search-input" type="search" placeholder="Search">
    </form>
    <div id="st-results-container"></div>
  
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <div class="entry">
    
      <span><a href="/tags/2d/">2d<small>1</small></a></span>
    
      <span><a href="/tags/AFNetworking/">AFNetworking<small>2</small></a></span>
    
      <span><a href="/tags/CoreData/">CoreData<small>2</small></a></span>
    
      <span><a href="/tags/Drawing/">Drawing<small>1</small></a></span>
    
      <span><a href="/tags/MagicalRecord/">MagicalRecord<small>1</small></a></span>
    
      <span><a href="/tags/NSDate/">NSDate<small>1</small></a></span>
    
      <span><a href="/tags/NSString/">NSString<small>1</small></a></span>
    
      <span><a href="/tags/Swift/">Swift<small>9</small></a></span>
    
      <span><a href="/tags/UIAlertView/">UIAlertView<small>1</small></a></span>
    
      <span><a href="/tags/UITabBarController/">UITabBarController<small>1</small></a></span>
    
      <span><a href="/tags/UITableViewControlle/">UITableViewControlle<small>1</small></a></span>
    
      <span><a href="/tags/UIWebView/">UIWebView<small>1</small></a></span>
    
      <span><a href="/tags/URL-Scheme/">URL Scheme<small>1</small></a></span>
    
      <span><a href="/tags/URL编码/">URL编码<small>1</small></a></span>
    
      <span><a href="/tags/XMPP/">XMPP<small>3</small></a></span>
    
      <span><a href="/tags/Xcode5-1/">Xcode5.1<small>1</small></a></span>
    
      <span><a href="/tags/api/">api<small>5</small></a></span>
    
      <span><a href="/tags/appStore审核/">appStore审核<small>1</small></a></span>
    
      <span><a href="/tags/block/">block<small>1</small></a></span>
    
      <span><a href="/tags/bytearray/">bytearray<small>1</small></a></span>
    
      <span><a href="/tags/cell自适应高度/">cell自适应高度<small>1</small></a></span>
    
      <span><a href="/tags/cocos2d/">cocos2d<small>3</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发font/">fontfontiPhone开发font<small>1</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发fontfont/">fontfontiPhone开发fontfont<small>1</small></a></span>
    
      <span><a href="/tags/fontfontios的fontfont/">fontfontios的fontfont<small>2</small></a></span>
    
      <span><a href="/tags/fontfont动画fontfont/">fontfont动画fontfont<small>1</small></a></span>
    
      <span><a href="/tags/framework/">framework<small>1</small></a></span>
    
      <span><a href="/tags/iOS8/">iOS8<small>2</small></a></span>
    
      <span><a href="/tags/iOS8-1-1/">iOS8.1.1<small>1</small></a></span>
    
      <span><a href="/tags/iOS8定位/">iOS8定位<small>1</small></a></span>
    
      <span><a href="/tags/iOS国际化/">iOS国际化<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之app上架/">iOS应用开发之app上架<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之第三方框架/">iOS应用开发之第三方框架<small>1</small></a></span>
    
      <span><a href="/tags/iOS开发/">iOS开发<small>5</small></a></span>
    
      <span><a href="/tags/iOS自定义Tabbar/">iOS自定义Tabbar<small>1</small></a></span>
    
      <span><a href="/tags/ios/">ios<small>53</small></a></span>
    
      <span><a href="/tags/ios7/">ios7<small>1</small></a></span>
    
      <span><a href="/tags/ios7适配/">ios7适配<small>1</small></a></span>
    
      <span><a href="/tags/ios国际化/">ios国际化<small>1</small></a></span>
    
      <span><a href="/tags/ios开发/">ios开发<small>27</small></a></span>
    
      <span><a href="/tags/iphone/">iphone<small>4</small></a></span>
    
      <span><a href="/tags/iphone开发/">iphone开发<small>59</small></a></span>
    
      <span><a href="/tags/itunes/">itunes<small>1</small></a></span>
    
      <span><a href="/tags/objective-c/">objective-c<small>1</small></a></span>
    
      <span><a href="/tags/svn/">svn<small>1</small></a></span>
    
      <span><a href="/tags/uiimage/">uiimage<small>2</small></a></span>
    
      <span><a href="/tags/uitableview/">uitableview<small>1</small></a></span>
    
      <span><a href="/tags/uitableviewcell/">uitableviewcell<small>1</small></a></span>
    
      <span><a href="/tags/uitextfield/">uitextfield<small>1</small></a></span>
    
      <span><a href="/tags/uiview/">uiview<small>3</small></a></span>
    
      <span><a href="/tags/uiviewcontroller/">uiviewcontroller<small>1</small></a></span>
    
      <span><a href="/tags/uiwebview/">uiwebview<small>1</small></a></span>
    
      <span><a href="/tags/xcode/">xcode<small>2</small></a></span>
    
      <span><a href="/tags/xmpp/">xmpp<small>1</small></a></span>
    
      <span><a href="/tags/二维码/">二维码<small>1</small></a></span>
    
      <span><a href="/tags/企业/">企业<small>1</small></a></span>
    
      <span><a href="/tags/动画/">动画<small>5</small></a></span>
    
      <span><a href="/tags/国际化/">国际化<small>1</small></a></span>
    
      <span><a href="/tags/在线工具/">在线工具<small>1</small></a></span>
    
      <span><a href="/tags/多线程/">多线程<small>1</small></a></span>
    
      <span><a href="/tags/存储/">存储<small>1</small></a></span>
    
      <span><a href="/tags/宏/">宏<small>1</small></a></span>
    
      <span><a href="/tags/导航/">导航<small>1</small></a></span>
    
      <span><a href="/tags/屏幕旋转/">屏幕旋转<small>2</small></a></span>
    
      <span><a href="/tags/应用程序/">应用程序<small>2</small></a></span>
    
      <span><a href="/tags/微信开放平台ios/">微信开放平台ios<small>1</small></a></span>
    
      <span><a href="/tags/打开AppStore/">打开AppStore<small>1</small></a></span>
    
      <span><a href="/tags/数据库/">数据库<small>1</small></a></span>
    
      <span><a href="/tags/缓存/">缓存<small>1</small></a></span>
    
      <span><a href="/tags/聊天/">聊天<small>1</small></a></span>
    
      <span><a href="/tags/苹果应用商店/">苹果应用商店<small>1</small></a></span>
    
      <span><a href="/tags/获取iP地址/">获取iP地址<small>1</small></a></span>
    
  </div>
</div>




  <script type="text/javascript">
    (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
    })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

    _st('install','6xH6jcZvsZxn2a9rcU4t');
  </script>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div id="foot-nav">
  <ul class="social">
    
      <li><a class="github" href="https://github.com/DaiXiang" title="github">github</a></li>
    
      <li><a class="rss" href="/atom.xml" title="rss">rss</a></li>
    
  </ul>
</div>
<div>
  
    &copy; 2014 尹现伟
  
</div>
<div class="clearfix"></div></footer>
  


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<script type="text/javascript">
  function navbar() {
    var top = $('#nav-top').innerHeight();
    $('#header').css('min-height', top);
  }
  navbar();
  $(window).resize(navbar);
</script>
<div id="totop" class="footer-btn">
  <a title="Return to Top"><img src="/img/scrollup.png"/></a>
</div>

<script type="text/javascript">
  $(function(){ 
	// When to show the scroll link
	// higher number = scroll link appears further down the page   
	var upperLimit = 800;
	
	// Our scroll link element
	var scrollElem = $('#totop');
   
	// Scroll to top speed
	var scrollSpeed = 500;
   
	// Show and hide the scroll to top link based on scroll position   
	scrollElem.hide();
	$(window).scroll(function () {            
		var scrollTop = $(document).scrollTop();       
		if ( scrollTop > upperLimit ) {
		  $(scrollElem).stop().fadeTo(300, 1); // fade back in
		  $(scrollElem).animate({bottom: "50px"}, { queue: false, duration: 10 });
		} else {
		  $(scrollElem).stop().fadeTo(300, 0); // fade out
	      $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
			
		}
	});

	// Scroll to top animation on click
	$(scrollElem).click(function(){
	  $('html, body').animate({scrollTop:0}, scrollSpeed);
	  $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
	  return false;
	});
  });
</script>
</body>
</html>