<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iphone开发 | 一枝红杏出墙来</title>
  <meta name="author" content="尹现伟">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="一枝红杏出墙来"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="shortcut icon">
  <link rel="alternate" href="/atom.xml" title="一枝红杏出墙来" type="application/atom+xml">
  <link rel="stylesheet" href="/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
  

</head>


<body>
  <header id="header" class="inner"><div id="nav-top">
  <div class="alignleft main-title">
    <h1>一枝红杏出墙来</h1>
    <h2></h2>
  </div>
  <nav id="main-nav" class="alignright">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title tag">iphone开发</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-26T02:07:00.000Z"><a href="/2014/02/26/如何改进iOS App的离线使用体验/">2月 26 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/26/如何改进iOS App的离线使用体验/">如何改进iOS App的离线使用体验</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <h2 id="App_Store中的App分析">App Store中的App分析</h2>
<p>App已经与我们形影不离了，不管在地铁上、公交上还是在会场你总能看到很多人拿出来手机，刷一刷微博，看看新闻。<br>据不完全统计有近一半的用户在非Wifi环境打开App，以下为一个典型iPhone和Android App（50W+用户）的友盟后台数据：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726375773.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726382086.jpg" alt="1" title="1"></a><br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726391398.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726403250.jpg" alt="2" title="2"></a><br>3G、2G的数据连接往往不稳定（特别在公交或者地铁上），这时打开一些App就会像这样：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726451850.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172647539.png" alt="IMG_2159" title="IMG_2159"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726512651.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726521091.png" alt="IMG_2163" title="IMG_2163"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101727107846.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172713863.png" alt="IMG_2160" title="IMG_2160"></a><br>当然也会有一些体验很好的App，在离线状态下也能顺畅使用：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172726622.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101727298830.png" alt="IMG_2149" title="IMG_2149"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101727449787.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172750588.png" alt="IMG_2150" title="IMG_2150"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728085325.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728128767.png" alt="IMG_2161" title="IMG_2161"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728301279.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728369845.png" alt="IMG_2162" title="IMG_2162"></a><br>甚至提供了离线阅读功能：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172846151.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728494804.png" alt="IMG_2158" title="IMG_2158"></a></p>
<h2 id="如何做？">如何做？</h2>
<p>打开过的文章、下载过的音频、查看过的图片我们都希望Cache到本地，下次不用再向服务器请求。<br>首先，我们为了最快让用户看到内容，会在ViewDidLoad加载Cache数据，如：<br>1234<code>-
 (``void``)viewDidLoad
 {</code> <code>``[self
 getArticleList:0 length:SECTION_LENGTH useCacheFirst:YES];``}</code>然后在viewDidAppear中向服务器请求最新数据，如<br>12345678<code>-
 (``void``)viewDidAppear:(``BOOL``)animated
 {`` </code> <code>``[super
 viewDidAppear:animated];</code> <code>``//...</code> <code>``[self
 getArticleList:0 length:SECTION_LENGTH useCacheFirst:NO]``}</code>当然这里的getArticleList接口有useCacheFirst参数，我们需要网络请求模块能够支持这一点，下面就介绍这些库和工具。（借助一些工具很容易能做到这些，而不用自己造轮子。遵循“凡事都应该最简单，而不过于简陋”的原则，这里整理一下，方便项目中使用）。</p>
<h3 id="1-NSMutableURLRequest">1.NSMutableURLRequest</h3>
<p>Sample(参考麒麟的文章《<a href="http://www.cnblogs.com/zhuqil/archive/2011/07/30/2122127.html" target="_blank" rel="external">iOS开发之缓存（一）：内存缓存</a>》来使用NSURLCache)：<br>1234567891011121314151617181920212223242526272829303132<code>NSString
 *paramURLAsString= @``&quot;[http://www.baidu.com/](http://www.baidu.com/)&quot;``;``if</code> <code>([paramURLAsString
 length] == 0){``    ``NSLog(@``&quot;Nil
 or empty URL is given&quot;``);``    ``return``;``}``NSURLCache
 *urlCache = [NSURLCache sharedURLCache];``/*
 设置缓存的大小为1M*/``[urlCache
 setMemoryCapacity:1*1024*1024];`` ``//创建一个nsurl``NSURL
 *url = [NSURL URLWithString:paramURLAsString];``    ``//创建一个请求``NSMutableURLRequest
 *request =``[NSMutableURLRequest`` ``requestWithURL:url`` ``cachePolicy:NSURLRequestUseProtocolCachePolicy`` ``timeoutInterval:60.0f];`` ``//从请求中获取缓存输出``NSCachedURLResponse
 *response =``[urlCache
 cachedResponseForRequest:request];``//判断是否有缓存``if</code> <code>(response
 != nil){``    ``NSLog(@``&quot;如果有缓存输出，从缓存中获取数据&quot;``);``    ``[request
 setCachePolicy:NSURLRequestReturnCacheDataDontLoad];``}``self.connection
 = nil;``/*
 创建NSURLConnection*/``NSURLConnection
 *newConnection =``[[NSURLConnection
 alloc] initWithRequest:request``                                ``delegate:self``                        ``startImmediately:YES];``self.connection
 = newConnection;``[newConnection
 release];</code>但是NSMutableURLRequest使用起来不够简便，在实际项目中我很少用它，而基本使用ASIHTTPRequest来代替。</p>
<h3 id="2-ASIHTTPRequest">2.ASIHTTPRequest</h3>
<p>你可以从这里找到它的介绍：<a href="http://allseeing-i.com/ASIHTTPRequest/" target="_blank" rel="external">http://allseeing-i.com/ASIHTTPRequest/</a>，在5.0/4.0及之前iOS版本，ASIHTTPRequest基本是主力的<br> HTTP requests library，它本身也是Github中的开源项目，但是从iOS 5.0之后逐渐停止维护了。未来的项目可以使用<strong><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a></strong>或者<strong><a href="https://github.com/MugunthKumar/MKNetworkKit" target="_blank" rel="external">MKNetworkKit</a></strong>代替ASIHTTPRequest。<br>ASIHTTPRequest的简介如下：</p>
<blockquote>
<p>ASIHTTPRequest is an easy to use wrapper around the CFNetwork API that makes some of the more tedious aspects of communicating with web servers easier. It is written in Objective-C and works in both Mac OS X and<br> iPhone applications.<br>It is suitable performing basic HTTP requests and interacting with REST-based services (GET / POST / PUT / DELETE). The included ASIFormDataRequest subclass makes it easy to submit POST data and files using<a href="http://en.wikipedia.org/wiki/MIME#Form_Data" target="_blank" rel="external">multipart/form-data</a>.<br>ASIHTTPRequest库API设计的简单易用，并且支持block、queue、gzip等丰富的功能，这是该开源项目如此受欢迎的主要原因。<br>ASIHTTPRequest库中提供了ASIWebPageRequest组件用于请求网页，并且能把网页中的外部资源一并请求下来，但是我在实际项目中使用后发现有严重Bug，所以不建议使用。<br>ASIHTTPRequest库的介绍中也提到了它可以支持REST-based service，但是与Restfull API打交道我们往往使用下面介绍的的RestKit。<br>Sample：<br>12345678910111213141516171819202122232425262728293031323334353637383940<code>NSMutableString
 *requestedUrl = [[NSMutableString alloc] initWithString:self.url];</code> <code>//如果优先使用本地数据``ASICachePolicy
 policy = _useCacheFirst ? ASIOnlyLoadIfNotCachedCachePolicy ``    ``:
 (ASIAskServerIfModifiedCachePolicy | ASIFallbackToCacheIfLoadFailsCachePolicy);</code> <code>asiRequest
 = [ASIHTTPRequest requestWithURL:``                   ``[NSURL
 URLWithString:[requestedUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]]];</code> <code>[asiRequest
 setDownloadCache:[ASIDownloadCache sharedCache]];``[asiRequest
 setCachePolicy:policy];``[asiRequest
 setCacheStoragePolicy:ASICachePermanentlyCacheStoragePolicy];</code> <code>//
 Connection``if</code> <code>(_connectionType
 == ConnectionTypeAsynchronously) {`` </code> <code>``[asiRequest
 setDelegate:self];``    ``[asiRequest
 startAsynchronous];`` </code> <code>``//
 Tell we&#39;re receiving.``    ``if</code> <code>(!_canceled
 &amp;&amp; [_delegate respondsToSelector:@selector(downloaderDidStart:)])``        ``[_delegate
 downloaderDidStart:self];``}``else``{``    ``[asiRequest
 startSynchronous];`` </code> <code>``NSError
 *error = [asiRequest error];`` </code> <code>``if</code> <code>(!error)
``    ``{``        ``[self
 requestFinished:asiRequest];``    ``}``    ``else``    ``{``        ``[self
 requestFailed:asiRequest];``    ``}``}</code> <code>[requestedUrl
 release];</code> </p>
<h3 id="3-RestKit">3.RestKit</h3>
<p>官方网站：<a href="http://restkit.org/" target="_blank" rel="external">http://restkit.org/</a>，Github开源项目，与 Restfull<br> API 的 Web服务打交道，这个库非常便捷，它也提供了很完整的Cache机制。<br>Sample：<br>123456789101112<code>+
 (``void``)setCachePolicy:(``BOOL``)useCacheFirst``{``    ``RKObjectManager*
 objectManager = [RKObjectManager sharedManager];`` </code> <code>``if</code> <code>(useCacheFirst)
 {``        ``objectManager.client.cachePolicy
 = RKRequestCachePolicyEnabled; ``//使用本地Cache，如果没有Cache请求服务器``    ``}``    ``else``    ``{``        ``objectManager.client.cachePolicy
 = RKRequestCachePolicyLoadIfOffline|RKRequestCachePolicyTimeout; ``//离线或者超时时使用本地Cache``    ``}``}</code>123456789101112<code>+
 (``BOOL``)getHomeTimeline:(NSInteger)maxId
``                 ``length:(NSInteger)length``               ``delegate:(id&lt;RKObjectLoaderDelegate&gt;)delegate``          ``useCacheFirst:(``BOOL``)useCacheFirst``{``    ``if</code> <code>(delegate
 == nil)``        ``return</code> <code>NO;`` </code> <code>``[iKnowAPI
 setCachePolicy:useCacheFirst];</code> <code>``//...``}</code>Cache请求只是RestKit最基本的功能，RestKit真正强大的地方在于处理与RESTful web services交互时的相关工作非常简便（<a href="https://github.com/RestKit/RestKit/wiki" target="_blank" rel="external">https://github.com/RestKit/RestKit/wiki</a>），RestKit还可以Cache<br> data model到Core Data中：<br>Core Data support. Building on top of the object mapping layer, RestKit provides integration with Apple’s Core Data framework. This support allows RestKit to persist remotely loaded objects directly back into a local<br> store, either as a fast local cache or a primary data store that is periodically synced with the cloud. RestKit can populate Core Data associations for you, allowing natural property based traversal of your data model. It also provides a nice API on top of<br> the Core Data primitives that simplifies configuration and querying use cases through an implementation of the Active Record access pattern.<br>但实际上RKRequestCachePolicy已经解决了大部分Cache需求。</p>
</blockquote>
<h3 id="4-SDWebImage">4.SDWebImage</h3>
<p>SDWebImage是Github开源项目：<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a>，它用于方便的请求、Cache网络图片，并且请求完毕后交由UIImageView显示。</p>
<blockquote>
<p>Asynchronous image downloader with cache support with an UIImageView category.<br>SDWebImage作为UIImageView的一个Category提供的，所以使用起来非常简单：<br>123<code>//
 Here we use the new provided setImageWithURL: method to load the web image``[imageView
 setImageWithURL:[NSURL URLWithString:@``&quot;[http://www.domain.com/path/to/image.jpg](http://www.domain.com/path/to/image.jpg)&quot;``]``               ``placeholderImage:[UIImage
 imageNamed:@``&quot;placeholder.png&quot;``]];</code>AFNetworking也提供了类似功能（<a href="http://afnetworking.github.com/AFNetworking/Categories/UIImageView+AFNetworking.html" target="_blank" rel="external">UIImageView+AFNetworking</a>）：<br>12<code>UIImageView
 *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0.0f, 0.0f, 100.0f, 100.0f)];``[imageView
 setImageWithURL:[NSURL URLWithString:@``&quot;[http://i.imgur.com/r4uwx.jpg](http://i.imgur.com/r4uwx.jpg)&quot;``]
 placeholderImage:[UIImage imageNamed:@``&quot;placeholder-avatar&quot;``]];</code> </p>
<h3 id="5-UIWebView中的图片Cache">5.UIWebView中的图片Cache</h3>
<p>如果你使用UIWebView来展示内容，在离线情况下如果也想能显示的话需要实现2点：</p>
<ul>
<li>Cache Html页面</li>
<li>Cache 图片等元素</li>
</ul>
</blockquote>
<p>使用上面介绍的网络组件来Cache Html页面比较便捷，之后使用webView loadHTMLString即可加载本地Html页面，而Cache图片需要更换NSURLCache公共实例为自定义的NSURLCache（UIWebView使用的即是+[NSURLCache sharedURLCache]）：<br>12345<code>//设置使用自定义Cache机制``LocalSubstitutionCache
 *cache = [[[LocalSubstitutionCache alloc] init] autorelease];``[cache
 setMemoryCapacity:4 * 1024 * 1024];``[cache
 setDiskCapacity:10 * 1024 * 1024];``[NSURLCache
 setSharedURLCache:cache];</code>自定义NSURLCache：<br>12345678910<code>#import
 &lt;Foundation/Foundation.h&gt;</code> <code>@interface
 LocalSubstitutionCache : NSURLCache``{``    ``NSMutableDictionary
 *cachedResponses;``}</code> <code>+
 (NSString *)pathForURL:(NSURL*)url;</code> <code>@end</code>详细的见NewsReader中的LocalSubstitutionCache.h/.m和WebViewController.m中的viewDidLoad，<a href="http://www.cnblogs.com/wangkewei/archive/2012/09/29/2708373.html" target="_blank" rel="external">News<br> Reader开源项目</a>这里参考的是：<a href="http://cocoawithlove.com/2010/09/substituting-local-data-for-remote.html" target="_blank" rel="external">http://cocoawithlove.com/2010/09/substituting-local-data-for-remote.html</a></p>
<h2 id="NewsReader中的介绍">NewsReader中的介绍</h2>
<h4 id="《iOS_News_Reader开源项目》这篇文章介绍到的开源项目改进了离线使用体验：">《<a href="http://www.cnblogs.com/wangkewei/archive/2012/09/29/2708373.html" target="_blank" rel="external">iOS News Reader开源项目</a>》这篇文章介绍到的开源项目改进了离线使用体验：</h4>
<p><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172859401.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101729043286.png" alt="IMG_2155" title="IMG_2155"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101729141291.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172918928.png" alt="IMG_2156" title="IMG_2156"></a><br>在没有网络的情况下使用已经Cache过的所有数据：文章、图片、音频等等，用到的主要方案已经在上面介绍了，详细的请看源码：<a href="https://github.com/cubewang/NewsReader" target="_blank" rel="external">https://github.com/cubewang/NewsReader</a>。<br>NewsReader项目因为历史演进的原因已经有些庞大了，需要进一步重构，在之后的项目中我们的客户端结构更精简。<br>另外欢迎加QQ群讨论：161561752<br>作者: 王克伟<br>出处: <a href="http://wangkewei.cnblogs.com/" target="_blank" rel="external">http://wangkewei.cnblogs.com/</a><br>版权声明: 本文的版权归作者与博客园共有。转载时须注明本文的详细链接，否则作者将保留追究其法律责任的权利。<br>您可以从<a href="http://www.cnblogs.com/wangkewei/archive/2009/10/15/1583745.html" target="_blank" rel="external">这里</a>更方便的找到我的文章。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-24T09:08:00.000Z"><a href="/2014/02/24/objective-c宏定义/">2月 24 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/24/objective-c宏定义/">objective-c宏定义</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><strong>本文转自:<a href="http://blog.csdn.net/wangqiuyun/article/details/8104698" target="_blank" rel="external">http://blog.csdn.net/wangqiuyun/article/details/8104698</a></strong><br><strong>1、先来几个常用的：</strong></p>
<p><strong>[csharp]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. // 是否高清屏  </p>
<ol>
<li><h1 id="define_isRetina_([UIScreen_instancesRespondToSelector:@selector(currentMode)]_?_CGSizeEqualToSize(CGSizeMake(640,_960),_[[UIScreen_mainScreen]_currentMode]-size)_:_NO)">define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), [[UIScreen mainScreen] currentMode].size) : NO)</h1>
</li>
<li>// 是否模拟器  </li>
<li><h1 id="define_isSimulator_(NSNotFound_!=_[[[UIDevice_currentDevice]_model]_rangeOfString:@”Simulator”]-location)">define isSimulator (NSNotFound != [[[UIDevice currentDevice] model] rangeOfString:@”Simulator”].location)</h1>
</li>
<li>// 是否iPad  </li>
<li><h1 id="define_isPad_(UI_USER_INTERFACE_IDIOM()_==_UIUserInterfaceIdiomPad)">define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)</h1>
</li>
<li>// 是否iPad  </li>
<li><h1 id="define_someThing_(UI_USER_INTERFACE_IDIOM()_==_UIUserInterfaceIdiomPad)?_ipad:_iphone">define someThing (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)? ipad: iphone</h1>
</li>
</ol>
<p><strong>2、基本的使用：</strong></p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. //定义π值 3.1415926    </p>
<ol>
<li><h1 id="define_PI_3-1415926">define PI 3.1415926</h1>
</li>
<li>//则在程序用可以如下使用       </li>
<li>double i=2<em>PI</em>3;     </li>
<li>//效果相当于  double i=2<em>3.1415926</em>3;    </li>
<li></li>
<li>//预处理命令可以定义任何符合格式的形式，例如判断年份是否闰年  </li>
<li><h1 id="define_IS_LEAP_YEAR_year%4==0&amp;&amp;year%100!=0||year%400==0">define  IS_LEAP_YEAR  year%4==0&amp;&amp;year%100!=0||year%400==0</h1>
</li>
<li>//使用时则可以直接    </li>
<li>if(IS_LEAP_YEAR)    </li>
<li></li>
<li>//或者可以定义一个参数      </li>
<li><h1 id="define_IS_LEAP_YEAR(y)_y%4==0&amp;&amp;y%100!=0||y%400==0">define  IS_LEAP_YEAR(y)  y%4==0&amp;&amp;y%100!=0||y%400==0</h1>
</li>
<li>//使用时则可以直接     </li>
<li>int ys=2012;     </li>
<li>if(IS_LEAP_YEAR(ys))       </li>
<li></li>
<li>//通常预处理程序定义在一行 如果好分行 比如说太长需要换行  需要使用“/”符号 表示还有下一行，多行分列也是如此，例：    </li>
<li><h1 id="Define_IS_LEAP_YEAR_year%4==0&amp;&amp;year%100!=0/">Define  IS_LEAP_YEAR  year%4==0&amp;&amp;year%100!=0/</h1>
</li>
<li>||year%400==0     </li>
<li>//宏定义参数后边放一个# 那么在调用该宏时，预处理程序将根据宏参数创建C风格的常量字符串 例：    </li>
<li><h1 id="define_STR(x)_#_x">define STR(x) # x</h1>
</li>
<li>//将会使得 随后调用的      </li>
<li></li>
<li>NSLOG(STR(Programming in Objective-c./n));    </li>
<li>//显示结果为 Programming in Objective-c./n  </li>
</ol>
<p><strong>3、关于#与##的操作符：</strong></p>
<p><1>.宏定义中字符串化操作符#：</1></p>
<h1 id="的功能是将其后面的宏参数进行字符串化操作，意思就是对它所应用的宏变量通过替换后在其左右各加上一个双引号。例如">的功能是将其后面的宏参数进行字符串化操作，意思就是对它所应用的宏变量通过替换后在其左右各加上一个双引号。例如</h1>
<p><strong>[csharp]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. #define WARN_IF(EXPR)\  </p>
<ol>
<li>do {\  </li>
<li>if (EXPR)\  </li>
<li>fprintf(stderr, “Warning: “ #EXPR “\n”);\  </li>
<li>} while(0)  </li>
<li></li>
<li>上面代码中的反斜线\主要用来转译换行符，即屏蔽换行符。  </li>
<li></li>
<li>那么如下的代码调用：  </li>
<li>WARN_IF(divider == 0);  </li>
<li></li>
<li>将被解析为：  </li>
<li>do {\  </li>
<li>if (divider == 0)\  </li>
<li>fprintf(stderr, “Warning: “ “divider == 0” “\n”);\  </li>
<li>} while(0);  </li>
</ol>
<p>注意能够字符串化操作的必须是宏参数，不是随随便便的某个子串（token）都行的。</p>
<p><2>.宏定义中的连接符##：<br>连接符##用来将两个token连接为一个token，但它不可以位于第一个token之前or最后一个token之后。注意这里连接的对象只要是token就行，而不一定是宏参数,但是##又必须位于宏定义中才有效，因其为编译期概念（比较绕）。</2></p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. #define LINK<em>MULTIPLE(a, b, c, d) a##</em>##b##<em>##c##</em>##d  </p>
<ol>
<li>typedef struct _record_type LINK_MULTIPLE(name, company, position, salary);  </li>
<li>/*  </li>
<li><ul>
<li>上面的代码将被替换为  </li>
</ul>
</li>
<li><ul>
<li>typedef struct _record_type name_company_position_salary;  </li>
</ul>
</li>
<li>*/  </li>
<li></li>
<li>又如下面的例子：  </li>
<li><h1 id="define_PARSER(N)_printf(“token”_#N_“_=_%d\n”,_token##N)">define PARSER(N) printf(“token” #N “ = %d\n”, token##N)</h1>
</li>
<li></li>
<li>int token64 = 64;  </li>
<li></li>
<li>如下调用宏：  </li>
<li>PARSER(64);  </li>
<li></li>
<li>将被解析为：  </li>
<li>printf(“token” “64” “ = %d\n”, token64);  </li>
<li></li>
<li>在obj-c中，如果我有如下定义：  </li>
<li><h1 id="define__X(A,_B)_(A#B)">define _X(A, B) (A#B)</h1>
</li>
<li><h1 id="define__XX(A,_B)__X([NSString_stringWithFormat:@”%@_c”,_A],_B)">define _XX(A, B) _X([NSString stringWithFormat:@”%@_c”, A], B)</h1>
</li>
<li>gcc将报错！  </li>
<li>正确的写法为：  </li>
<li><h1 id="define__XX(A,_B)__X(([NSString_stringWithFormat:@”%@_c”,_A]),_B)">define _XX(A, B) _X(([NSString stringWithFormat:@”%@_c”, A]), B)</h1>
</li>
</ol>
<p><strong>4、再来个宏定义 object-c 单例</strong></p>
<p><strong>[csharp]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. #define GTMOBJECT<em>SINGLETON_BOILERPLATE(_object_name</em>, <em>shared_obj_name</em>)  </p>
<ol>
<li>static <em>object_name</em> *z##<em>shared_obj_name</em> = nil;   </li>
<li><ul>
<li>(<em>object_name</em> *)<em>shared_obj_name</em> {              </li>
</ul>
</li>
<li>@synchronized(self) {                             </li>
<li>if (z##<em>shared_obj_name</em> == nil) {              </li>
<li>/<em> Note that ‘self’ may not be the same as <em>object_name</em> </em>/                                </li>
<li>/<em> first assignment done in allocWithZone but we must reassign in case init fails </em>/       </li>
<li>z##<em>shared_obj_name</em> = [[self alloc] init];                                                </li>
<li><em>GTMDevAssert((z##_shared_obj_name</em> != nil), @”didn’t catch singleton allocation”);        </li>
<li>}                                               </li>
<li>}                                                 </li>
<li>return z##<em>shared_obj_name</em>;                      </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(id)allocWithZone:(NSZone *)zone {                </li>
</ul>
</li>
<li>@synchronized(self) {                             </li>
<li>if (z##<em>shared_obj_name</em> == nil) {              </li>
<li>z##<em>shared_obj_name</em> = [super allocWithZone:zone];  </li>
<li>return z##<em>shared_obj_name</em>;                  </li>
<li>}                                               </li>
<li>}                                                 </li>
<li></li>
<li>/<em> We can’t return the shared instance, because it’s been init’d </em>/  </li>
<li>_GTMDevAssert(NO, @”use the singleton API, not alloc+init”);         </li>
<li>return nil;                                       </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(id)retain {                                      </li>
</ul>
</li>
<li>return self;                                      </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(NSUInteger)retainCount {                         </li>
</ul>
</li>
<li>return NSUIntegerMax;                             </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(void)release {                                   </li>
</ul>
</li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(id)autorelease {                                 </li>
</ul>
</li>
<li>return self;                                      </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(id)copyWithZone:(NSZone *)zone {                 </li>
</ul>
</li>
<li>return self;                                      </li>
<li>}  </li>
</ol>
<p><strong>5、条件编译：</strong></p>
<p><strong>[csharp]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. #if !defined(FCDebug) || FCDebug == 0  </p>
<ol>
<li><h1 id="define_FCLOG(…)_do_{}_while_(0)">define FCLOG(…) do {} while (0)</h1>
</li>
<li><h1 id="define_FCLOGINFO(…)_do_{}_while_(0)">define FCLOGINFO(…) do {} while (0)</h1>
</li>
<li><h1 id="define_FCLOGERROR(…)_do_{}_while_(0)">define FCLOGERROR(…) do {} while (0)</h1>
</li>
<li></li>
<li><h1 id="elif_FCDebug_==_1">elif FCDebug == 1</h1>
</li>
<li><h1 id="define_FCLOG(…)_NSLog(VA_ARGS)">define FCLOG(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="define_FCLOGERROR(…)_NSLog(VA_ARGS)">define FCLOGERROR(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="define_FCLOGINFO(…)_do_{}_while_(0)-1">define FCLOGINFO(…) do {} while (0)</h1>
</li>
<li></li>
<li><h1 id="elif_FCDebug_&gt;_1">elif FCDebug &gt; 1</h1>
</li>
<li><h1 id="define_FCLOG(…)_NSLog(VA_ARGS)-1">define FCLOG(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="define_FCLOGERROR(…)_NSLog(VA_ARGS)-1">define FCLOGERROR(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="define_FCLOGINFO(…)_NSLog(VA_ARGS)">define FCLOGINFO(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="endif">endif</h1>
</li>
</ol>
<p><strong>6、参照C语言的预处理命令简介 ：</strong></p>
<h1 id="define_定义一个预处理宏">define              定义一个预处理宏</h1>
<h1 id="undef_取消宏的定义">undef               取消宏的定义</h1>
<h1 id="include_包含文件命令">include            包含文件命令</h1>
<h1 id="include_next_与#include相似,_但它有着特殊的用途">include_next   与#include相似, 但它有着特殊的用途</h1>
<h1 id="if_编译预处理中的条件命令,_相当于C语法中的if语句">if                      编译预处理中的条件命令, 相当于C语法中的if语句</h1>
<h1 id="ifdef_判断某个宏是否被定义,_若已定义,_执行随后的语句">ifdef                判断某个宏是否被定义, 若已定义, 执行随后的语句</h1>
<h1 id="ifndef_与#ifdef相反,_判断某个宏是否未被定义">ifndef             与#ifdef相反, 判断某个宏是否未被定义</h1>
<h1 id="elif_若#if,_#ifdef,_#ifndef或前面的#elif条件不满足,_则执行#elif之后的语句,_相当于C语法中的else-if">elif                  若#if, #ifdef, #ifndef或前面的#elif条件不满足, 则执行#elif之后的语句, 相当于C语法中的else-if</h1>
<h1 id="else_与#if,_#ifdef,_#ifndef对应,_若这些条件不满足,_则执行#else之后的语句,_相当于C语法中的else">else                与#if, #ifdef, #ifndef对应, 若这些条件不满足, 则执行#else之后的语句, 相当于C语法中的else</h1>
<h1 id="endif_#if,_#ifdef,_#ifndef这些条件命令的结束标志-">endif              #if, #ifdef, #ifndef这些条件命令的结束标志.</h1>
<p>defined            与#if, #elif配合使用, 判断某个宏是否被定义</p>
<h1 id="line_标志该语句所在的行号">line                标志该语句所在的行号</h1>
<h1 id="将宏参数替代为以参数值为内容的字符窜常量">将宏参数替代为以参数值为内容的字符窜常量</h1>
<h2 id="将两个相邻的标记(token)连接为一个单独的标记">将两个相邻的标记(token)连接为一个单独的标记</h2>
<h1 id="pragma_说明编译器信息#warning_显示编译警告信息">pragma        说明编译器信息#warning       显示编译警告信息</h1>
<h1 id="error_显示编译错误信息">error            显示编译错误信息</h1>
<p>参考链接：<a href="http://www.uml.org.cn/c++/200902104.asp" target="_blank" rel="external">http://www.uml.org.cn/c++/200902104.asp</a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/objective-c/">objective-c</a>, <a href="/tags/宏/">宏</a>, <a href="/tags/iphone开发/">iphone开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-24T05:35:00.000Z"><a href="/2014/02/24/iOS7应用国际化/">2月 24 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/24/iOS7应用国际化/">iOS7应用国际化</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>一 应用名字国际化:1. 新建一个工程test.</p>
<ol>
<li>首先修改应用名字</li>
<li><p>test-&gt;PROJECT-&gt;Info-&gt;Localizations-&gt;+号-&gt;Simplified<img src="http://img.blog.csdn.net/20140224131250015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p>在(English)添加CFBundleDisplayName=”English”;</p>
</li>
<li>在(Simplified)添加CFBundleDisplayName=”中文”;<img src="http://img.blog.csdn.net/20140224131753703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>启动应用就会按照本地语言加载应用的名称.</li>
</ol>
<p>二 应用内容国际化1. New File-&gt;String Flies,文件名字必须写Localizable,否则iOS识别不了,选择Localizable.strings,右边点击Localize…选择语言.<img src="" alt=""></p>
<ol>
<li>添加之后右边的Licalization会列出你支持的语言,全部勾上.</li>
<li><p>Localizable.strings会有你选择的两种语言的Strings文件.</p>
</li>
<li><p>在(English)里添加”key” = “English”;</p>
</li>
<li>在(Simplified)里添加”key” = “中文”;<img src="http://img.blog.csdn.net/20140224132942609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>添加一个Label就可以看到效果了.<img src="http://img.blog.csdn.net/20140224133121703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>当然还有获取当前语言的方法    </li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *languages = [NSLocale preferredLanguages];</div><div class="line">    <span class="built_in">NSString</span> *language = [languages objectAtIndex:<span class="number">0</span>];</div><div class="line">    <span class="built_in">NSLog</span> ( <span class="string">@"%@"</span> , language);</div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios国际化/">ios国际化</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/国际化/">国际化</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-21T08:29:00.000Z"><a href="/2014/02/21/stringByEvaluatingJavaScriptFromString的使用方法/">2月 21 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/21/stringByEvaluatingJavaScriptFromString的使用方法/">stringByEvaluatingJavaScriptFromString的使用方法</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>　来源：　朱祁林 麒麟的blogstringByEvaluatingJavaScriptFromString使用stringByEvaluatingJavaScriptFromString方法，需要等UIWebView中的页面加载完成之后去调用。我们在界面上拖放一个UIWebView控件。在Load中将googlemobile加载到这个控件中，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line"> {</div><div class="line"> [<span class="keyword">super</span> viewDidLoad];</div><div class="line"> webview<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</div><div class="line"> webview<span class="variable">.scalesPageToFit</span> =<span class="literal">YES</span>;</div><div class="line"> webview<span class="variable">.delegate</span> =<span class="keyword">self</span>;</div><div class="line"> <span class="built_in">NSURL</span> *url =[[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"http://www.google.com.hk/m?gl=CN&hl=zh_CN&source=ihp"</span>];</div><div class="line"></div><div class="line"> <span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:url];</div><div class="line"> [webview loadRequest:request];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们在webViewDidFinishLoad方法中就可以通过javascript操作界面元素了。1、获取当前页面的url。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView {</div><div class="line"> <span class="built_in">NSString</span> *currentURL = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.location.href"</span>];</div><div class="line"> }</div></pre></td></tr></table></figure>

<p>2、获取页面title：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView {</div><div class="line"> <span class="built_in">NSString</span> *currentURL = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.location.href"</span>];</div><div class="line"></div><div class="line"> <span class="built_in">NSString</span> *title = [webview stringByEvaluatingJavaScriptFromString:<span class="string">@"document.title"</span>];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>3、修改界面元素的值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *js_result = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.getElementsByName('q')[0].value='朱祁林';"</span>];</div></pre></td></tr></table></figure>

<p>4、表单提交：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *js_result2 = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.forms[0].submit(); "</span>];</div></pre></td></tr></table></figure>

<p>这样就实现了在google搜索关键字：“朱祁林”的功能。5、插入js代码上面的功能我们可以封装到一个js函数中，将这个函数插入到页面上执行，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[webView stringByEvaluatingJavaScriptFromString:<span class="string">@"var script = document.createElement('script');"</span></div><div class="line"><span class="string">"script.type = 'text/javascript';"</span></div><div class="line"><span class="string">"script.text = \"function myFunction() { "</span></div><div class="line"><span class="string">"var field = document.getElementsByName('q')[0];"</span></div><div class="line"><span class="string">"field.value='朱祁林';"</span></div><div class="line"><span class="string">"document.forms[0].submit();"</span></div><div class="line"><span class="string">"}\";"</span></div><div class="line"><span class="string">"document.getElementsByTagName('head')[0].appendChild(script);"</span>];</div><div class="line"> [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"myFunction();"</span>];</div></pre></td></tr></table></figure>

<p>看上面的代码：a、首先通过js创建一个script的标签，type为’text/javascript’。b、然后在这个标签中插入一段字符串，这段字符串就是一个函数：myFunction，这个函数实现google自动搜索关键字的功能。c、然后使用stringByEvaluatingJavaScriptFromString执行myFunction函数。演示：第一步打开google mobile网站 第二步输入关键字 第三步搜素 总结：这篇文章主要是讲解了stringByEvaluatingJavaScriptFromString的用法，它的功能非常的强大，用起来非常简单，通过它我们可以很方便的操作uiwebview中的页面元素。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/UIWebView/">UIWebView</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-20T09:11:00.000Z"><a href="/2014/02/20/iOS开发常用的类别和宏定义集成frameworkd/">2月 20 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/20/iOS开发常用的类别和宏定义集成frameworkd/">iOS开发常用的类别和宏定义集成frameworkd</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>自己闲着没事就把在网上搜罗一些常用的宏定义和类别方法,顺便学习Framework的打包,自己用着挺方便的.<br><a href="http://download.csdn.net/download/yinxianwei88/6942209" target="_blank" rel="external">Framework下载</a><br><img src="http://img.blog.csdn.net/20140220170410875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之第三方框架/">iOS应用开发之第三方框架</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-17T07:51:00.000Z"><a href="/2014/02/17/Xcode的Architectures和Valid Architectures的区别/">2月 17 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/17/Xcode的Architectures和Valid Architectures的区别/">Xcode的Architectures和Valid Architectures的区别</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>作者：shede333<br><a href="http://my.oschina.net/shede333" target="_blank" rel="external">主页：http://my.oschina.net/shede333</a><br>版权声明：原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="external">Creative<br> Commons BY-NC-ND 3.0</a></p>
<h2 id="Xcode的Architectures和Valid_Architectures的区别">Xcode的Architectures和Valid Architectures的区别</h2>
<h3 id="Architectures">Architectures</h3>
<p>这代表，在这个项目里你想要Xcode编译的目标设备列表。</p>
<h3 id="Valid_Architectures">Valid Architectures</h3>
<p>还不是太明确这个设置的意图，但是一般来说是不需要更改的。<br>在Xcode5.0里的Valid Architectures 设置里，有2个选项：</p>
<ol>
<li>默认为<code>standard
architectures (including 64-bit)(armv7,armv7s,arm64)</code>，这样设置，你的Deployment target最低只能设置为 6.0,(在Xcode5.0.1 之后,最低能够兼容IOS 5.1.1);</li>
<li><code>standard
architectures (armv7,armv7s)</code>，这样设置，你的Deployment target最低能设置为 4.3；</li>
</ol>
<h2 id="原因解释如下：">原因解释如下：</h2>
<p>使用standard architectures (including 64-bit)(armv7,armv7s,arm64)参数，<br>则打的包里面有32位、64位两份代码，<br>在iPhone5s（<code>iPhone5s的cpu是64位的</code>）下，会首选运行64位代码包，<br>其余的iPhone（<code>其余iPhone都是32位的,iPhone5c也是32位</code>），<br>只能运行32位包，<br>但是包含两种架构的代码包，只有运行在ios6，ios7系统上。<br>这也就是说，这种打包方式，对手机几乎没啥要求，但是对系统有要求，即ios6以上。<br>而使用standard architectures (armv7,armv7s)参数，<br>则打的包里只有32位代码，<br>iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能，原因下面的参考有解释。<br>其余的iPhone对32位代码包更没问题，<br>而32位代码包，对系统也几乎也没什么限制。<br>所以总结如下：<br>要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。<br>如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。</p>
<h2 id="参考1：">参考1：</h2>
<p><a href="http://en.wikipedia.org/wiki/List_of_iOS_devices" target="_blank" rel="external">所有IOS设备详情列表<br> List of iOS devices - Wikipedia, the free encyclopedia</a></p>
<blockquote>
<p>armv6：iPhone 2G/3G，iPod 1G/2G<br>armv7：iPhone 3GS/4/4s，iPod 3G/4G，iPad 1G/2G/3G<br>armv7s：iPhone5</p>
<h2 id="参考2：">参考2：</h2>
<p><a href="http://blog.csdn.net/keyboardota/article/details/11993883" target="_blank" rel="external">iOS<br> 7: 如何为iPhone 5S编译64位应用。</a><br>Xcode 5编译的iOS 7程序包含了32位和64位两套二进制代码，在32位的iOS系统上会调用32位的二进制代码，在64位系统上会调用64位的二进制代码，以此来解决向后兼容的问题。<br>同时，考虑到很多32位的程序可能在没有重新编译的情况下部署到64位系统上，64位的iOS系统中带有两套FrameWork，一套是32位的，一套是64位的。<br>当64位的iOS系统运行原来的32位程序时，系统会调用32位的FrameWork作为底层支撑，当系统运行64位程序时，系统会调用64位的FrameWork作为底层支撑。<br>也就是说，当一个iPhone 5S上同时运行32位程序和64位程序时，系统同时将32位和64位两套FrameWork载入了内存中，所以消耗的内存也比较多。<br>如果一台64位的iOS设备上运行的所有程序都是为64位系统编译过的，iOS系统将只载入64位的FrameWork，这将节省好多内存。所以，如果大家都可以快速将程序传换成64位的，iOS将跑得更快。真的是“大家好才是真的好”。</p>
<h2 id="参考3：">参考3：</h2>
<ol>
<li><a href="http://stackoverflow.com/questions/12701188/whats-the-difference-between-architectures-and-valid-architectures-in-xcode" target="_blank" rel="external">What’s<br>the difference between “Architectures” and “Valid Architectures” in Xcode Build Settings?</a></li>
<li><a href="http://stackoverflow.com/questions/18913906/xcode-5-and-ios-7-architecture-and-valid-architectures" target="_blank" rel="external">Xcode<br>5 and iOS 7: Architecture and Valid architectures</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW51" target="_blank" rel="external">Xcode<br>Build Setting Reference (苹果官方文档)</a></li>
<li><a href="https://developer.apple.com/library/iOS/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html" target="_blank" rel="external">64-Bit<br>transition Guide for Cocoa Touch (苹果官方文档)</a></li>
</ol>
</blockquote>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之Xcode配置/">iOS应用开发之Xcode配置</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/xcode/">xcode</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-13T01:36:00.000Z"><a href="/2014/02/13/Cocos2d 中对图片的各种操作/">2月 13 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/13/Cocos2d 中对图片的各种操作/">Cocos2d 中对图片的各种操作</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>关于精灵的各种操作，总结一下以便以后复习查找。<br>内容简要：<br>1、初始化 2、创建无图的精灵 3、设置精灵贴图大小  4、添加入层中<br>5、对精灵进行缩放  6、对精灵款或高进行缩放  7、旋转精灵<br>8、设置精灵透明度  9、精灵的镜像反转  10、设置精灵的颜色<br>11、得到图的宽高   12、按照像素设定图片大小  13、在原有的基础上加xy的坐标<br>14、设置图片锚点    15、从新排列z轴顺序   16、更换精灵贴图<br>17、设置可视区域 18、贴图无锯齿</p>
<p>原文地址：<a href="http://blog.csdn.net/dingkun520wy/article/details/6976558" target="_blank" rel="external">http://blog.csdn.net/dingkun520wy/article/details/6976558</a>  </p>
<hr>
<p>//初始化<br>CCSprite<em> sprite =[CCSprite spriteWithFile:@”Icon.png”];<br> //创建无图的精灵<br>CCSprite</em>sprite2 =[CCSprite node];<br>//设置精灵贴图大小<br>sprite2.textureRect=CGRectMake(0, 0, 20, 20);//设置其为宽20，高20.</p>
<p>//添加入层中</p>
<p>[self addChild:sprite z:2]; //将精灵加入层中设置其z轴为2<br>//对精灵进行缩放<br>sprite.scale=2;//放大2倍<br>//对精灵款或高进行缩放<br>sprite.scaleX = 2;//宽放大2倍<br>sprite.scaleY = 2;//高放大2倍<br>//旋转精灵<br>sprite.rotation=90;//旋转90度<br>//设置精灵透明度<br>sprite.opacity=255;//设置透明度为完全不透明（范围0～255）<br>//定义精灵位置<br>sprite.position=ccp(100,100);//设置精灵中心点坐标是x=100，y=100<br>//精灵的镜像反转<br>[sprite setFlipX:YES];//X轴镜像反转<br>[sprite setFlipY:YES];//Y轴镜像反转<br>//设置精灵的颜色<br>[sprite setColor:ccc3(255, 0, 0)];//设置颜色为红色<br>//得到图的宽高</p>
<p>float  contentSize  = sprite .contentSize.width //得到图片的宽高<br>//按照像素设定图片大小</p>
<p>sprite.scaleX=(20)/contentSize; //按照像素定制图片宽高<br>//在原有的基础上加xy的坐标<br>sprite.position = ccpAdd(sprite.position,ccp(20,20));//在原有坐标的基础上加减坐标<br>//设置图片锚点<br>[sprite setAnchorPoint:ccp(0.5,0.5) ];//设置图片的锚点<br>//从新排列z轴顺序<br>[self reorderChild:sprite z:1];//从新排列z轴顺序<br>//更换精灵贴图<br>CCTexture2D * test=[[CCTextureCache sharedTextureCache] addImage: @”test.png”];//新建贴图</p>
<p>[sprite setTexture:test];<br>//更换精灵贴图，加载帧缓存，这个test.plist保存了fram这张图<br>[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@”test.plist”];<br>CCSpriteFrame* frame = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@”fram.png”];<br>[sprite2 setDisplayFrame:frame];</p>
<p>//设置可视区域<br>CCSprite * sprite3 =[CCSprite spriteWithFile:@”icon.png” rect:CGRectMake(0, 0, 20,20)];//创建时设置</p>
<p>[sprite3 setTextureRect:CGRectMake(10, 10, 30, 30)];//创建后设置<br>//贴图无锯齿<br>[sprite3 .texture setAliasTexParameters];</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS游戏开发之基础学习/">iOS游戏开发之基础学习</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/cocos2d/">cocos2d</a>, <a href="/tags/2d/">2d</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/ios开发/">ios开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-21T09:12:00.000Z"><a href="/2014/01/21/关于UIView 的autoresizingMask属性，即UIViewAutoresizing/">1月 21 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/21/关于UIView 的autoresizingMask属性，即UIViewAutoresizing/">关于UIView 的autoresizingMask属性，即UIViewAutoresizing</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><strong>作者：舍得333<br> 主页：</strong><a href="http://blog.sina.com.cn/u/1509658847" target="_blank" rel="external">http://blog.sina.com.cn/u/1509658847</a><br><strong>版权声明</strong>：原创作品，允许转载，转载时请务必以超链接形式标明文章原始出版、作者信息和本声明，否则将追究法律责任。</p>
<p>enum<br> {<br>   UIViewAutoresizingNone                 =<br> 0,<br>   UIViewAutoresizingFlexibleLeftMargin   =<br> 1 &lt;&lt; 0,<br>   UIViewAutoresizingFlexibleWidth        =<br> 1 &lt;&lt; 1,<br>   UIViewAutoresizingFlexibleRightMargin  =<br> 1 &lt;&lt; 2,<br>   UIViewAutoresizingFlexibleTopMargin    =<br> 1 &lt;&lt; 3,<br>   UIViewAutoresizingFlexibleHeight       =<br> 1 &lt;&lt; 4,<br>   UIViewAutoresizingFlexibleBottomMargin<br> = 1 &lt;&lt; 5<br>};<br>typedef NSUInteger UIViewAutoresizing;<br>这六个值与xib文件里面的图形显示怎么对应起来，这个说起来很坑爹的。<br>代码设置与xib图形设置很不一至。</p>
<p>根据UIView的API文档说明，autoresizingMask的默认值是UIViewAutoresizingNone<br>那么再xib文件里面对应的图形是：</p>
<p>即四周选中，中间2个没有选中。这个真是有点变态啊，我刚开始以为是全都不选呢。</p>
<p>再举个例子：<br>我想要view一直与左下角对齐，高度自由伸缩，xib设置如图：</p>
<p>那么代码应该怎么写呢？一定要注意看清每个单词哦！！！，如下：<br>subView.autoresizingMask =<br>    UIViewAutoresizingFlexibleTopMargin<br> |<br>    UIViewAutoresizingFlexibleRightMargin<br> |<br>    UIViewAutoresizingFlexibleHeight;</p>
<p>下面的文章参考自：<a href="http://www.cnblogs.com/kiao295338444/articles/2308903.html" target="_blank" rel="external">http://www.cnblogs.com/kiao295338444/articles/2308903.html</a><br>在 UIView 中有一个autoresizingMask的属性，它对应的是一个枚举的值（如下），属性的意思就是自动调整子控件与父控件中间的位置，宽高。<br>enum {<br>   UIViewAutoresizingNone                 = 0,<br>   UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,<br>   UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,<br>   UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,<br>   UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,<br>   UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,<br>   UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5<br>};<br>typedef NSUInteger UIViewAutoresizing;</p>
<p>分别解释以上意思。<br>UIViewAutoresizingNone就是不自动调整。<br>UIViewAutoresizingFlexibleLeftMargin就是自动调整与superView左边的距离，也就是说，与superView右边的距离不变。<br>UIViewAutoresizingFlexibleRightMargin就是自动调整与superView的右边距离，也就是说，与superView左边的距离不变。<br>UIViewAutoresizingFlexibleTopMargin</p>
<p>UIViewAutoresizingFlexibleBottomMargin<br>UIViewAutoresizingFlexibleWidth<br>UIViewAutoresizingFlexibleHeight<br>以上就不多解释了，参照上面的。<br>也可以多个枚举同时设置。如下：<br>subView.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin  |UIViewAutoresizingFlexibleRightMargin;<br>如果有多个，就用“|”关联。<br>还有一个属性就是autoresizesSubviews，此属性的意思就是，是否可以让其subviews自动进行调整，默认状态是YES，就是允许，如果设置成NO，那么subView的autoresizingMask属性失效。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之UI/">iOS应用开发之UI</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone/">iphone</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/uiview/">uiview</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-15T09:06:00.000Z"><a href="/2014/01/15/iOS 7, 导航栏和状态栏自定义/">1月 15 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/15/iOS 7, 导航栏和状态栏自定义/">iOS 7, 导航栏和状态栏自定义</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <h1 id="本文转自:http://beyondvincent-com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6">本文转自:<a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6" target="_blank" rel="external">http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6</a></h1>
<p><a href="http://beyondvincent.com/images/2013/11/7.png" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/7.png" alt=""></a><br>注：本文译自<a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/" target="_blank" rel="external"><code>Customizing
 Navigation Bar and Status Bar in iOS 7</code></a><br>近期，跟大多数开发者一样，我也正忙于对程序进行升级以适配iOS 7。最新的iOS 7外观上有大量的改动。从开发者的角度来看，导航栏和状态栏就发生了明显的变化。状态栏现在是半透明的了，这也就意味着导航栏会显示在状态栏后面。有些情况下，导航栏的背景图片可以延伸显示到状态栏后面。<br>之前我曾经写过一篇关于<a href="http://www.appcoda.com/customize-navigation-bar-back-butto/" target="_blank" rel="external">如何定制导航栏</a>的文章。不过现在是时候对其进行更新了。下面就是本文将要介绍的内容：</p>
<ul>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#0" target="_blank" rel="external">iOS 7中默认的导航栏</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#1" target="_blank" rel="external">设置导航栏的背景颜色</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#2" target="_blank" rel="external">在导航栏中使用背景图片</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#3" target="_blank" rel="external">定制返回按钮的颜色</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#4" target="_blank" rel="external">修改导航栏标题的字体</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#44" target="_blank" rel="external">修改导航栏标题为图片</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#5" target="_blank" rel="external">添加多个按钮</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6" target="_blank" rel="external">修改状态栏的风格</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#7" target="_blank" rel="external">隐藏状态栏</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#8" target="_blank" rel="external">总结</a></li>
</ul>
<p><a href="http://beyondvincent.com/images/2013/11/9.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/9.jpg" alt=""></a><br>本文提供的代码需要用Xcode 5来执行。如果你还在使用老版本的Xcode，那么在运行示例之前请将Xcode升级到Xcode 5。</p>
<h3 id="iOS_7中默认的导航栏"><a href=""></a>iOS 7中默认的导航栏</h3>
<p>在开始定制之前，我们先来看看iOS 7中默认导航栏的外观。通过Xcode用<code>Single
 View Controller</code>模板创建一个工程。然后将view controller嵌入到一个navigation controller中。如果你不想从头开始，那么也可以在这里下载到这个<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip" target="_blank" rel="external">示例工程</a>。<br>Xcode 5包含有iOS 6和iOS 7模拟器，我们可以在这两个不同的模拟器版本中运行示例程序，进行对比，如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/10.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/10.jpg" alt=""></a><br>如上图所示，在iOS 7中的导航栏默认情况下跟状态栏是交织在一起的，并且它的颜色也被修改为亮灰色。</p>
<h3 id="设置导航栏的背景颜色"><a href=""></a>设置导航栏的背景颜色</h3>
<p>在iOS 7中，不再使用tintColor属性来设置导航栏的颜色，而是使用barTintColor属性来修改背景色。我们可以在<code>AppDelegate.m</code>文件中的方法<code>didFinishLaunchingWithOptions:</code>里面添加如下代码来修改颜色：<br>    1</p>
<pre><code><span class="string">[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]]</span>;
</code></pre><p>效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/11.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/11.jpg" alt=""></a><br>一般情况，我们都会使用自己的颜色，下面这个宏用来设置RGB颜色非常方便：<br>    1</p>
<pre><code>#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((<span class="built_in">float</span>)((rgbValue &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span> green:((<span class="built_in">float</span>)((rgbValue &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>))/<span class="number">255.0</span> blue:((<span class="built_in">float</span>)(rgbValue &amp; <span class="number">0xFF</span>))/<span class="number">255.0</span> alpha:<span class="number">1.0</span>]
</code></pre><p>将上面这个宏放到<code>AppDelegate.m</code>文件中，然后通过这个宏来创建一个UIColor对象(根据指定的RGB)。如下示例：<br>    1</p>
<pre><code><span class="attr_selector">[[UINavigationBar appearance]</span> setBarTintColor<span class="value">:<span class="function">UIColorFromRGB</span>(<span class="number">0</span>x067AB5)];</span>
</code></pre><p>默认情况下，导航栏的translucent属性为YES。另外，系统还会对所有的导航栏做模糊处理，这样可以让iOS 7中导航栏的颜色更加饱和。如下图，是translucent值为NO和YES的对比效果：<br><a href="http://beyondvincent.com/images/2013/11/12.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/12.jpg" alt=""></a><br>要想禁用translucent属性，可以在Storyboard中选中导航栏，然后在Attribute Inspectors中，取消translucent的勾选。</p>
<h3 id="在导航栏中使用背景图片"><a href=""></a>在导航栏中使用背景图片</h3>
<p>如果希望在导航栏中使用一个图片当做背景，那么你需要提供一个稍微高一点的图片(这样可以延伸到导航栏背后)。导航栏的高度从44 points(88 pixels)变为了64 points(128 pixels)。<br>我们依然可以使用<code>setBackgroundImage:</code>方法为导航栏设置自定义图片。如下代码所示：<br>    1</p>
<pre><code>[[UINavigationBar appearance] <span class="keyword">set</span>BackgroundImage:[UIImage imageNamed:@<span class="string">"nav_bg.png"</span>] <span class="keyword">for</span>BarMetrics:UIBarMetricsDefault];
</code></pre><p>示例工程中提供了两个背景图片：nav_bg.png 和 nav_bg_ios7.png。运行一下试试看吧，如下效果：<br><a href="http://beyondvincent.com/images/2013/11/13.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/13.jpg" alt=""></a></p>
<h3 id="定制返回按钮的颜"><a href=""></a>定制返回按钮的颜</h3>
<p>在iOS 7中，所有的按钮都是无边框的。其中返回按钮会有一个V型箭头，以及上一个屏幕中的标题(如果上一屏幕的标题是空，那么就显示”返回”)。要想给返回按钮着色，可以使用tintColor属性。如下代码所示：<br>    1</p>
<pre><code><span class="string">[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]]</span>;
</code></pre><p>除了返回按钮，tintColor属性会影响到所有按钮标题和图片。<br><a href="http://beyondvincent.com/images/2013/11/14.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/14.jpg" alt=""></a><br>如果想要用自己的图片替换V型，可以设置图片的<code>backIndicatorImage</code>和<code>backIndicatorTransitionMaskImage</code>。如下代码所示：<br>    1<br>    2</p>
<pre><code><span class="string">[[UINavigationBarappearance]setBackIndicatorImage:[UIImageimageNamed:@"back_btn.png"]]</span>;<span class="string">[[UINavigationBarappearance]setBackIndicatorTransitionMaskImage:[UIImageimageNamed:@"back_btn.png"]]</span>;
</code></pre><p>图片的颜色是由tintColor属性控制的。<br><a href="http://beyondvincent.com/images/2013/11/15.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/15.jpg" alt=""></a></p>
<h3 id="修改导航栏标题的字体"><a href=""></a>修改导航栏标题的字体</h3>
<p>跟iOS 6一样，我们可以使用导航栏的<code>titleTextAttributes</code>属性来定制导航栏的文字风格。在text<br> attributes字典中使用如下一些key，可以指定字体、文字颜色、文字阴影色以及文字阴影偏移量：</p>
<ul>
<li>UITextAttributeFont – 字体key</li>
<li>UITextAttributeTextColor – 文字颜色key</li>
<li>UITextAttributeTextShadowColor – 文字阴影色key</li>
<li>UITextAttributeTextShadowOffset – 文字阴影偏移量key</li>
</ul>
<p>如下代码所示，对导航栏的标题风格做了修改：<br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7</p>
<pre><code>NSShadow*<span class="built_in">shadow</span>=[[NSShadowalloc]init];<span class="built_in">shadow</span>.shadowColor=[UIColorcolorWithRed:<span class="number">0.0</span>green:<span class="number">0.0</span>blue:<span class="number">0.0</span>alpha:<span class="number">0.8</span>];<span class="built_in">shadow</span>.shadowOffset=CGSizeMake(<span class="number">0</span>,<span class="number">1</span>);[[UINavigationBarappearance]setTitleTextAttributes:[NSDictionarydictionaryWithObjectsAndKeys:[UIColorcolorWithRed:<span class="number">245.0</span>/<span class="number">255.0</span>green:<span class="number">245.0</span>/<span class="number">255.0</span>blue:<span class="number">245.0</span>/<span class="number">255.0</span>alpha:<span class="number">1.0</span>],NSForegroundColorAttributeName,<span class="built_in">shadow</span>,NSShadowAttributeName,[UIFontfontWithName:@<span class="string">"HelveticaNeue-CondensedBlack"</span>size:<span class="number">21.0</span>],NSFontAttributeName,nil]];
</code></pre><p>运行效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/16.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/16.jpg" alt=""></a></p>
<h3 id="修改导航栏标题为图片"><a href=""></a>修改导航栏标题为图片</h3>
<p>如果要想将导航栏标题修改为一个图片或者logo，那么只需要使用下面这行代码即可：<br>    1</p>
<pre><code>self.navigationItem.titleView = <span class="string">[[UIImageView alloc] initWithImage:[UIImage imageNamed:@"appcoda-logo.png"]]</span>;
</code></pre><p>上面的代码简单的修改了titleView属性，将一个图片赋值给它。 注意：这不是iOS 7中的新功能，之前的iOS版本就可以已经有了。<br>具体效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/17.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/17.jpg" alt=""></a></p>
<h3 id="添加多个按钮"><a href=""></a>添加多个按钮</h3>
<p>同样，这个技巧也不是iOS 7的，开发者经常会在导航栏中添加多个按钮，所以我决定在这里进行介绍。我们可以在导航栏左边或者右边添加多个按钮。例如，我们希望在导航栏右边添加一个照相机和分享按钮，那只需要使用下面的代码即可：<br>    1<br>    2<br>    3<br>    4<br>    5</p>
<pre><code><span class="built_in">UIBarButtonItem</span>*shareItem=[[UIBarButtonItemalloc]initWithBarButtonSystemItem:UIBarButtonSystemItemActiontarget:selfaction:<span class="literal">nil</span>];<span class="built_in">UIBarButtonItem</span>*cameraItem=[[UIBarButtonItemalloc]initWithBarButtonSystemItem:UIBarButtonSystemItemCameratarget:selfaction:<span class="literal">nil</span>];<span class="built_in">NSArray</span>*actionButtonItems=@[shareItem,cameraItem];<span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.rightBarButtonItems</span>=actionButtonItems;
</code></pre><p>如下效果：<br><a href="http://beyondvincent.com/images/2013/11/18.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/18.jpg" alt=""></a></p>
<h3 id="修改状态栏的风格"><a href=""></a>修改状态栏的风格</h3>
<p>在老版本的iOS中，状态栏永远都是白色风格。而在iOS 7中，我们可以修改每个view controller中状态栏的外观。通过UIStatusBarStyle常量可以指定状态栏的内容是暗色或亮色。默认情况下，状态栏的显示是暗色。也就是说，状态栏上的时间、电池指示器和Wi-Fi信号显示为暗色。如果导航栏中使用暗色为背景，那么看起来的效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/19.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/19.jpg" alt=""></a><br>如上图这种情况下，我们可能希望将导航栏的风格修改为亮色。这里有两个方法可以实现。在iOS 7中，我们可以在每个view controller中overriding<code>preferredStatusBarStyle:</code>方法，如下所示：<br>    1<br>    2<br>    3<br>    4</p>
<pre><code>-(UIStatusBarStyle)preferredStatusBarStyle{<span class="keyword">return</span>UIStatusBarStyleLightContent;}
</code></pre><p>上面代码的效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/20.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/20.jpg" alt=""></a><br>在iOS 7中，通过上面的方法来修改状态栏风格非常的棒。另外，我们也可以使用UIApplication的statusBarStyle方法来设置状态栏，不过，首先需要停止使用<code>View
 controller-based status bar appearance</code>。在project target的Info tab中，插入一个新的key，名字为<code>View
 controller-based status bar appearance</code>，并将其值设置为NO。<br><a href="http://beyondvincent.com/images/2013/11/21.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/21.jpg" alt=""></a><br>然后就可以使用下面的代码来设置状态栏风格了：<br>    1</p>
<pre><code><span class="attr_selector">[[UIApplication sharedApplication]</span> <span class="tag">setStatusBarStyle</span><span class="pseudo">:UIStatusBarStyleLightContent</span>];
</code></pre><h3 id="隐藏状态栏"><a href=""></a>隐藏状态栏</h3>
<p>有时候我们需要隐藏状态栏，那么此时我们在view controller中override方法prefersStatusBarHidden:即可，如下代码所示：<br>    1<br>    2<br>    3<br>    4</p>
<pre><code>-(BOOL)prefersStatusBarHidden{<span class="keyword">return</span>YES;}
</code></pre><h3 id="总结"><a href=""></a>总结</h3>
<p>iOS 7给开发者提供了一些新的自由度来定制导航栏和状态栏的外观。希望上面的这些技巧能对你有用。<br>这里可以下载到<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip" target="_blank" rel="external">示例工程源码</a>。只需要取消相关代码注释即可进行测试。<br><a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之UI/">iOS应用开发之UI</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios/">ios</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios7适配/">ios7适配</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-08T05:09:00.000Z"><a href="/2014/01/08/IOS开发之Block 编程（翻译官方文档）/">1月 8 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/08/IOS开发之Block 编程（翻译官方文档）/">IOS开发之Block 编程（翻译官方文档）</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>本文转自：<a href="http://blog.csdn.net/perfect_promise/article/details/7757746" target="_blank" rel="external">http://blog.csdn.net/perfect_promise/article/details/7757746</a></p>
<p>注：小弟才疏学浅，英文水平够烂，若有不正确或误导的地方，请大家指出，欢迎大家指正和修改。本文中涉及的词法范围：作用范围，例如if{}else{}，两个{}分别是if和else的作用范围。#<a href=""></a>介绍<br>Block对象是一个C级别的语法和运行机制。它与标准的C函数类似，不同之处在于，它除了有可执行代码以外，它还包含了与堆、栈内存绑定的变量。因此，Block对象包含着一组状态数据，这些数据在程序执行时用于对行为产生影响。</p>
<p>你可以用Block来写一些可以传到API中的函数语句，可选择性地存储，并可以使用多线程。作为一个回调，Block特别的有用，因为block既包含了回调期间的代码，又包含了执行期间需要的数据。<br>作为Mac OS X v10.6 Xcode开发工具附带的工具，Block在GCC和Clang中同样可用。你能在Mac OS X v10.6 及其以上版本和iOS 4.0及其以上版本中使用Block。.Block的运行是开源的，因此你能在<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/" target="_blank" rel="external">LLVM’s<br> compiler-rt subproject repository</a>里面找到它。Block也已经被提交到C标准工作组作为 <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1370.pdf" target="_blank" rel="external">N1370:<br> Apple’s Extensions to C</a>。 由于Objective-C 和 C++ 都是衍生自 C，block被设计为可同时兼容这三种语言。<br>你应该阅读这篇文档，去学习Block是什么，以及在C、C++和OC中如何使用Block使你的程序更加的高效和更易于维护。</p>
<h2 id="声明和使用Block"><a href=""></a>声明和使用Block</h2>
<p>用^操作符来声明一个Block变量，并指明Block述句的开始。Block的主体部分包含在 <code>{}内，像下面的例子中一样（与C语法一样，“；”指明语句的结束）：</code><br>    int multiplier = 7;<br>    int (^myBlock)(int) = ^(int num) {<br>        return num <em> multiplier;<br>    };<br><img src="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Art/blocks.jpg" alt="image: ../Art/blocks.jpg">注意：Block可以使用定义范围之内的任何变量。<br>如果你把Block声明为一个变量，你以后就可以像调用一个方法一样使用它：<br>    int multiplier = 7;<br>    int (^myBlock)(int) = ^(int num) {<br>        return num </em> multiplier;<br>    };</p>
<pre><code><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>"</span>, myBlock(<span class="number">3</span>));
<span class="regexp">//</span> prints <span class="string">"21"</span>
</code></pre><h1 id="直接使用Block"><a href=""></a>直接使用Block</h1>
<p>很多情况下，你不需要声明Block变量；你只是简单地写一个Block语句内联在需要使用它作为参数的地方。下面的例子使用了 <code>qsort_b方法，</code>qsort_b方法与标准的qsort_r类似，只是用Block作为它的最后一个参数。``<br>    char *myCharacters[3] = { “TomJohn”, “George”, “Charles Condomine” };</p>
<pre><code>qsort_b(myCharacters, 3, sizeof(char <span class="keyword">*</span>), ^(const void <span class="keyword">*</span>l, const void <span class="keyword">*</span>r) {
    char <span class="keyword">*</span>left = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)l;
    char <span class="keyword">*</span>right = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)r;
    return strncmp(left, right, 1);
});

// myCharacters is now { <span class="string">"Charles Condomine"</span>, <span class="string">"George"</span>, <span class="string">"TomJohn"</span> }
</code></pre><h1 id="Cocoa_Block"><a href=""></a>Cocoa Block</h1>
<p>Cocoa框架中有几个方法使用Block作为参数，通常是在执行对象的操作集合，或者操作完成后使用它作为回调。下面的例子向我们展示了<br><code>在NSArray</code> 对象的方法<code>[sortedArrayUsingComparator:怎样使用Block](http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/NSArray.html#//apple_ref/occ/instm/NSArray/sortedArrayUsingComparator:)</code>.。这个方法只有单一的参数，block被定义为<code>[NSComparator](http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSComparator)</code> 局部变量：<br>    NSArray *stringsArray = [NSArray arrayWithObjects:<br>                                     @”string 1”,<br>                                     @”String 21”,<br>                                     @”string 12”,<br>                                     @”String 11”,<br>                                     @”String 02”, nil];</p>
<pre><code>static NSStringCompareOptions comparisonOptions = NSCaseInsensitiveSearch | NSNumericSearch |
        NSWidthInsensitiveSearch | NSForcedOrderingSearch;
NSLocale *currentLocale = [NSLocale currentLocale];

NSComparator finderSortBlock = ^(<span class="property">id</span> string1, <span class="property">id</span> string2) {

    NSRange string1Range = NSMakeRange(<span class="number">0</span>, [string1 <span class="property">length</span>]);
<span class="command">    return</span> [string1 compare:string2 options:comparisonOptions range:string1Range locale:currentLocale];
};

NSArray *finderSortArray = [stringsArray sortedArrayUsingComparator:finderSortBlock];
NSLog(@<span class="string">"finderSortArray: %@"</span>, finderSortArray);

/*
Output:
finderSortArray: (
    <span class="string">"string 1"</span>,
    <span class="string">"String 02"</span>,
    <span class="string">"String 11"</span>,
    <span class="string">"string 12"</span>,
    <span class="string">"String 21"</span>
)
*/
</code></pre><h2 id="_block变量"><a href=""></a>_block变量</h2>
<p>Block的一个强大的特性是，它能在相同的词法范围内修改变量值。Block能修改变量是通过_block存储类型标示符。与 <a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxGettingStarted.html#//apple_ref/doc/uid/TP40007502-CH7-SW4" target="_blank" rel="external">“Cocoa<br> Block”</a> 中的例子一样，你能使用一个block变量来计算有多少字符串与下面例子中是相同的。 Block直接被用，并且用 <code>currentLocale作为一个只读变量在block中。</code><br>    NSArray *stringsArray = [NSArray arrayWithObjects:<br>                             @”string 1”,<br>                             @”String 21”, // &lt;-<br>                             @”string 12”,<br>                             @”String 11”,<br>                             @”Strîng 21”, // &lt;-<br>                             @”Striñg 21”, // &lt;-<br>                             @”String 02”, nil];</p>
<pre><code>NSLocale *currentLocale = [NSLocale currentLocale];
__block NSUInteger orderedSameCount = <span class="number">0</span>;

NSArray *diacriticInsensitiveSortArray = [stringsArray sortedArrayUsingComparator:^(<span class="property">id</span> string1, <span class="property">id</span> string2) {

    NSRange string1Range = NSMakeRange(<span class="number">0</span>, [string1 <span class="property">length</span>]);
    NSComparisonResult comparisonResult = [string1 compare:string2 options:NSDiacriticInsensitiveSearch range:string1Range locale:currentLocale];

    <span class="keyword">if</span> (comparisonResult == NSOrderedSame) {
        orderedSameCount++;
    }
<span class="command">    return</span> comparisonResult;
}];

NSLog(@<span class="string">"diacriticInsensitiveSortArray: %@"</span>, diacriticInsensitiveSortArray);
NSLog(@<span class="string">"orderedSameCount: %d"</span>, orderedSameCount);

/*
Output:

diacriticInsensitiveSortArray: (
    <span class="string">"String 02"</span>,
    <span class="string">"string 1"</span>,
    <span class="string">"String 11"</span>,
    <span class="string">"string 12"</span>,
    <span class="string">"String 21"</span>,
    <span class="string">"Str\U00eeng 21"</span>,
    <span class="string">"Stri\U00f1g 21"</span>
)
orderedSameCount: <span class="number">2</span>
*/
</code></pre><p>更详细的内容请查看 <a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW1" target="_blank" rel="external">“Blocks<br> 和变量.”</a></p>
<h1 id="Block功能"><a href=""></a>Block功能</h1>
<p>Block是一个匿名的内嵌代码集：</p>
<ul>
<li><p>与方法一样，有一个类型参数列表</p>
</li>
<li><p>有一个隐形或声明的返回类型</p>
</li>
<li><p>能从它定义的词法范围内获取状态</p>
</li>
<li><p>能有选择性地修改词法范围中的状态</p>
</li>
<li><p>能共享相同词法范围内其他块定义的修改的潜在性</p>
</li>
<li><p>词法范围被销毁后仍能继续在已定义的词法范围内共享和修改状态</p>
</li>
</ul>
<p>你能复制一个block，并把它传递给其他线程来延迟执行（或者，在它自己的线程内，做一个运行环）。编译和运行过程中，从block中引用的所有变量都保留乐一份block的副本。block不仅适用于纯 C 和 C++，同时block也是一个Objective-C 对象。</p>
<h1 id="用法"><a href=""></a>用法</h1>
<p>Blocks通常表示比较小的，独立的代码段。因此，它特别适用于可能被同时执行的封装单元工作的模式，或者是集合中的项目，或者是当另一个操作完成后的一个回调。<br>Blocks之所以能替代传统的回调方法主要有以下两个理由：</p>
<ol>
<li><p>它允许你在调用点写代码，调用点稍后会在方法实现段被执行。<br>Blocks通常也是框架方法中的参数。</p>
</li>
<li><p>它允许访问局部变量。<br>与其使用回调，需要一个包含所有上下文信息的数据结构，你只需要执行一个操作，直接访问局部变量即可。</p>
</li>
</ol>
<h1 id="声明block参考"><a href=""></a>声明block参考</h1>
<p>Block变量持有Block引用。 声明它的语法与在函数中声明指针类似，用 <code>^代替</code> <code>*。</code> 其余部分，与C类型系统，具有完全的互操作性。以下时所有有效块的变量声明：<br>    void (^blockReturningVoidWithVoidArgument)(void);<br>    int (^blockReturningIntWithIntAndCharArguments)(int, char);<br>    void (^arrayOfTenBlocksReturningVoidWithIntArgument[10])(int);<br>Block支持可变参数 (<code>...</code>)参数。 不带任何参数的block，在参数列表中必须指定为void。Block的设计考虑到类型安全，通过提供给编译器全套的元数据来验证block的使用、传递参数到block中和返回值分配。一个块引用可以转换到任意类型的指针，反之亦然。但是，你不能通过*来获得block的值，因而在编译时，block的大小也不能被计算出来。<br>你可以创建一个block类型，当你在多个地方使用到同一个签名的block时，这种方式时很好的。<br>    typedef float (^MyBlockType)(float, float);</p>
<pre><code>MyBlockType myFirstBlock = // <span class="keyword">...</span> ;
MyBlockType mySecondBlock = // <span class="keyword">...</span> ;
</code></pre><h1 id="创建block"><a href=""></a>创建block</h1>
<p>用^指明block语句的开始。在它后面的（）是参数列表。block的主体部分在{ }里面.。下面的例子定义了一个简单的block，并把先前定义的变量（oneForm）分配给它。<br>    int (^oneFrom)(int);</p>
<pre><code>oneFrom = ^(<span class="keyword">int</span> anInt) {
    <span class="keyword">return</span> anInt - <span class="number">1</span>;
};
</code></pre><p>如果你不显式声明块表达式的返回值，它可以根据block的内容进行自动匹配。如果返回类型和参数列表都是void，你也可以省略参数列表。 如果存在多个返回语句，应该正确的进行匹配(又需要的话，可以使用类型转换)。</p>
<h1 id="全局block"><a href=""></a>全局block</h1>
<p>在文件级别，你可以使用block作为一个全局表达式。</p>
<pre><code><span class="preprocessor">#import &lt;stdio.h&gt;</span>

<span class="keyword">int</span> GlobalInt = <span class="number">0</span>;
<span class="keyword">int</span> (^getGlobalInt)(<span class="keyword">void</span>) = ^{ <span class="keyword">return</span> GlobalInt; };
</code></pre><h1 id="变量类型"><a href=""></a>变量类型</h1>
<p>block对象的代码中，变量被看成五种不同的方式。<br>与函数一样，block支持三种标准类型的变量：</p>
<ul>
<li><p>全局变量，带有static修饰符的变量</p>
</li>
<li><p>全局函数（不是专门的变量）</p>
</li>
<li><p>局部变量和参数</p>
</li>
</ul>
<p>Blocks也支持其他两种变量类型：</p>
<ol>
<li><p>函数级别的_block变量。如有引用块被复制到堆，block中的_block变量是可变的。</p>
</li>
<li><p><code>const</code></p>
</li>
</ol>
<p>最后，在一个方法的实现，块可能引用的Objective-C的实例变量—参考<a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW3" target="_blank" rel="external">“Object<br> and Block Variables.”</a><br>以下是在block中使用变量的规则：</p>
<ol>
<li><p>可以访问全局变量，包括词法范围内存在的static变量。</p>
</li>
<li><p>可以传参给block，与传参给函数的方式是一样的。</p>
</li>
<li><p>局部词法范围内的堆栈变量被看成时const变量。<br>他们的值存放在程序内的block语句中。 在嵌套block中，他们的值来自于最近的词法范围内。</p>
</li>
<li><p>声明为_block类型的<br>局部词法范围内的变量是可改变的。更改的适用范围仅为局部词法范围，包括词法范围内定义的其他block。 在<a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6" target="_blank" rel="external">“The<br>__block Storage Type.”</a>中有更详细的描述。</p>
</li>
<li>block作用范围内声明的局部变量，与函数中的局部变量一样。<br>block的每一次调用，都重新生成此变量的新的副本。这些变量可以被转换为const或引用变量在块内的作用域。</li>
</ol>
<p>下面的例子说明了局部非静态变量的使用：</p>
<pre><code><span class="keyword">int</span> <span class="keyword">x</span> = <span class="number">123</span>;

void (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> <span class="keyword">y</span>) {

    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> <span class="variable">%d</span>\n"</span>, <span class="keyword">x</span>, <span class="keyword">y</span>);
};

printXAndY(<span class="number">456</span>); <span class="regexp">//</span> prints: <span class="number">123</span> <span class="number">456</span>
</code></pre><p>如上所述，在block内试图分配一个新的x的值将会报错：<br>    int x = 123;</p>
<pre><code>void (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> <span class="keyword">y</span>) {

    <span class="keyword">x</span> = <span class="keyword">x</span> + <span class="keyword">y</span>; <span class="regexp">//</span> error
    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> <span class="variable">%d</span>\n"</span>, <span class="keyword">x</span>, <span class="keyword">y</span>);
};
</code></pre><p>为了使一个变量在block内部可以被修改，你应该使用_block来修饰这个变量—参考 <a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6" target="_blank" rel="external">“The<br> __block Storage Type.”</a></p>
<h1 id="_block存储类型"><a href=""></a>_block存储类型</h1>
<p>在变量前面加上_block类型修饰符，我们可以指定传进来的变量是可变或者可读写的。_block存储与它类似，但是局部变量的寄存器、auto变量和static存储类型之间相互排斥。<br><code>_block变量共享变量之间的作用域和块之间的作用域拷贝变量存储范围内。因此，如果block中定义的所有拷贝在框架内的生存超越帧结束（例如，正在排队等待执行），堆栈帧被破坏后存储也将继续存在</code>。在一个给定的词法范围的多个块，可以同时使用共享变量。<br>作为优化，在堆栈上的块存储块启动就像自身调用一样。如果块被复制，使用Block_copy（或在Objective-C中块发送一个副本），变量将被复制到堆。因此，_block块的地址可以随时更改。<br>_block变量有两个进一步的限制：他们不能是可变数组，不能包含C99的可变长数组的结构。<br>下面的例子说明了_block变量的作用：<br>    __block int x = 123; //  x lives in block storage</p>
<pre><code><span class="keyword">void</span> (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> y) {

    x = x + y;
    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);
};
printXAndY(<span class="number">456</span>); <span class="comment">// prints: 579 456</span>
<span class="comment">// x is now 579</span>
</code></pre><p>下面的例子显示了几种类型的变量块的相互作用：<br>    extern NSInteger CounterGlobal;<br>    static NSInteger CounterStatic;</p>
<pre><code>{
    <span class="built_in">NSInteger</span> localCounter = <span class="number">42</span>;
    __block <span class="keyword">char</span> localCharacter;

    <span class="keyword">void</span> (^aBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) {
        ++CounterGlobal;
        ++CounterStatic;
        CounterGlobal = localCounter; <span class="comment">// localCounter fixed at block creation</span>
        localCharacter = <span class="string">'a'</span>; <span class="comment">// sets localCharacter in enclosing scope</span>
    };

    ++localCounter; <span class="comment">// unseen by the block</span>
    localCharacter = <span class="string">'b'</span>;

    aBlock(); <span class="comment">// execute the block</span>
    <span class="comment">// localCharacter now 'a'</span>
}
</code></pre><h1 id="对象和block变量"><a href=""></a>对象和block变量</h1>
<p>Block提供支持的Objective-C和C+ +的对象，和其他块，作为变量。</p>
<h3 id="Objective-C_对象"><a href=""></a>Objective-C 对象</h3>
<p>在手动引用计数的环境， 复制块时，块内使用局部变量保留。Block内使用的局部变量引用技术将retain。如果您想覆盖一个特定对象变量的这种行为，你可以标记_block修饰符来修饰该变量。<br>如果您使用ARC，当block被copy时对象变量被保留，并自动释放，和延迟释放。<br><a href="&quot;Note&quot;"></a><strong>注：在垃圾收集的环境，如果你给变量同时使用_weak和_block修饰符，那么该block将无法确保是否还存在。</strong></p>
<p>如果你在执行方法内使用block，实例变量对象的内存管理规则更加微妙：</p>
<ul>
<li><p>如果您访问实例变量的参照，对象retain；</p>
</li>
<li><p>如果您访问实例变量的值，对象retain；</p>
</li>
</ul>
<p>下面的例子说明了两种不同的情况：<br>    dispatch_async(queue, ^{<br>        // instanceVariable is used by reference, self is retained<br>        doSomethingWithObject(instanceVariable);<br>    });</p>
<pre><code>id localVariable = instanceVariable;
dispatch_async(queue, ^{
    <span class="regexp">//</span> localVariable <span class="keyword">is</span> used <span class="keyword">by</span> value, localVariable <span class="keyword">is</span> retained (<span class="keyword">not</span> self)
    doSomethingWithObject(localVariable);
});
</code></pre><h1 id="调用block"><a href=""></a>调用block</h1>
<p>如果你声明block作为一个变量，你可以像使用函数一样使用它，就像下面两个示例所示一样：<br>    int (^oneFrom)(int) = ^(int anInt) {<br>        return anInt - 1;<br>    };</p>
<pre><code><span class="built_in">printf</span>(<span class="string">"1 from 10 is %d"</span>, oneFrom(<span class="number">10</span>));
<span class="comment">// Prints "1 from 10 is 9"</span>

<span class="keyword">float</span> (^distanceTraveled) (<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>) =
                          ^(<span class="keyword">float</span> startingSpeed, <span class="keyword">float</span> acceleration, <span class="keyword">float</span> time) {

    <span class="keyword">float</span> <span class="built_in">distance</span> = (startingSpeed * time) + (<span class="number">0.5</span> * acceleration * time * time);
    <span class="keyword">return</span> <span class="built_in">distance</span>;
};

<span class="keyword">float</span> howFar = distanceTraveled(<span class="number">0.0</span>, <span class="number">9.8</span>, <span class="number">1.0</span>);
<span class="comment">// howFar = 4.9</span>
</code></pre><p>然而，通常情况下，你使用block作为一个函数或方法的参数，在这些情况下，你通常创建一个块“内联”。</p>
<h1 id="使用block作为函数参数"><a href=""></a>使用block作为函数参数</h1>
<p>可以把block作为函数参数进行传递，就像其他参数一样。然后，很多时候你不需要声明block；而你只需把他们内联到需要使用block作为一个参数的地方。下面的例子使用了 <code>qsort_b方法，</code>qsort_b方法与标准的qsort_r类似，只是用Block作为它的最后一个参数。``<br>    char *myCharacters[3] = { “TomJohn”, “George”, “Charles Condomine” };</p>
<pre><code>qsort_b(myCharacters, 3, sizeof(char <span class="keyword">*</span>), ^(const void <span class="keyword">*</span>l, const void <span class="keyword">*</span>r) {
    char <span class="keyword">*</span>left = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)l;
    char <span class="keyword">*</span>right = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)r;
    return strncmp(left, right, 1);
});
// Block implementation ends at <span class="string">"}"</span>

// myCharacters is now { <span class="string">"Charles Condomine"</span>, <span class="string">"George"</span>, <span class="string">"TomJohn"</span> }
</code></pre><p>请注意，该块包含在函数的参数列表。<br>下面的示例显示如何使用block的dispatch_apply函数。 <code>dispatch_apply``使用以下方式进行定义：</code><br>    void dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));<br>功能是提交一个block到一个调度队列进行多次调用。它携带了三个参数；第一个参数指定执行的迭代的数量；第二个参数指定block被提交到哪个队列； 点歌参数就是block自身，反过来这需要一个参数迭代的当前索引。<br>可以使用<code>dispatch_apply</code> 分别打印出迭代索引，如下所示：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;dispatch/dispatch.h&gt;</span>
size_t count = <span class="number">10</span>;
dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);

dispatch_apply(count, <span class="built_in">queue</span>, ^(size_t i) {
    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, i);
});
</code></pre><h1 id="使用block作为方法参数"><a href=""></a>使用block作为方法参数</h1>
<p><a href="">Cocoa提供了一种方法，使用blocks。传递block作为参数与传递其他参数的方式是一样的。</a><br>下面的示例，确定一个数组前五个元素中任意一个在过滤集中的索引数。<br>    NSArray <em>array = [NSArray arrayWithObjects: @”A”, @”B”, @”C”, @”A”, @”B”, @”Z”,@”G”, @”are”, @”Q”, nil];<br>    NSSet </em>filterSet = [NSSet setWithObjects: @”A”, @”Z”, @”Q”, nil];</p>
<pre><code><span class="built_in">BOOL</span> (^test)(<span class="keyword">id</span> obj, NSUInteger idx, <span class="built_in">BOOL</span> *stop);

test = ^ (<span class="keyword">id</span> obj, NSUInteger idx, <span class="built_in">BOOL</span> *stop) {

    <span class="keyword">if</span> (idx &lt; <span class="number">5</span>) {
        <span class="keyword">if</span> ([filterSet containsObject: obj]) {
            <span class="keyword">return</span> <span class="literal">YES</span>;
        }
    }
    <span class="keyword">return</span> <span class="literal">NO</span>;
};

<span class="built_in">NSIndexSet</span> *indexes = [array indexesOfObjectsPassingTest:test];

<span class="built_in">NSLog</span>(<span class="string">@"indexes: %@"</span>, indexes);

<span class="comment">/*
Output:
indexes: &lt;NSIndexSet: 0x10236f0&gt;[number of indexes: 2 (in 2 ranges), indexes: (0 3)]
*/</span>
</code></pre><p>下方的例子是确定一个NSSet对象中是否包含有局部变量指定的一个单词，如果包含的话，设置另一个局部变量的值为YES。found也被声明为一个_block变量， 这个block是定义联：<br>    __block BOOL found = NO;<br>    NSSet <em>aSet = [NSSet setWithObjects: @”Alpha”, @”Beta”, @”Gamma”, @”X”, nil];<br>    NSString </em>string = @”gamma”;</p>
<pre><code>[aSet enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) {
    <span class="keyword">if</span> ([obj localizedCaseInsensitiveCompare:string] == NSOrderedSame) {
        *stop = <span class="literal">YES</span>;
        found = <span class="literal">YES</span>;
    }
}];

<span class="comment">// At this point, found == YES</span>
</code></pre><h1 id="复制block"><a href=""></a>复制block</h1>
<p>通常情况下，你不需要复制（或保留）一个块。如果你想要block在它的定义域被销毁后仍可以被使用，你仅仅只需要创建一个副本。复制移动block到堆中。.<br>你能用C函数来复制和释放block：<br>    Block_copy();<br>    Block_release();<br>如果你使用Objective-C，block的属性可以使用copy、retain、release和autorelease。<br>为了避免产生内存泄露，block的copy和retain的使用必须平衡。使用了copy和retain的地方必须进行release（autorelease除外）——除非在一个垃圾收集环境。</p>
<h1 id="避免的模式"><a href=""></a>避免的模式</h1>
<p>块文本（即，^{…}）是一个堆栈的本地数据结构的地址块。因此堆栈的本地数据结构的范围是封闭的复合语句，所以你应该避免使用下例中的模式：,<br>    void dontDoThis() {<br>        void (^blockArray[3])(void);  // an array of 3 block references</p>
<pre><code>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {
        blockArray[i] = ^{ printf(<span class="string">"hello, %d\n"</span>, i); };
        // <span class="type">WRONG</span>: <span class="type">The</span> <span class="keyword">block</span> literal scope <span class="keyword">is</span> the <span class="string">"for"</span> loop
    }
}

<span class="type">void</span> dontDoThisEither() {
    <span class="type">void</span> (^<span class="keyword">block</span>)(<span class="type">void</span>);

    <span class="type">int</span> i = random():
    <span class="keyword">if</span> (i &gt; <span class="number">1000</span>) {
        <span class="keyword">block</span> = ^{ printf(<span class="string">"got i at: %d\n"</span>, i); };
        // <span class="type">WRONG</span>: <span class="type">The</span> <span class="keyword">block</span> literal scope <span class="keyword">is</span> the <span class="string">"then"</span> clause
    }
    // ...
}
</code></pre><h1 id="调试"><a href=""></a>调试</h1>
<p>在block中你可以设置断点进行单步调试。你可以从调用块内GDB会议调用一个block，如下例所示：<br>    $ invoke-block myBlock 10 20<br>如果你想传一个C字符串值，你必须使用引用。例如， 把这个字符串传到<code>doSomethingWithString</code> block中，你可以像下面这样写：<br>    $ invoke-block doSomethingWithString “\”this string\””</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
    <a href="/tags/iphone开发/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  
    <form>
      <input id="st-search-input" type="search" placeholder="Search">
    </form>
    <div id="st-results-container"></div>
  
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <div class="entry">
    
      <span><a href="/tags/2d/">2d<small>1</small></a></span>
    
      <span><a href="/tags/AFNetworking/">AFNetworking<small>2</small></a></span>
    
      <span><a href="/tags/CoreData/">CoreData<small>2</small></a></span>
    
      <span><a href="/tags/Drawing/">Drawing<small>1</small></a></span>
    
      <span><a href="/tags/MagicalRecord/">MagicalRecord<small>1</small></a></span>
    
      <span><a href="/tags/NSDate/">NSDate<small>1</small></a></span>
    
      <span><a href="/tags/NSString/">NSString<small>1</small></a></span>
    
      <span><a href="/tags/Swift/">Swift<small>9</small></a></span>
    
      <span><a href="/tags/UIAlertView/">UIAlertView<small>1</small></a></span>
    
      <span><a href="/tags/UITabBarController/">UITabBarController<small>1</small></a></span>
    
      <span><a href="/tags/UITableViewControlle/">UITableViewControlle<small>1</small></a></span>
    
      <span><a href="/tags/UIWebView/">UIWebView<small>1</small></a></span>
    
      <span><a href="/tags/URL-Scheme/">URL Scheme<small>1</small></a></span>
    
      <span><a href="/tags/URL编码/">URL编码<small>1</small></a></span>
    
      <span><a href="/tags/XMPP/">XMPP<small>3</small></a></span>
    
      <span><a href="/tags/Xcode5-1/">Xcode5.1<small>1</small></a></span>
    
      <span><a href="/tags/api/">api<small>5</small></a></span>
    
      <span><a href="/tags/appStore审核/">appStore审核<small>1</small></a></span>
    
      <span><a href="/tags/block/">block<small>1</small></a></span>
    
      <span><a href="/tags/bytearray/">bytearray<small>1</small></a></span>
    
      <span><a href="/tags/cell自适应高度/">cell自适应高度<small>1</small></a></span>
    
      <span><a href="/tags/cocos2d/">cocos2d<small>3</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发font/">fontfontiPhone开发font<small>1</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发fontfont/">fontfontiPhone开发fontfont<small>1</small></a></span>
    
      <span><a href="/tags/fontfontios的fontfont/">fontfontios的fontfont<small>2</small></a></span>
    
      <span><a href="/tags/fontfont动画fontfont/">fontfont动画fontfont<small>1</small></a></span>
    
      <span><a href="/tags/framework/">framework<small>1</small></a></span>
    
      <span><a href="/tags/iOS8/">iOS8<small>2</small></a></span>
    
      <span><a href="/tags/iOS8-1-1/">iOS8.1.1<small>1</small></a></span>
    
      <span><a href="/tags/iOS8定位/">iOS8定位<small>1</small></a></span>
    
      <span><a href="/tags/iOS国际化/">iOS国际化<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之app上架/">iOS应用开发之app上架<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之第三方框架/">iOS应用开发之第三方框架<small>1</small></a></span>
    
      <span><a href="/tags/iOS开发/">iOS开发<small>5</small></a></span>
    
      <span><a href="/tags/iOS自定义Tabbar/">iOS自定义Tabbar<small>1</small></a></span>
    
      <span><a href="/tags/ios/">ios<small>53</small></a></span>
    
      <span><a href="/tags/ios7/">ios7<small>1</small></a></span>
    
      <span><a href="/tags/ios7适配/">ios7适配<small>1</small></a></span>
    
      <span><a href="/tags/ios国际化/">ios国际化<small>1</small></a></span>
    
      <span><a href="/tags/ios开发/">ios开发<small>27</small></a></span>
    
      <span><a href="/tags/iphone/">iphone<small>4</small></a></span>
    
      <span><a href="/tags/iphone开发/">iphone开发<small>59</small></a></span>
    
      <span><a href="/tags/itunes/">itunes<small>1</small></a></span>
    
      <span><a href="/tags/objective-c/">objective-c<small>1</small></a></span>
    
      <span><a href="/tags/svn/">svn<small>1</small></a></span>
    
      <span><a href="/tags/uiimage/">uiimage<small>2</small></a></span>
    
      <span><a href="/tags/uitableview/">uitableview<small>1</small></a></span>
    
      <span><a href="/tags/uitableviewcell/">uitableviewcell<small>1</small></a></span>
    
      <span><a href="/tags/uitextfield/">uitextfield<small>1</small></a></span>
    
      <span><a href="/tags/uiview/">uiview<small>3</small></a></span>
    
      <span><a href="/tags/uiviewcontroller/">uiviewcontroller<small>1</small></a></span>
    
      <span><a href="/tags/uiwebview/">uiwebview<small>1</small></a></span>
    
      <span><a href="/tags/xcode/">xcode<small>2</small></a></span>
    
      <span><a href="/tags/xmpp/">xmpp<small>1</small></a></span>
    
      <span><a href="/tags/二维码/">二维码<small>1</small></a></span>
    
      <span><a href="/tags/企业/">企业<small>1</small></a></span>
    
      <span><a href="/tags/动画/">动画<small>5</small></a></span>
    
      <span><a href="/tags/国际化/">国际化<small>1</small></a></span>
    
      <span><a href="/tags/在线工具/">在线工具<small>1</small></a></span>
    
      <span><a href="/tags/多线程/">多线程<small>1</small></a></span>
    
      <span><a href="/tags/存储/">存储<small>1</small></a></span>
    
      <span><a href="/tags/宏/">宏<small>1</small></a></span>
    
      <span><a href="/tags/导航/">导航<small>1</small></a></span>
    
      <span><a href="/tags/屏幕旋转/">屏幕旋转<small>2</small></a></span>
    
      <span><a href="/tags/应用程序/">应用程序<small>2</small></a></span>
    
      <span><a href="/tags/微信开放平台ios/">微信开放平台ios<small>1</small></a></span>
    
      <span><a href="/tags/打开AppStore/">打开AppStore<small>1</small></a></span>
    
      <span><a href="/tags/数据库/">数据库<small>1</small></a></span>
    
      <span><a href="/tags/缓存/">缓存<small>1</small></a></span>
    
      <span><a href="/tags/聊天/">聊天<small>1</small></a></span>
    
      <span><a href="/tags/苹果应用商店/">苹果应用商店<small>1</small></a></span>
    
      <span><a href="/tags/获取iP地址/">获取iP地址<small>1</small></a></span>
    
  </div>
</div>




  <script type="text/javascript">
    (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
    })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

    _st('install','6xH6jcZvsZxn2a9rcU4t');
  </script>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div id="foot-nav">
  <ul class="social">
    
      <li><a class="github" href="https://github.com/DaiXiang" title="github">github</a></li>
    
      <li><a class="rss" href="/atom.xml" title="rss">rss</a></li>
    
  </ul>
</div>
<div>
  
    &copy; 2014 尹现伟
  
</div>
<div class="clearfix"></div></footer>
  


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<script type="text/javascript">
  function navbar() {
    var top = $('#nav-top').innerHeight();
    $('#header').css('min-height', top);
  }
  navbar();
  $(window).resize(navbar);
</script>
<div id="totop" class="footer-btn">
  <a title="Return to Top"><img src="/img/scrollup.png"/></a>
</div>

<script type="text/javascript">
  $(function(){ 
	// When to show the scroll link
	// higher number = scroll link appears further down the page   
	var upperLimit = 800;
	
	// Our scroll link element
	var scrollElem = $('#totop');
   
	// Scroll to top speed
	var scrollSpeed = 500;
   
	// Show and hide the scroll to top link based on scroll position   
	scrollElem.hide();
	$(window).scroll(function () {            
		var scrollTop = $(document).scrollTop();       
		if ( scrollTop > upperLimit ) {
		  $(scrollElem).stop().fadeTo(300, 1); // fade back in
		  $(scrollElem).animate({bottom: "50px"}, { queue: false, duration: 10 });
		} else {
		  $(scrollElem).stop().fadeTo(300, 0); // fade out
	      $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
			
		}
	});

	// Scroll to top animation on click
	$(scrollElem).click(function(){
	  $('html, body').animate({scrollTop:0}, scrollSpeed);
	  $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
	  return false;
	});
  });
</script>
</body>
</html>