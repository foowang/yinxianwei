<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ios | 一枝红杏出墙来</title>
  <meta name="author" content="尹现伟">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="一枝红杏出墙来"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="shortcut icon">
  <link rel="alternate" href="/atom.xml" title="一枝红杏出墙来" type="application/atom+xml">
  <link rel="stylesheet" href="/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
  

</head>


<body>
  <header id="header" class="inner"><div id="nav-top">
  <div class="alignleft main-title">
    <h1>一枝红杏出墙来</h1>
    <h2></h2>
  </div>
  <nav id="main-nav" class="alignright">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title tag">ios</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-10-20T08:16:00.000Z"><a href="/2014/10/20/iOS生成特定形状、彩色的二维码/">10月 20 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/10/20/iOS生成特定形状、彩色的二维码/">iOS生成特定形状、彩色的二维码</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>Git地址：<a href="https://github.com/smallMas/FMTQRCode" target="_blank" rel="external">https://github.com/smallMas/FMTQRCode</a><br>可惜没有生成中间带有logo的二维码</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之第三方框架/">iOS应用开发之第三方框架</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/二维码/">二维码</a>, <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-20T08:54:00.000Z"><a href="/2014/02/20/国人当自强：两岸三地在线编程学习网站大搜罗/">2月 20 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/20/国人当自强：两岸三地在线编程学习网站大搜罗/">国人当自强：两岸三地在线编程学习网站大搜罗</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><strong>       本文转自：<a href="http://www.csdn.net/article/2013-12-12/2817782-best-websites-to-learn-mobile-dev-in-china/1" target="_blank" rel="external">http://www.csdn.net/article/2013-12-12/2817782-best-websites-to-learn-mobile-dev-in-china/1</a></strong><br><strong>       摘要：</strong>在本文中，我们介绍了来自两岸三地的编程学习网站，通过它们，不仅可以一窥国内App开发的发展现状，而且这些网站各有特点，无论是主打游戏学习还是视频学习，对于想要自学的开发者而言，都是个好去处。<br>说到国内的在线编程学习网站，很多人都是一脸茫然，即使是资深开发者也是如此。在许多人眼中，尽管国内App开发景象一派繁荣，但教育疲软却是不争的事实。在《<a href="http://www.csdn.net/article/2013-12-05/2817687-best-websites-to-learn-mobile-dev-and-design" target="_blank" rel="external"><strong>移动开发者的自学宝典：十大在线编程学习网站</strong></a>》之后，笔者心生了搜罗国内在线编程学习网站的想法。在本文中，我们介绍了来自两岸三地的编程学习网站，通过它们，不仅可以一窥国内App开发的发展现状，而且在这些网站中，有些主打游戏学习，有些主打视频学习，各有特点，对于想要自学的开发者而言，不可谓不是个好去处。</p>
<h3 id="1-_Fenby">1. <a href="http://www.fenby.com/" target="_blank" rel="external">Fenby</a></h3>
<p>在国内为数不多的几个在线编程学习网站中，Fenby颇有知名度，也深受开发者喜爱。的确，对于一心想要寻找中文在线编程学习平台的用户而言，Fenby确实很好。Fenby是一个免费的在线编程互动编程学习网站，提供在线课程、互动问答、编程大赛和练习等。Fenby的运营理念很类似于Codecademy，强调趣味，而据Fenby官方介绍，他们也正是为了解决厚重乏味的书本、艰涩难搭的运行环境和枯燥冗长的视频这三大难题而生的。<br><a href="http://cms.csdnimg.cn/article/201312/12/52a9612fb5678.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/12/52a9612fb5678_middle.jpg" alt=""></a><br>说到Fenby的知识点讲授方面，则更像Treehouse，通过在视频中加入拟物、拟人等类比的知识点讲解，以及很多可视化的动画元素，让学习也变得生动有趣。而在视频教学之后，就会进入一个课堂练习的环节，用户可以在Fenby的在线编译器中输入代码，进行练习操作。<br><a href="http://cms.csdnimg.cn/article/201312/12/52a964d66d854.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/12/52a964d66d854_middle.jpg" alt=""></a><br>Fenby的这个在线代码编译器还是他们自主开发的，是不是很牛叉？除了课堂练习之外，在Fenby上，还有一个闪电编程的模块，初学者可以直接在这里起步，而开发者，则可以将代码粘贴到这里，运行调试程序。<br><strong>2. <a href="http://www.gkk.cn/" target="_blank" rel="external">中国IT公开课排行榜</a></strong><br>接下来，再介绍一个很赞的网站——中国IT公开课排行榜（以下简称为“GKK.CN”）。GKK.CN是北京尚网旗下的一个视频教程平台，在GKK.CN上，有包括应用开发、网站开发、设计等在内的各种原创IT视频教程，并且还都是免费的。<br><a href="http://cms.csdnimg.cn/article/201312/12/52a983ce5187f.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/12/52a983ce5187f_middle.jpg" alt=""></a><br>GKK.CN视频教学不仅全面，而且还有GKK.CN本身还有Android、iOS客户端，无论是在PC、平板电脑、智能手机上，用户都可以随时随地进行视频学习，此外，对于自己喜欢的视频，用户还可以收藏或下载。<br><strong>3. <a href="http://www.microoh.com/" target="_blank" rel="external">麦可网</a></strong><br>相比其他网站，在移动开发上，麦可网明显要更专业得多，这是一家垂直于移动开发课程、专注于打造以移动开发者为核心的实名生态圈的在线教育网站，于2012年正式上线，其前身为Android开发联盟。在麦可上，只有移动互联网和IT职业英语两类视频课程，其中，移动互联网又按技术种类划分为Android、手游、WP及iOS应用开发。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa67ac08cd8.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa67ac08cd8_middle.jpg" alt=""></a><br>在国内在线教育创业圈子里，麦可网是少数中的少数，能持续盈利，还能将视频价格卖到几千块，麦可的的确确如它的介绍所言，将教育做到极致，当之无愧是国内在线教育中的一匹黑马。如此大受欢迎，麦可自有其独到之处。麦可网上的所有课程都是由具有多年开发经验的自聘讲师制作，用户既可以加入麦可的实名圈子，学习它上面的课程，也可以加入其名师圈子，进行教学授课。         </p>
<p><strong>4. <a href="http://www.kaikeba.com/" target="_blank" rel="external">开课吧</a></strong><br>开课吧是国内首家专注于泛IT学科领域的垂直B2C在线教育服务平台，成立于2013年，是一个全新设计的基于移动云计算的混合式教学平台。集在线课程的创意、设计、前期拍摄、后期制作、综合运营为一体，面向个人、高校和企事业单位提供在线内容服务、在线教育平台运营服务和在线课程制作服务等综合在线教育解决方案。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa6d5a1c434.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa6d5a1c434_middle.jpg" alt=""></a><br>开课吧的课程有云计算、互联网营销、交互设计、大数据及编程开发五大类之分，均来自于世界著名学府、泛IT行业领军企业、泛IT行业知名培训机构及名师大腕之手。以线上学习与线下考试相结合的O2O混合教学模式，并通过提供多个3-10分钟的视频短片，用图像、动画的方式寓教于乐，既能引起学习者的兴趣，也能提高学习效率、增强学习效果。<br><strong>5. <a href="http://www.duobei.com/explore/tag/iOS" target="_blank" rel="external">多贝公开课</a></strong><br>在知乎上，说到在线教育网站，许多人对于多贝网都是颇为赞誉，更有甚者直言“找老师，上多贝”。多贝公开课是一个专注于兴趣培养、技能培训的线上C2C公开课开放平台。在多贝网上，讲师可以快速举办在线互动讲座和公开课，并自动生成回放；学生则可以轻松检索和观看各种课程，并直接与老师取得联系。多贝网所实现的其实很简单，就是零负担学习、零负担授课，让所有人都能体验人人为师、人人为学的线上互动。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa7aaa5203e.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa7aaa5203e_middle.jpg" alt=""></a><br>多贝网的课程类别甚广，有兴趣、健康、考试、职场、互联网（产品、设计、创业等）、IT技术（iOS、Android等）、语言、营销等多个类别，对于想要学习移动应用开发和设计的童鞋而言，修学多贝公开课可能不会让你成为顶级大牛，却可以让你快速起步，一步一步从新手变高手。<br><strong>6. <a href="http://www.ucai.cn/course" target="_blank" rel="external">优才网</a></strong><br>优才网是北京优才创智科技有限公司旗下的一个在线教育服务网站，主要提供互联网和移动互联网的培训。优才网在一定程度上借鉴了Codecademy人机互动的游戏模式，但在本质上却不尽相同。优才网所采用的是“人机互动”与传统在线教育“社区知识教学”相结合的方式去做在线教育。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa80c8314fc.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa80c8314fc_middle.jpg" alt=""></a><br>优才网的课程主要面向个人及院校，分为前端、后端、iOS、Android四大开发方向，涵盖应用、手游、跨平台、HTML5等开发。按学习程度分配班级，学员可以相互交流学习心得，并找到相应“辅导老师”答疑解惑，优才网的教学模式更像是一所完整的“网络大学”，全方位满足学生的学习需求。<br><strong><a href="http://hero.pongo.cn/" target="_blank" rel="external"></a><a href="http://www.csdn.net/" target="_blank" rel="external"></a></strong><br>和一般的在线编程学习网站不同，庞果网的在线编程网站Hero英雄会主打“挑战”二字，面向广大程序员，定期发布挑战题目或比赛。在这里，程序员不仅可以提升自己，与高手切磋。而且，只要赢得挑战，就可以获得头衔、奖品以及名企职位等。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aaa3855e05a.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aaa3855e05a_middle.jpg" alt=""></a><br><strong>8. <a href="http://wanbiancheng.com/" target="_blank" rel="external">玩编程</a></strong><br>对于想要自学编程的人来说，也许玩编程更合适。玩编程是由一群曾经自学过编程的工程师、设计师、产品经理和创业家组成的团队创立的，其实这个创始团队本身就是一个很好的自学编程例子。玩编程联合创始人之一高健凯来自台湾，非技术出身，却能去尝试，并坚持下来，还从举办分享编程经验的公开课到现在创建玩编程，这本身就是件很了不起的事情。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aaaa4bb6ae3.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aaaa4bb6ae3_middle.jpg" alt=""></a><br>事实上，自学编程是一件说起来容易但实践起来却非常困难的事情。因为经历过，了解其中的滋味，玩编程以短视频的互动式教学方式为用户提供更容易、更有趣、更有效的编程学习体验。目前，玩编程尚在内测中，只提供iOS开发课程，都是通过一些最真实有趣的App讲解，让用户在学到知识的同时，也学会如何做出一款最酷的iOS应用。<br><strong>9. <a href="http://codetank.alloyteam.com/" target="_blank" rel="external">代码坦克</a>（CodeTank）</strong><br>代码坦克是腾讯推出的一款相当有趣且极具挑战性的编程对战游戏，通过它，用户可以用JavaScript语言来编写属于自己的坦克机器人，并与其他人的坦克进行战斗。因为游戏是不能直接操控坦克的，所以开发者需要用代码和算法让坦克动起来，并更具战斗力。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aaae0c96bfd.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aaae0c96bfd_middle.jpg" alt=""></a><br>用真正游戏的方式进行编程语言学习，在国内来说很新颖。CodeTank是全球首个JavaScript程序员的在线编程对战游戏，是由腾讯AlloyTeam和HTML5梦工场联合出品的在线坦克仿真游戏平台，采用HTML5、Javascript、CSS3、NodeJS、MongoDB等Web技术来构建一个基于互联网的在线智能坦克机器人战斗仿真引擎。<br><strong>10. <a href="http://code4app.com/" target="_blank" rel="external">Code4App</a></strong><br>此处所介绍的Code4App，从严格意义上来讲，并不属于在线编程学习网站范畴，但它确实是一个对于移动开发者非常有用的网站，是iOS开发者的好帮手。Code4App是一个面向移动开发者的开源代码收集和分享网站，在这里，开发者可以便捷地找到自己所需要的代码，以减少在不同App开发过程中重复造车，从而大大提高开发效率。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa8d8fc863a.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa8d8fc863a_middle.jpg" alt=""></a><br>因“让移动开发者不再重复造轮子”而生，致力于做国内最好的、移动开发平台的开源代码收集网站。Code4App会为每份代码做严格的模拟机和真机测试，并配上文字说明、屏幕截图以及视频演示，除此之外，还允许用户自行上传代码分享给其他用户。也正因为这样，Code4App颇受开发者青睐。目前Code4App只推出了iOS平台，但在未来也会加入Android、WP等其他移动平台。<br><strong>11. <a href="http://www.tutor.compbrother.com/" target="_blank" rel="external">香港电脑补习网</a>、<a href="http://www.systematic.com.hk/iphone-programming.htm" target="_blank" rel="external">Systematic系统电脑教育中心</a></strong><br>不久之前，在微博上看到有人讨论香港的IT行业，让笔者有了一窥香港的App开发的冲动。即使是现在，许多人对于香港的移动互联网还是充满憧憬和向往的。可是，尽管有一些非常不错的移动互联网公司，但整体上却并不如人意。即使因为智能设备在香港的大幅度普及，即使受到内地风生水起的影响，为App开发创造了一些机会，但其环境却已大不如前。<br>在许多香港本土居民的眼中，搞开发是项没有前途的事业。在这种情况下，香港的在线编程教育实在难以雄起，在搜罗过程中，笔者发现，说到应用开发学习，香港的编程学习网站有特点实在是凤毛麟角，更多的是以线上线下相结合的方式，而首推的便是香港电脑补习网、Systematic系统电脑教育中心，都是线下教学，这和我们所推崇的MOOC还是有很大的差距的。<br><strong>结束语</strong><br>在本文中，我们并未介绍诸如网易公开课等比较知名的MOOC网站，只是对更倾向于IT的在线编程学习网站列举出来并进行介绍。其实在国内，说到自学编程资源，还是很多的，除了论坛博客，还有许多视频教学网站，比如专门提供Android开发教学的，也是Android开发者最喜欢的<strong><a href="http://www.android-study.net/" target="_blank" rel="external">Android开发学习网</a>、<a href="http://edu.eoe.cn/" target="_blank" rel="external">eoe在线课堂</a>、<a href="http://www.apkbus.com/heima/" target="_blank" rel="external">安卓巴士</a></strong>等，如果你有好的学习网站，不妨在这里和我们分享一下吧。<br>（文/唐小引 责编/张宁）<br><strong>本文为CSDN原创文章，未经允许不得转载，如需转载请联系market#csdn.net(#换成@)</strong></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之学习资源/">iOS应用开发之学习资源</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-17T07:51:00.000Z"><a href="/2014/02/17/Xcode的Architectures和Valid Architectures的区别/">2月 17 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/17/Xcode的Architectures和Valid Architectures的区别/">Xcode的Architectures和Valid Architectures的区别</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>作者：shede333<br><a href="http://my.oschina.net/shede333" target="_blank" rel="external">主页：http://my.oschina.net/shede333</a><br>版权声明：原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="external">Creative<br> Commons BY-NC-ND 3.0</a></p>
<h2 id="Xcode的Architectures和Valid_Architectures的区别">Xcode的Architectures和Valid Architectures的区别</h2>
<h3 id="Architectures">Architectures</h3>
<p>这代表，在这个项目里你想要Xcode编译的目标设备列表。</p>
<h3 id="Valid_Architectures">Valid Architectures</h3>
<p>还不是太明确这个设置的意图，但是一般来说是不需要更改的。<br>在Xcode5.0里的Valid Architectures 设置里，有2个选项：</p>
<ol>
<li>默认为<code>standard
architectures (including 64-bit)(armv7,armv7s,arm64)</code>，这样设置，你的Deployment target最低只能设置为 6.0,(在Xcode5.0.1 之后,最低能够兼容IOS 5.1.1);</li>
<li><code>standard
architectures (armv7,armv7s)</code>，这样设置，你的Deployment target最低能设置为 4.3；</li>
</ol>
<h2 id="原因解释如下：">原因解释如下：</h2>
<p>使用standard architectures (including 64-bit)(armv7,armv7s,arm64)参数，<br>则打的包里面有32位、64位两份代码，<br>在iPhone5s（<code>iPhone5s的cpu是64位的</code>）下，会首选运行64位代码包，<br>其余的iPhone（<code>其余iPhone都是32位的,iPhone5c也是32位</code>），<br>只能运行32位包，<br>但是包含两种架构的代码包，只有运行在ios6，ios7系统上。<br>这也就是说，这种打包方式，对手机几乎没啥要求，但是对系统有要求，即ios6以上。<br>而使用standard architectures (armv7,armv7s)参数，<br>则打的包里只有32位代码，<br>iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能，原因下面的参考有解释。<br>其余的iPhone对32位代码包更没问题，<br>而32位代码包，对系统也几乎也没什么限制。<br>所以总结如下：<br>要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。<br>如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。</p>
<h2 id="参考1：">参考1：</h2>
<p><a href="http://en.wikipedia.org/wiki/List_of_iOS_devices" target="_blank" rel="external">所有IOS设备详情列表<br> List of iOS devices - Wikipedia, the free encyclopedia</a></p>
<blockquote>
<p>armv6：iPhone 2G/3G，iPod 1G/2G<br>armv7：iPhone 3GS/4/4s，iPod 3G/4G，iPad 1G/2G/3G<br>armv7s：iPhone5</p>
<h2 id="参考2：">参考2：</h2>
<p><a href="http://blog.csdn.net/keyboardota/article/details/11993883" target="_blank" rel="external">iOS<br> 7: 如何为iPhone 5S编译64位应用。</a><br>Xcode 5编译的iOS 7程序包含了32位和64位两套二进制代码，在32位的iOS系统上会调用32位的二进制代码，在64位系统上会调用64位的二进制代码，以此来解决向后兼容的问题。<br>同时，考虑到很多32位的程序可能在没有重新编译的情况下部署到64位系统上，64位的iOS系统中带有两套FrameWork，一套是32位的，一套是64位的。<br>当64位的iOS系统运行原来的32位程序时，系统会调用32位的FrameWork作为底层支撑，当系统运行64位程序时，系统会调用64位的FrameWork作为底层支撑。<br>也就是说，当一个iPhone 5S上同时运行32位程序和64位程序时，系统同时将32位和64位两套FrameWork载入了内存中，所以消耗的内存也比较多。<br>如果一台64位的iOS设备上运行的所有程序都是为64位系统编译过的，iOS系统将只载入64位的FrameWork，这将节省好多内存。所以，如果大家都可以快速将程序传换成64位的，iOS将跑得更快。真的是“大家好才是真的好”。</p>
<h2 id="参考3：">参考3：</h2>
<ol>
<li><a href="http://stackoverflow.com/questions/12701188/whats-the-difference-between-architectures-and-valid-architectures-in-xcode" target="_blank" rel="external">What’s<br>the difference between “Architectures” and “Valid Architectures” in Xcode Build Settings?</a></li>
<li><a href="http://stackoverflow.com/questions/18913906/xcode-5-and-ios-7-architecture-and-valid-architectures" target="_blank" rel="external">Xcode<br>5 and iOS 7: Architecture and Valid architectures</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW51" target="_blank" rel="external">Xcode<br>Build Setting Reference (苹果官方文档)</a></li>
<li><a href="https://developer.apple.com/library/iOS/documentation/General/Conceptual/CocoaTouch64BitGuide/Introduction/Introduction.html" target="_blank" rel="external">64-Bit<br>transition Guide for Cocoa Touch (苹果官方文档)</a></li>
</ol>
</blockquote>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之Xcode配置/">iOS应用开发之Xcode配置</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/xcode/">xcode</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-14T02:27:00.000Z"><a href="/2014/02/14/cocos2d-iPhone官方文档(泰然网译)/">2月 14 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/14/cocos2d-iPhone官方文档(泰然网译)/">cocos2d-iPhone官方文档(泰然网译)</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><a href="http://www.ityran.com/archives/3818" target="_blank" rel="external">http://www.ityran.com/archives/3818</a></p>
<p>.</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS游戏开发之基础学习/">iOS游戏开发之基础学习</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/cocos2d/">cocos2d</a>, <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-13T01:36:00.000Z"><a href="/2014/02/13/Cocos2d 中对图片的各种操作/">2月 13 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/13/Cocos2d 中对图片的各种操作/">Cocos2d 中对图片的各种操作</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>关于精灵的各种操作，总结一下以便以后复习查找。<br>内容简要：<br>1、初始化 2、创建无图的精灵 3、设置精灵贴图大小  4、添加入层中<br>5、对精灵进行缩放  6、对精灵款或高进行缩放  7、旋转精灵<br>8、设置精灵透明度  9、精灵的镜像反转  10、设置精灵的颜色<br>11、得到图的宽高   12、按照像素设定图片大小  13、在原有的基础上加xy的坐标<br>14、设置图片锚点    15、从新排列z轴顺序   16、更换精灵贴图<br>17、设置可视区域 18、贴图无锯齿</p>
<p>原文地址：<a href="http://blog.csdn.net/dingkun520wy/article/details/6976558" target="_blank" rel="external">http://blog.csdn.net/dingkun520wy/article/details/6976558</a>  </p>
<hr>
<p>//初始化<br>CCSprite<em> sprite =[CCSprite spriteWithFile:@”Icon.png”];<br> //创建无图的精灵<br>CCSprite</em>sprite2 =[CCSprite node];<br>//设置精灵贴图大小<br>sprite2.textureRect=CGRectMake(0, 0, 20, 20);//设置其为宽20，高20.</p>
<p>//添加入层中</p>
<p>[self addChild:sprite z:2]; //将精灵加入层中设置其z轴为2<br>//对精灵进行缩放<br>sprite.scale=2;//放大2倍<br>//对精灵款或高进行缩放<br>sprite.scaleX = 2;//宽放大2倍<br>sprite.scaleY = 2;//高放大2倍<br>//旋转精灵<br>sprite.rotation=90;//旋转90度<br>//设置精灵透明度<br>sprite.opacity=255;//设置透明度为完全不透明（范围0～255）<br>//定义精灵位置<br>sprite.position=ccp(100,100);//设置精灵中心点坐标是x=100，y=100<br>//精灵的镜像反转<br>[sprite setFlipX:YES];//X轴镜像反转<br>[sprite setFlipY:YES];//Y轴镜像反转<br>//设置精灵的颜色<br>[sprite setColor:ccc3(255, 0, 0)];//设置颜色为红色<br>//得到图的宽高</p>
<p>float  contentSize  = sprite .contentSize.width //得到图片的宽高<br>//按照像素设定图片大小</p>
<p>sprite.scaleX=(20)/contentSize; //按照像素定制图片宽高<br>//在原有的基础上加xy的坐标<br>sprite.position = ccpAdd(sprite.position,ccp(20,20));//在原有坐标的基础上加减坐标<br>//设置图片锚点<br>[sprite setAnchorPoint:ccp(0.5,0.5) ];//设置图片的锚点<br>//从新排列z轴顺序<br>[self reorderChild:sprite z:1];//从新排列z轴顺序<br>//更换精灵贴图<br>CCTexture2D * test=[[CCTextureCache sharedTextureCache] addImage: @”test.png”];//新建贴图</p>
<p>[sprite setTexture:test];<br>//更换精灵贴图，加载帧缓存，这个test.plist保存了fram这张图<br>[[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@”test.plist”];<br>CCSpriteFrame* frame = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@”fram.png”];<br>[sprite2 setDisplayFrame:frame];</p>
<p>//设置可视区域<br>CCSprite * sprite3 =[CCSprite spriteWithFile:@”icon.png” rect:CGRectMake(0, 0, 20,20)];//创建时设置</p>
<p>[sprite3 setTextureRect:CGRectMake(10, 10, 30, 30)];//创建后设置<br>//贴图无锯齿<br>[sprite3 .texture setAliasTexParameters];</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS游戏开发之基础学习/">iOS游戏开发之基础学习</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/cocos2d/">cocos2d</a>, <a href="/tags/2d/">2d</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/ios开发/">ios开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-21T09:12:00.000Z"><a href="/2014/01/21/关于UIView 的autoresizingMask属性，即UIViewAutoresizing/">1月 21 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/21/关于UIView 的autoresizingMask属性，即UIViewAutoresizing/">关于UIView 的autoresizingMask属性，即UIViewAutoresizing</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><strong>作者：舍得333<br> 主页：</strong><a href="http://blog.sina.com.cn/u/1509658847" target="_blank" rel="external">http://blog.sina.com.cn/u/1509658847</a><br><strong>版权声明</strong>：原创作品，允许转载，转载时请务必以超链接形式标明文章原始出版、作者信息和本声明，否则将追究法律责任。</p>
<p>enum<br> {<br>   UIViewAutoresizingNone                 =<br> 0,<br>   UIViewAutoresizingFlexibleLeftMargin   =<br> 1 &lt;&lt; 0,<br>   UIViewAutoresizingFlexibleWidth        =<br> 1 &lt;&lt; 1,<br>   UIViewAutoresizingFlexibleRightMargin  =<br> 1 &lt;&lt; 2,<br>   UIViewAutoresizingFlexibleTopMargin    =<br> 1 &lt;&lt; 3,<br>   UIViewAutoresizingFlexibleHeight       =<br> 1 &lt;&lt; 4,<br>   UIViewAutoresizingFlexibleBottomMargin<br> = 1 &lt;&lt; 5<br>};<br>typedef NSUInteger UIViewAutoresizing;<br>这六个值与xib文件里面的图形显示怎么对应起来，这个说起来很坑爹的。<br>代码设置与xib图形设置很不一至。</p>
<p>根据UIView的API文档说明，autoresizingMask的默认值是UIViewAutoresizingNone<br>那么再xib文件里面对应的图形是：</p>
<p>即四周选中，中间2个没有选中。这个真是有点变态啊，我刚开始以为是全都不选呢。</p>
<p>再举个例子：<br>我想要view一直与左下角对齐，高度自由伸缩，xib设置如图：</p>
<p>那么代码应该怎么写呢？一定要注意看清每个单词哦！！！，如下：<br>subView.autoresizingMask =<br>    UIViewAutoresizingFlexibleTopMargin<br> |<br>    UIViewAutoresizingFlexibleRightMargin<br> |<br>    UIViewAutoresizingFlexibleHeight;</p>
<p>下面的文章参考自：<a href="http://www.cnblogs.com/kiao295338444/articles/2308903.html" target="_blank" rel="external">http://www.cnblogs.com/kiao295338444/articles/2308903.html</a><br>在 UIView 中有一个autoresizingMask的属性，它对应的是一个枚举的值（如下），属性的意思就是自动调整子控件与父控件中间的位置，宽高。<br>enum {<br>   UIViewAutoresizingNone                 = 0,<br>   UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,<br>   UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,<br>   UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,<br>   UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,<br>   UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,<br>   UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5<br>};<br>typedef NSUInteger UIViewAutoresizing;</p>
<p>分别解释以上意思。<br>UIViewAutoresizingNone就是不自动调整。<br>UIViewAutoresizingFlexibleLeftMargin就是自动调整与superView左边的距离，也就是说，与superView右边的距离不变。<br>UIViewAutoresizingFlexibleRightMargin就是自动调整与superView的右边距离，也就是说，与superView左边的距离不变。<br>UIViewAutoresizingFlexibleTopMargin</p>
<p>UIViewAutoresizingFlexibleBottomMargin<br>UIViewAutoresizingFlexibleWidth<br>UIViewAutoresizingFlexibleHeight<br>以上就不多解释了，参照上面的。<br>也可以多个枚举同时设置。如下：<br>subView.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin  |UIViewAutoresizingFlexibleRightMargin;<br>如果有多个，就用“|”关联。<br>还有一个属性就是autoresizesSubviews，此属性的意思就是，是否可以让其subviews自动进行调整，默认状态是YES，就是允许，如果设置成NO，那么subView的autoresizingMask属性失效。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之UI/">iOS应用开发之UI</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone/">iphone</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/uiview/">uiview</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-15T09:06:00.000Z"><a href="/2014/01/15/iOS 7, 导航栏和状态栏自定义/">1月 15 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/15/iOS 7, 导航栏和状态栏自定义/">iOS 7, 导航栏和状态栏自定义</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <h1 id="本文转自:http://beyondvincent-com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6">本文转自:<a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6" target="_blank" rel="external">http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6</a></h1>
<p><a href="http://beyondvincent.com/images/2013/11/7.png" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/7.png" alt=""></a><br>注：本文译自<a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/" target="_blank" rel="external"><code>Customizing
 Navigation Bar and Status Bar in iOS 7</code></a><br>近期，跟大多数开发者一样，我也正忙于对程序进行升级以适配iOS 7。最新的iOS 7外观上有大量的改动。从开发者的角度来看，导航栏和状态栏就发生了明显的变化。状态栏现在是半透明的了，这也就意味着导航栏会显示在状态栏后面。有些情况下，导航栏的背景图片可以延伸显示到状态栏后面。<br>之前我曾经写过一篇关于<a href="http://www.appcoda.com/customize-navigation-bar-back-butto/" target="_blank" rel="external">如何定制导航栏</a>的文章。不过现在是时候对其进行更新了。下面就是本文将要介绍的内容：</p>
<ul>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#0" target="_blank" rel="external">iOS 7中默认的导航栏</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#1" target="_blank" rel="external">设置导航栏的背景颜色</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#2" target="_blank" rel="external">在导航栏中使用背景图片</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#3" target="_blank" rel="external">定制返回按钮的颜色</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#4" target="_blank" rel="external">修改导航栏标题的字体</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#44" target="_blank" rel="external">修改导航栏标题为图片</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#5" target="_blank" rel="external">添加多个按钮</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6" target="_blank" rel="external">修改状态栏的风格</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#7" target="_blank" rel="external">隐藏状态栏</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#8" target="_blank" rel="external">总结</a></li>
</ul>
<p><a href="http://beyondvincent.com/images/2013/11/9.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/9.jpg" alt=""></a><br>本文提供的代码需要用Xcode 5来执行。如果你还在使用老版本的Xcode，那么在运行示例之前请将Xcode升级到Xcode 5。</p>
<h3 id="iOS_7中默认的导航栏"><a href=""></a>iOS 7中默认的导航栏</h3>
<p>在开始定制之前，我们先来看看iOS 7中默认导航栏的外观。通过Xcode用<code>Single
 View Controller</code>模板创建一个工程。然后将view controller嵌入到一个navigation controller中。如果你不想从头开始，那么也可以在这里下载到这个<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip" target="_blank" rel="external">示例工程</a>。<br>Xcode 5包含有iOS 6和iOS 7模拟器，我们可以在这两个不同的模拟器版本中运行示例程序，进行对比，如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/10.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/10.jpg" alt=""></a><br>如上图所示，在iOS 7中的导航栏默认情况下跟状态栏是交织在一起的，并且它的颜色也被修改为亮灰色。</p>
<h3 id="设置导航栏的背景颜色"><a href=""></a>设置导航栏的背景颜色</h3>
<p>在iOS 7中，不再使用tintColor属性来设置导航栏的颜色，而是使用barTintColor属性来修改背景色。我们可以在<code>AppDelegate.m</code>文件中的方法<code>didFinishLaunchingWithOptions:</code>里面添加如下代码来修改颜色：<br>    1</p>
<pre><code><span class="string">[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]]</span>;
</code></pre><p>效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/11.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/11.jpg" alt=""></a><br>一般情况，我们都会使用自己的颜色，下面这个宏用来设置RGB颜色非常方便：<br>    1</p>
<pre><code>#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((<span class="built_in">float</span>)((rgbValue &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span> green:((<span class="built_in">float</span>)((rgbValue &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>))/<span class="number">255.0</span> blue:((<span class="built_in">float</span>)(rgbValue &amp; <span class="number">0xFF</span>))/<span class="number">255.0</span> alpha:<span class="number">1.0</span>]
</code></pre><p>将上面这个宏放到<code>AppDelegate.m</code>文件中，然后通过这个宏来创建一个UIColor对象(根据指定的RGB)。如下示例：<br>    1</p>
<pre><code><span class="attr_selector">[[UINavigationBar appearance]</span> setBarTintColor<span class="value">:<span class="function">UIColorFromRGB</span>(<span class="number">0</span>x067AB5)];</span>
</code></pre><p>默认情况下，导航栏的translucent属性为YES。另外，系统还会对所有的导航栏做模糊处理，这样可以让iOS 7中导航栏的颜色更加饱和。如下图，是translucent值为NO和YES的对比效果：<br><a href="http://beyondvincent.com/images/2013/11/12.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/12.jpg" alt=""></a><br>要想禁用translucent属性，可以在Storyboard中选中导航栏，然后在Attribute Inspectors中，取消translucent的勾选。</p>
<h3 id="在导航栏中使用背景图片"><a href=""></a>在导航栏中使用背景图片</h3>
<p>如果希望在导航栏中使用一个图片当做背景，那么你需要提供一个稍微高一点的图片(这样可以延伸到导航栏背后)。导航栏的高度从44 points(88 pixels)变为了64 points(128 pixels)。<br>我们依然可以使用<code>setBackgroundImage:</code>方法为导航栏设置自定义图片。如下代码所示：<br>    1</p>
<pre><code>[[UINavigationBar appearance] <span class="keyword">set</span>BackgroundImage:[UIImage imageNamed:@<span class="string">"nav_bg.png"</span>] <span class="keyword">for</span>BarMetrics:UIBarMetricsDefault];
</code></pre><p>示例工程中提供了两个背景图片：nav_bg.png 和 nav_bg_ios7.png。运行一下试试看吧，如下效果：<br><a href="http://beyondvincent.com/images/2013/11/13.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/13.jpg" alt=""></a></p>
<h3 id="定制返回按钮的颜"><a href=""></a>定制返回按钮的颜</h3>
<p>在iOS 7中，所有的按钮都是无边框的。其中返回按钮会有一个V型箭头，以及上一个屏幕中的标题(如果上一屏幕的标题是空，那么就显示”返回”)。要想给返回按钮着色，可以使用tintColor属性。如下代码所示：<br>    1</p>
<pre><code><span class="string">[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]]</span>;
</code></pre><p>除了返回按钮，tintColor属性会影响到所有按钮标题和图片。<br><a href="http://beyondvincent.com/images/2013/11/14.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/14.jpg" alt=""></a><br>如果想要用自己的图片替换V型，可以设置图片的<code>backIndicatorImage</code>和<code>backIndicatorTransitionMaskImage</code>。如下代码所示：<br>    1<br>    2</p>
<pre><code><span class="string">[[UINavigationBarappearance]setBackIndicatorImage:[UIImageimageNamed:@"back_btn.png"]]</span>;<span class="string">[[UINavigationBarappearance]setBackIndicatorTransitionMaskImage:[UIImageimageNamed:@"back_btn.png"]]</span>;
</code></pre><p>图片的颜色是由tintColor属性控制的。<br><a href="http://beyondvincent.com/images/2013/11/15.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/15.jpg" alt=""></a></p>
<h3 id="修改导航栏标题的字体"><a href=""></a>修改导航栏标题的字体</h3>
<p>跟iOS 6一样，我们可以使用导航栏的<code>titleTextAttributes</code>属性来定制导航栏的文字风格。在text<br> attributes字典中使用如下一些key，可以指定字体、文字颜色、文字阴影色以及文字阴影偏移量：</p>
<ul>
<li>UITextAttributeFont – 字体key</li>
<li>UITextAttributeTextColor – 文字颜色key</li>
<li>UITextAttributeTextShadowColor – 文字阴影色key</li>
<li>UITextAttributeTextShadowOffset – 文字阴影偏移量key</li>
</ul>
<p>如下代码所示，对导航栏的标题风格做了修改：<br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7</p>
<pre><code>NSShadow*<span class="built_in">shadow</span>=[[NSShadowalloc]init];<span class="built_in">shadow</span>.shadowColor=[UIColorcolorWithRed:<span class="number">0.0</span>green:<span class="number">0.0</span>blue:<span class="number">0.0</span>alpha:<span class="number">0.8</span>];<span class="built_in">shadow</span>.shadowOffset=CGSizeMake(<span class="number">0</span>,<span class="number">1</span>);[[UINavigationBarappearance]setTitleTextAttributes:[NSDictionarydictionaryWithObjectsAndKeys:[UIColorcolorWithRed:<span class="number">245.0</span>/<span class="number">255.0</span>green:<span class="number">245.0</span>/<span class="number">255.0</span>blue:<span class="number">245.0</span>/<span class="number">255.0</span>alpha:<span class="number">1.0</span>],NSForegroundColorAttributeName,<span class="built_in">shadow</span>,NSShadowAttributeName,[UIFontfontWithName:@<span class="string">"HelveticaNeue-CondensedBlack"</span>size:<span class="number">21.0</span>],NSFontAttributeName,nil]];
</code></pre><p>运行效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/16.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/16.jpg" alt=""></a></p>
<h3 id="修改导航栏标题为图片"><a href=""></a>修改导航栏标题为图片</h3>
<p>如果要想将导航栏标题修改为一个图片或者logo，那么只需要使用下面这行代码即可：<br>    1</p>
<pre><code>self.navigationItem.titleView = <span class="string">[[UIImageView alloc] initWithImage:[UIImage imageNamed:@"appcoda-logo.png"]]</span>;
</code></pre><p>上面的代码简单的修改了titleView属性，将一个图片赋值给它。 注意：这不是iOS 7中的新功能，之前的iOS版本就可以已经有了。<br>具体效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/17.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/17.jpg" alt=""></a></p>
<h3 id="添加多个按钮"><a href=""></a>添加多个按钮</h3>
<p>同样，这个技巧也不是iOS 7的，开发者经常会在导航栏中添加多个按钮，所以我决定在这里进行介绍。我们可以在导航栏左边或者右边添加多个按钮。例如，我们希望在导航栏右边添加一个照相机和分享按钮，那只需要使用下面的代码即可：<br>    1<br>    2<br>    3<br>    4<br>    5</p>
<pre><code><span class="built_in">UIBarButtonItem</span>*shareItem=[[UIBarButtonItemalloc]initWithBarButtonSystemItem:UIBarButtonSystemItemActiontarget:selfaction:<span class="literal">nil</span>];<span class="built_in">UIBarButtonItem</span>*cameraItem=[[UIBarButtonItemalloc]initWithBarButtonSystemItem:UIBarButtonSystemItemCameratarget:selfaction:<span class="literal">nil</span>];<span class="built_in">NSArray</span>*actionButtonItems=@[shareItem,cameraItem];<span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.rightBarButtonItems</span>=actionButtonItems;
</code></pre><p>如下效果：<br><a href="http://beyondvincent.com/images/2013/11/18.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/18.jpg" alt=""></a></p>
<h3 id="修改状态栏的风格"><a href=""></a>修改状态栏的风格</h3>
<p>在老版本的iOS中，状态栏永远都是白色风格。而在iOS 7中，我们可以修改每个view controller中状态栏的外观。通过UIStatusBarStyle常量可以指定状态栏的内容是暗色或亮色。默认情况下，状态栏的显示是暗色。也就是说，状态栏上的时间、电池指示器和Wi-Fi信号显示为暗色。如果导航栏中使用暗色为背景，那么看起来的效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/19.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/19.jpg" alt=""></a><br>如上图这种情况下，我们可能希望将导航栏的风格修改为亮色。这里有两个方法可以实现。在iOS 7中，我们可以在每个view controller中overriding<code>preferredStatusBarStyle:</code>方法，如下所示：<br>    1<br>    2<br>    3<br>    4</p>
<pre><code>-(UIStatusBarStyle)preferredStatusBarStyle{<span class="keyword">return</span>UIStatusBarStyleLightContent;}
</code></pre><p>上面代码的效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/20.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/20.jpg" alt=""></a><br>在iOS 7中，通过上面的方法来修改状态栏风格非常的棒。另外，我们也可以使用UIApplication的statusBarStyle方法来设置状态栏，不过，首先需要停止使用<code>View
 controller-based status bar appearance</code>。在project target的Info tab中，插入一个新的key，名字为<code>View
 controller-based status bar appearance</code>，并将其值设置为NO。<br><a href="http://beyondvincent.com/images/2013/11/21.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/21.jpg" alt=""></a><br>然后就可以使用下面的代码来设置状态栏风格了：<br>    1</p>
<pre><code><span class="attr_selector">[[UIApplication sharedApplication]</span> <span class="tag">setStatusBarStyle</span><span class="pseudo">:UIStatusBarStyleLightContent</span>];
</code></pre><h3 id="隐藏状态栏"><a href=""></a>隐藏状态栏</h3>
<p>有时候我们需要隐藏状态栏，那么此时我们在view controller中override方法prefersStatusBarHidden:即可，如下代码所示：<br>    1<br>    2<br>    3<br>    4</p>
<pre><code>-(BOOL)prefersStatusBarHidden{<span class="keyword">return</span>YES;}
</code></pre><h3 id="总结"><a href=""></a>总结</h3>
<p>iOS 7给开发者提供了一些新的自由度来定制导航栏和状态栏的外观。希望上面的这些技巧能对你有用。<br>这里可以下载到<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip" target="_blank" rel="external">示例工程源码</a>。只需要取消相关代码注释即可进行测试。<br><a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之UI/">iOS应用开发之UI</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios/">ios</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios7适配/">ios7适配</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-08T05:09:00.000Z"><a href="/2014/01/08/IOS开发之Block 编程（翻译官方文档）/">1月 8 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/08/IOS开发之Block 编程（翻译官方文档）/">IOS开发之Block 编程（翻译官方文档）</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>本文转自：<a href="http://blog.csdn.net/perfect_promise/article/details/7757746" target="_blank" rel="external">http://blog.csdn.net/perfect_promise/article/details/7757746</a></p>
<p>注：小弟才疏学浅，英文水平够烂，若有不正确或误导的地方，请大家指出，欢迎大家指正和修改。本文中涉及的词法范围：作用范围，例如if{}else{}，两个{}分别是if和else的作用范围。#<a href=""></a>介绍<br>Block对象是一个C级别的语法和运行机制。它与标准的C函数类似，不同之处在于，它除了有可执行代码以外，它还包含了与堆、栈内存绑定的变量。因此，Block对象包含着一组状态数据，这些数据在程序执行时用于对行为产生影响。</p>
<p>你可以用Block来写一些可以传到API中的函数语句，可选择性地存储，并可以使用多线程。作为一个回调，Block特别的有用，因为block既包含了回调期间的代码，又包含了执行期间需要的数据。<br>作为Mac OS X v10.6 Xcode开发工具附带的工具，Block在GCC和Clang中同样可用。你能在Mac OS X v10.6 及其以上版本和iOS 4.0及其以上版本中使用Block。.Block的运行是开源的，因此你能在<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/" target="_blank" rel="external">LLVM’s<br> compiler-rt subproject repository</a>里面找到它。Block也已经被提交到C标准工作组作为 <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1370.pdf" target="_blank" rel="external">N1370:<br> Apple’s Extensions to C</a>。 由于Objective-C 和 C++ 都是衍生自 C，block被设计为可同时兼容这三种语言。<br>你应该阅读这篇文档，去学习Block是什么，以及在C、C++和OC中如何使用Block使你的程序更加的高效和更易于维护。</p>
<h2 id="声明和使用Block"><a href=""></a>声明和使用Block</h2>
<p>用^操作符来声明一个Block变量，并指明Block述句的开始。Block的主体部分包含在 <code>{}内，像下面的例子中一样（与C语法一样，“；”指明语句的结束）：</code><br>    int multiplier = 7;<br>    int (^myBlock)(int) = ^(int num) {<br>        return num <em> multiplier;<br>    };<br><img src="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Art/blocks.jpg" alt="image: ../Art/blocks.jpg">注意：Block可以使用定义范围之内的任何变量。<br>如果你把Block声明为一个变量，你以后就可以像调用一个方法一样使用它：<br>    int multiplier = 7;<br>    int (^myBlock)(int) = ^(int num) {<br>        return num </em> multiplier;<br>    };</p>
<pre><code><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>"</span>, myBlock(<span class="number">3</span>));
<span class="regexp">//</span> prints <span class="string">"21"</span>
</code></pre><h1 id="直接使用Block"><a href=""></a>直接使用Block</h1>
<p>很多情况下，你不需要声明Block变量；你只是简单地写一个Block语句内联在需要使用它作为参数的地方。下面的例子使用了 <code>qsort_b方法，</code>qsort_b方法与标准的qsort_r类似，只是用Block作为它的最后一个参数。``<br>    char *myCharacters[3] = { “TomJohn”, “George”, “Charles Condomine” };</p>
<pre><code>qsort_b(myCharacters, 3, sizeof(char <span class="keyword">*</span>), ^(const void <span class="keyword">*</span>l, const void <span class="keyword">*</span>r) {
    char <span class="keyword">*</span>left = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)l;
    char <span class="keyword">*</span>right = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)r;
    return strncmp(left, right, 1);
});

// myCharacters is now { <span class="string">"Charles Condomine"</span>, <span class="string">"George"</span>, <span class="string">"TomJohn"</span> }
</code></pre><h1 id="Cocoa_Block"><a href=""></a>Cocoa Block</h1>
<p>Cocoa框架中有几个方法使用Block作为参数，通常是在执行对象的操作集合，或者操作完成后使用它作为回调。下面的例子向我们展示了<br><code>在NSArray</code> 对象的方法<code>[sortedArrayUsingComparator:怎样使用Block](http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/NSArray.html#//apple_ref/occ/instm/NSArray/sortedArrayUsingComparator:)</code>.。这个方法只有单一的参数，block被定义为<code>[NSComparator](http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSComparator)</code> 局部变量：<br>    NSArray *stringsArray = [NSArray arrayWithObjects:<br>                                     @”string 1”,<br>                                     @”String 21”,<br>                                     @”string 12”,<br>                                     @”String 11”,<br>                                     @”String 02”, nil];</p>
<pre><code>static NSStringCompareOptions comparisonOptions = NSCaseInsensitiveSearch | NSNumericSearch |
        NSWidthInsensitiveSearch | NSForcedOrderingSearch;
NSLocale *currentLocale = [NSLocale currentLocale];

NSComparator finderSortBlock = ^(<span class="property">id</span> string1, <span class="property">id</span> string2) {

    NSRange string1Range = NSMakeRange(<span class="number">0</span>, [string1 <span class="property">length</span>]);
<span class="command">    return</span> [string1 compare:string2 options:comparisonOptions range:string1Range locale:currentLocale];
};

NSArray *finderSortArray = [stringsArray sortedArrayUsingComparator:finderSortBlock];
NSLog(@<span class="string">"finderSortArray: %@"</span>, finderSortArray);

/*
Output:
finderSortArray: (
    <span class="string">"string 1"</span>,
    <span class="string">"String 02"</span>,
    <span class="string">"String 11"</span>,
    <span class="string">"string 12"</span>,
    <span class="string">"String 21"</span>
)
*/
</code></pre><h2 id="_block变量"><a href=""></a>_block变量</h2>
<p>Block的一个强大的特性是，它能在相同的词法范围内修改变量值。Block能修改变量是通过_block存储类型标示符。与 <a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxGettingStarted.html#//apple_ref/doc/uid/TP40007502-CH7-SW4" target="_blank" rel="external">“Cocoa<br> Block”</a> 中的例子一样，你能使用一个block变量来计算有多少字符串与下面例子中是相同的。 Block直接被用，并且用 <code>currentLocale作为一个只读变量在block中。</code><br>    NSArray *stringsArray = [NSArray arrayWithObjects:<br>                             @”string 1”,<br>                             @”String 21”, // &lt;-<br>                             @”string 12”,<br>                             @”String 11”,<br>                             @”Strîng 21”, // &lt;-<br>                             @”Striñg 21”, // &lt;-<br>                             @”String 02”, nil];</p>
<pre><code>NSLocale *currentLocale = [NSLocale currentLocale];
__block NSUInteger orderedSameCount = <span class="number">0</span>;

NSArray *diacriticInsensitiveSortArray = [stringsArray sortedArrayUsingComparator:^(<span class="property">id</span> string1, <span class="property">id</span> string2) {

    NSRange string1Range = NSMakeRange(<span class="number">0</span>, [string1 <span class="property">length</span>]);
    NSComparisonResult comparisonResult = [string1 compare:string2 options:NSDiacriticInsensitiveSearch range:string1Range locale:currentLocale];

    <span class="keyword">if</span> (comparisonResult == NSOrderedSame) {
        orderedSameCount++;
    }
<span class="command">    return</span> comparisonResult;
}];

NSLog(@<span class="string">"diacriticInsensitiveSortArray: %@"</span>, diacriticInsensitiveSortArray);
NSLog(@<span class="string">"orderedSameCount: %d"</span>, orderedSameCount);

/*
Output:

diacriticInsensitiveSortArray: (
    <span class="string">"String 02"</span>,
    <span class="string">"string 1"</span>,
    <span class="string">"String 11"</span>,
    <span class="string">"string 12"</span>,
    <span class="string">"String 21"</span>,
    <span class="string">"Str\U00eeng 21"</span>,
    <span class="string">"Stri\U00f1g 21"</span>
)
orderedSameCount: <span class="number">2</span>
*/
</code></pre><p>更详细的内容请查看 <a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW1" target="_blank" rel="external">“Blocks<br> 和变量.”</a></p>
<h1 id="Block功能"><a href=""></a>Block功能</h1>
<p>Block是一个匿名的内嵌代码集：</p>
<ul>
<li><p>与方法一样，有一个类型参数列表</p>
</li>
<li><p>有一个隐形或声明的返回类型</p>
</li>
<li><p>能从它定义的词法范围内获取状态</p>
</li>
<li><p>能有选择性地修改词法范围中的状态</p>
</li>
<li><p>能共享相同词法范围内其他块定义的修改的潜在性</p>
</li>
<li><p>词法范围被销毁后仍能继续在已定义的词法范围内共享和修改状态</p>
</li>
</ul>
<p>你能复制一个block，并把它传递给其他线程来延迟执行（或者，在它自己的线程内，做一个运行环）。编译和运行过程中，从block中引用的所有变量都保留乐一份block的副本。block不仅适用于纯 C 和 C++，同时block也是一个Objective-C 对象。</p>
<h1 id="用法"><a href=""></a>用法</h1>
<p>Blocks通常表示比较小的，独立的代码段。因此，它特别适用于可能被同时执行的封装单元工作的模式，或者是集合中的项目，或者是当另一个操作完成后的一个回调。<br>Blocks之所以能替代传统的回调方法主要有以下两个理由：</p>
<ol>
<li><p>它允许你在调用点写代码，调用点稍后会在方法实现段被执行。<br>Blocks通常也是框架方法中的参数。</p>
</li>
<li><p>它允许访问局部变量。<br>与其使用回调，需要一个包含所有上下文信息的数据结构，你只需要执行一个操作，直接访问局部变量即可。</p>
</li>
</ol>
<h1 id="声明block参考"><a href=""></a>声明block参考</h1>
<p>Block变量持有Block引用。 声明它的语法与在函数中声明指针类似，用 <code>^代替</code> <code>*。</code> 其余部分，与C类型系统，具有完全的互操作性。以下时所有有效块的变量声明：<br>    void (^blockReturningVoidWithVoidArgument)(void);<br>    int (^blockReturningIntWithIntAndCharArguments)(int, char);<br>    void (^arrayOfTenBlocksReturningVoidWithIntArgument[10])(int);<br>Block支持可变参数 (<code>...</code>)参数。 不带任何参数的block，在参数列表中必须指定为void。Block的设计考虑到类型安全，通过提供给编译器全套的元数据来验证block的使用、传递参数到block中和返回值分配。一个块引用可以转换到任意类型的指针，反之亦然。但是，你不能通过*来获得block的值，因而在编译时，block的大小也不能被计算出来。<br>你可以创建一个block类型，当你在多个地方使用到同一个签名的block时，这种方式时很好的。<br>    typedef float (^MyBlockType)(float, float);</p>
<pre><code>MyBlockType myFirstBlock = // <span class="keyword">...</span> ;
MyBlockType mySecondBlock = // <span class="keyword">...</span> ;
</code></pre><h1 id="创建block"><a href=""></a>创建block</h1>
<p>用^指明block语句的开始。在它后面的（）是参数列表。block的主体部分在{ }里面.。下面的例子定义了一个简单的block，并把先前定义的变量（oneForm）分配给它。<br>    int (^oneFrom)(int);</p>
<pre><code>oneFrom = ^(<span class="keyword">int</span> anInt) {
    <span class="keyword">return</span> anInt - <span class="number">1</span>;
};
</code></pre><p>如果你不显式声明块表达式的返回值，它可以根据block的内容进行自动匹配。如果返回类型和参数列表都是void，你也可以省略参数列表。 如果存在多个返回语句，应该正确的进行匹配(又需要的话，可以使用类型转换)。</p>
<h1 id="全局block"><a href=""></a>全局block</h1>
<p>在文件级别，你可以使用block作为一个全局表达式。</p>
<pre><code><span class="preprocessor">#import &lt;stdio.h&gt;</span>

<span class="keyword">int</span> GlobalInt = <span class="number">0</span>;
<span class="keyword">int</span> (^getGlobalInt)(<span class="keyword">void</span>) = ^{ <span class="keyword">return</span> GlobalInt; };
</code></pre><h1 id="变量类型"><a href=""></a>变量类型</h1>
<p>block对象的代码中，变量被看成五种不同的方式。<br>与函数一样，block支持三种标准类型的变量：</p>
<ul>
<li><p>全局变量，带有static修饰符的变量</p>
</li>
<li><p>全局函数（不是专门的变量）</p>
</li>
<li><p>局部变量和参数</p>
</li>
</ul>
<p>Blocks也支持其他两种变量类型：</p>
<ol>
<li><p>函数级别的_block变量。如有引用块被复制到堆，block中的_block变量是可变的。</p>
</li>
<li><p><code>const</code></p>
</li>
</ol>
<p>最后，在一个方法的实现，块可能引用的Objective-C的实例变量—参考<a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW3" target="_blank" rel="external">“Object<br> and Block Variables.”</a><br>以下是在block中使用变量的规则：</p>
<ol>
<li><p>可以访问全局变量，包括词法范围内存在的static变量。</p>
</li>
<li><p>可以传参给block，与传参给函数的方式是一样的。</p>
</li>
<li><p>局部词法范围内的堆栈变量被看成时const变量。<br>他们的值存放在程序内的block语句中。 在嵌套block中，他们的值来自于最近的词法范围内。</p>
</li>
<li><p>声明为_block类型的<br>局部词法范围内的变量是可改变的。更改的适用范围仅为局部词法范围，包括词法范围内定义的其他block。 在<a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6" target="_blank" rel="external">“The<br>__block Storage Type.”</a>中有更详细的描述。</p>
</li>
<li>block作用范围内声明的局部变量，与函数中的局部变量一样。<br>block的每一次调用，都重新生成此变量的新的副本。这些变量可以被转换为const或引用变量在块内的作用域。</li>
</ol>
<p>下面的例子说明了局部非静态变量的使用：</p>
<pre><code><span class="keyword">int</span> <span class="keyword">x</span> = <span class="number">123</span>;

void (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> <span class="keyword">y</span>) {

    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> <span class="variable">%d</span>\n"</span>, <span class="keyword">x</span>, <span class="keyword">y</span>);
};

printXAndY(<span class="number">456</span>); <span class="regexp">//</span> prints: <span class="number">123</span> <span class="number">456</span>
</code></pre><p>如上所述，在block内试图分配一个新的x的值将会报错：<br>    int x = 123;</p>
<pre><code>void (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> <span class="keyword">y</span>) {

    <span class="keyword">x</span> = <span class="keyword">x</span> + <span class="keyword">y</span>; <span class="regexp">//</span> error
    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> <span class="variable">%d</span>\n"</span>, <span class="keyword">x</span>, <span class="keyword">y</span>);
};
</code></pre><p>为了使一个变量在block内部可以被修改，你应该使用_block来修饰这个变量—参考 <a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6" target="_blank" rel="external">“The<br> __block Storage Type.”</a></p>
<h1 id="_block存储类型"><a href=""></a>_block存储类型</h1>
<p>在变量前面加上_block类型修饰符，我们可以指定传进来的变量是可变或者可读写的。_block存储与它类似，但是局部变量的寄存器、auto变量和static存储类型之间相互排斥。<br><code>_block变量共享变量之间的作用域和块之间的作用域拷贝变量存储范围内。因此，如果block中定义的所有拷贝在框架内的生存超越帧结束（例如，正在排队等待执行），堆栈帧被破坏后存储也将继续存在</code>。在一个给定的词法范围的多个块，可以同时使用共享变量。<br>作为优化，在堆栈上的块存储块启动就像自身调用一样。如果块被复制，使用Block_copy（或在Objective-C中块发送一个副本），变量将被复制到堆。因此，_block块的地址可以随时更改。<br>_block变量有两个进一步的限制：他们不能是可变数组，不能包含C99的可变长数组的结构。<br>下面的例子说明了_block变量的作用：<br>    __block int x = 123; //  x lives in block storage</p>
<pre><code><span class="keyword">void</span> (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> y) {

    x = x + y;
    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);
};
printXAndY(<span class="number">456</span>); <span class="comment">// prints: 579 456</span>
<span class="comment">// x is now 579</span>
</code></pre><p>下面的例子显示了几种类型的变量块的相互作用：<br>    extern NSInteger CounterGlobal;<br>    static NSInteger CounterStatic;</p>
<pre><code>{
    <span class="built_in">NSInteger</span> localCounter = <span class="number">42</span>;
    __block <span class="keyword">char</span> localCharacter;

    <span class="keyword">void</span> (^aBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) {
        ++CounterGlobal;
        ++CounterStatic;
        CounterGlobal = localCounter; <span class="comment">// localCounter fixed at block creation</span>
        localCharacter = <span class="string">'a'</span>; <span class="comment">// sets localCharacter in enclosing scope</span>
    };

    ++localCounter; <span class="comment">// unseen by the block</span>
    localCharacter = <span class="string">'b'</span>;

    aBlock(); <span class="comment">// execute the block</span>
    <span class="comment">// localCharacter now 'a'</span>
}
</code></pre><h1 id="对象和block变量"><a href=""></a>对象和block变量</h1>
<p>Block提供支持的Objective-C和C+ +的对象，和其他块，作为变量。</p>
<h3 id="Objective-C_对象"><a href=""></a>Objective-C 对象</h3>
<p>在手动引用计数的环境， 复制块时，块内使用局部变量保留。Block内使用的局部变量引用技术将retain。如果您想覆盖一个特定对象变量的这种行为，你可以标记_block修饰符来修饰该变量。<br>如果您使用ARC，当block被copy时对象变量被保留，并自动释放，和延迟释放。<br><a href="&quot;Note&quot;"></a><strong>注：在垃圾收集的环境，如果你给变量同时使用_weak和_block修饰符，那么该block将无法确保是否还存在。</strong></p>
<p>如果你在执行方法内使用block，实例变量对象的内存管理规则更加微妙：</p>
<ul>
<li><p>如果您访问实例变量的参照，对象retain；</p>
</li>
<li><p>如果您访问实例变量的值，对象retain；</p>
</li>
</ul>
<p>下面的例子说明了两种不同的情况：<br>    dispatch_async(queue, ^{<br>        // instanceVariable is used by reference, self is retained<br>        doSomethingWithObject(instanceVariable);<br>    });</p>
<pre><code>id localVariable = instanceVariable;
dispatch_async(queue, ^{
    <span class="regexp">//</span> localVariable <span class="keyword">is</span> used <span class="keyword">by</span> value, localVariable <span class="keyword">is</span> retained (<span class="keyword">not</span> self)
    doSomethingWithObject(localVariable);
});
</code></pre><h1 id="调用block"><a href=""></a>调用block</h1>
<p>如果你声明block作为一个变量，你可以像使用函数一样使用它，就像下面两个示例所示一样：<br>    int (^oneFrom)(int) = ^(int anInt) {<br>        return anInt - 1;<br>    };</p>
<pre><code><span class="built_in">printf</span>(<span class="string">"1 from 10 is %d"</span>, oneFrom(<span class="number">10</span>));
<span class="comment">// Prints "1 from 10 is 9"</span>

<span class="keyword">float</span> (^distanceTraveled) (<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>) =
                          ^(<span class="keyword">float</span> startingSpeed, <span class="keyword">float</span> acceleration, <span class="keyword">float</span> time) {

    <span class="keyword">float</span> <span class="built_in">distance</span> = (startingSpeed * time) + (<span class="number">0.5</span> * acceleration * time * time);
    <span class="keyword">return</span> <span class="built_in">distance</span>;
};

<span class="keyword">float</span> howFar = distanceTraveled(<span class="number">0.0</span>, <span class="number">9.8</span>, <span class="number">1.0</span>);
<span class="comment">// howFar = 4.9</span>
</code></pre><p>然而，通常情况下，你使用block作为一个函数或方法的参数，在这些情况下，你通常创建一个块“内联”。</p>
<h1 id="使用block作为函数参数"><a href=""></a>使用block作为函数参数</h1>
<p>可以把block作为函数参数进行传递，就像其他参数一样。然后，很多时候你不需要声明block；而你只需把他们内联到需要使用block作为一个参数的地方。下面的例子使用了 <code>qsort_b方法，</code>qsort_b方法与标准的qsort_r类似，只是用Block作为它的最后一个参数。``<br>    char *myCharacters[3] = { “TomJohn”, “George”, “Charles Condomine” };</p>
<pre><code>qsort_b(myCharacters, 3, sizeof(char <span class="keyword">*</span>), ^(const void <span class="keyword">*</span>l, const void <span class="keyword">*</span>r) {
    char <span class="keyword">*</span>left = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)l;
    char <span class="keyword">*</span>right = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)r;
    return strncmp(left, right, 1);
});
// Block implementation ends at <span class="string">"}"</span>

// myCharacters is now { <span class="string">"Charles Condomine"</span>, <span class="string">"George"</span>, <span class="string">"TomJohn"</span> }
</code></pre><p>请注意，该块包含在函数的参数列表。<br>下面的示例显示如何使用block的dispatch_apply函数。 <code>dispatch_apply``使用以下方式进行定义：</code><br>    void dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));<br>功能是提交一个block到一个调度队列进行多次调用。它携带了三个参数；第一个参数指定执行的迭代的数量；第二个参数指定block被提交到哪个队列； 点歌参数就是block自身，反过来这需要一个参数迭代的当前索引。<br>可以使用<code>dispatch_apply</code> 分别打印出迭代索引，如下所示：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;dispatch/dispatch.h&gt;</span>
size_t count = <span class="number">10</span>;
dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);

dispatch_apply(count, <span class="built_in">queue</span>, ^(size_t i) {
    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, i);
});
</code></pre><h1 id="使用block作为方法参数"><a href=""></a>使用block作为方法参数</h1>
<p><a href="">Cocoa提供了一种方法，使用blocks。传递block作为参数与传递其他参数的方式是一样的。</a><br>下面的示例，确定一个数组前五个元素中任意一个在过滤集中的索引数。<br>    NSArray <em>array = [NSArray arrayWithObjects: @”A”, @”B”, @”C”, @”A”, @”B”, @”Z”,@”G”, @”are”, @”Q”, nil];<br>    NSSet </em>filterSet = [NSSet setWithObjects: @”A”, @”Z”, @”Q”, nil];</p>
<pre><code><span class="built_in">BOOL</span> (^test)(<span class="keyword">id</span> obj, NSUInteger idx, <span class="built_in">BOOL</span> *stop);

test = ^ (<span class="keyword">id</span> obj, NSUInteger idx, <span class="built_in">BOOL</span> *stop) {

    <span class="keyword">if</span> (idx &lt; <span class="number">5</span>) {
        <span class="keyword">if</span> ([filterSet containsObject: obj]) {
            <span class="keyword">return</span> <span class="literal">YES</span>;
        }
    }
    <span class="keyword">return</span> <span class="literal">NO</span>;
};

<span class="built_in">NSIndexSet</span> *indexes = [array indexesOfObjectsPassingTest:test];

<span class="built_in">NSLog</span>(<span class="string">@"indexes: %@"</span>, indexes);

<span class="comment">/*
Output:
indexes: &lt;NSIndexSet: 0x10236f0&gt;[number of indexes: 2 (in 2 ranges), indexes: (0 3)]
*/</span>
</code></pre><p>下方的例子是确定一个NSSet对象中是否包含有局部变量指定的一个单词，如果包含的话，设置另一个局部变量的值为YES。found也被声明为一个_block变量， 这个block是定义联：<br>    __block BOOL found = NO;<br>    NSSet <em>aSet = [NSSet setWithObjects: @”Alpha”, @”Beta”, @”Gamma”, @”X”, nil];<br>    NSString </em>string = @”gamma”;</p>
<pre><code>[aSet enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) {
    <span class="keyword">if</span> ([obj localizedCaseInsensitiveCompare:string] == NSOrderedSame) {
        *stop = <span class="literal">YES</span>;
        found = <span class="literal">YES</span>;
    }
}];

<span class="comment">// At this point, found == YES</span>
</code></pre><h1 id="复制block"><a href=""></a>复制block</h1>
<p>通常情况下，你不需要复制（或保留）一个块。如果你想要block在它的定义域被销毁后仍可以被使用，你仅仅只需要创建一个副本。复制移动block到堆中。.<br>你能用C函数来复制和释放block：<br>    Block_copy();<br>    Block_release();<br>如果你使用Objective-C，block的属性可以使用copy、retain、release和autorelease。<br>为了避免产生内存泄露，block的copy和retain的使用必须平衡。使用了copy和retain的地方必须进行release（autorelease除外）——除非在一个垃圾收集环境。</p>
<h1 id="避免的模式"><a href=""></a>避免的模式</h1>
<p>块文本（即，^{…}）是一个堆栈的本地数据结构的地址块。因此堆栈的本地数据结构的范围是封闭的复合语句，所以你应该避免使用下例中的模式：,<br>    void dontDoThis() {<br>        void (^blockArray[3])(void);  // an array of 3 block references</p>
<pre><code>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {
        blockArray[i] = ^{ printf(<span class="string">"hello, %d\n"</span>, i); };
        // <span class="type">WRONG</span>: <span class="type">The</span> <span class="keyword">block</span> literal scope <span class="keyword">is</span> the <span class="string">"for"</span> loop
    }
}

<span class="type">void</span> dontDoThisEither() {
    <span class="type">void</span> (^<span class="keyword">block</span>)(<span class="type">void</span>);

    <span class="type">int</span> i = random():
    <span class="keyword">if</span> (i &gt; <span class="number">1000</span>) {
        <span class="keyword">block</span> = ^{ printf(<span class="string">"got i at: %d\n"</span>, i); };
        // <span class="type">WRONG</span>: <span class="type">The</span> <span class="keyword">block</span> literal scope <span class="keyword">is</span> the <span class="string">"then"</span> clause
    }
    // ...
}
</code></pre><h1 id="调试"><a href=""></a>调试</h1>
<p>在block中你可以设置断点进行单步调试。你可以从调用块内GDB会议调用一个block，如下例所示：<br>    $ invoke-block myBlock 10 20<br>如果你想传一个C字符串值，你必须使用引用。例如， 把这个字符串传到<code>doSomethingWithString</code> block中，你可以像下面这样写：<br>    $ invoke-block doSomethingWithString “\”this string\””</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-08T02:29:00.000Z"><a href="/2014/01/08/IOS应用如何配置iTunes文件共享/">1月 8 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/08/IOS应用如何配置iTunes文件共享/">IOS应用如何配置iTunes文件共享</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>info.plist里设置UIFileSharingEnabled = YES;</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之Xcode配置/">iOS应用开发之Xcode配置</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/itunes/">itunes</a>, <a href="/tags/应用程序/">应用程序</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-07T07:36:00.000Z"><a href="/2014/01/07/基于XMPP的IOS聊天客户端程序(IOS端三)/">1月 7 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/07/基于XMPP的IOS聊天客户端程序(IOS端三)/">基于XMPP的IOS聊天客户端程序(IOS端三)</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><a href="http://blog.csdn.net/kangx6/article/details/7750765" target="_blank" rel="external"> 本文转自：http://blog.csdn.net/kangx6/article/details/7750765</a></p>
<p>前两篇介绍了如何通过XMPP来发送消息和接收消息，这一篇我们主要介绍如何来美化我们的聊天程序，看一下最终效果呢，当然源程序也会在最后放出<br><img src="http://my.csdn.net/uploads/201207/16/1342409417_2820.png" alt=""></p>
<p>好了，我们来看一下我们写的程序<br>这里我们自定义了TableViewCell<br><img src="http://my.csdn.net/uploads/201207/16/1342411906_4192.png" alt=""></p>
<p>一行是显示发布日期，一行是显示发送的消息，还有一个是背景</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. -(id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{  </p>
<ol>
<li></li>
<li>self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];  </li>
<li>if (self) {  </li>
<li>//日期标签  </li>
<li>senderAndTimeLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 5, 300, 20)];  </li>
<li>//居中显示  </li>
<li>senderAndTimeLabel.textAlignment = UITextAlignmentCenter;  </li>
<li>senderAndTimeLabel.font = [UIFont systemFontOfSize:11.0];  </li>
<li>//文字颜色  </li>
<li>senderAndTimeLabel.textColor = [UIColor lightGrayColor];  </li>
<li>[self.contentView addSubview:senderAndTimeLabel];  </li>
<li></li>
<li>//背景图  </li>
<li>bgImageView = [[UIImageView alloc] initWithFrame:CGRectZero];  </li>
<li>[self.contentView addSubview:bgImageView];  </li>
<li></li>
<li>//聊天信息  </li>
<li>messageContentView = [[UITextView alloc] init];  </li>
<li>messageContentView.backgroundColor = [UIColor clearColor];  </li>
<li>//不可编辑  </li>
<li>messageContentView.editable = NO;  </li>
<li>messageContentView.scrollEnabled = NO;  </li>
<li>[messageContentView sizeToFit];  </li>
<li>[self.contentView addSubview:messageContentView];  </li>
<li></li>
<li>}  </li>
<li></li>
<li>return self;  </li>
<li></li>
<li>}  </li>
</ol>
<p>定义好，在UITableViewCell中将Cell改成我们自己定义的Cell</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. -(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{  </p>
<ol>
<li></li>
<li>static NSString *identifier = @”msgCell”;  </li>
<li></li>
<li>KKMessageCell <em>cell =(KKMessageCell </em>)[tableView dequeueReusableCellWithIdentifier:identifier];  </li>
<li></li>
<li>if (cell == nil) {  </li>
<li>cell = [[KKMessageCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:identifier];  </li>
<li>}  </li>
<li></li>
<li>NSMutableDictionary *dict = [messages objectAtIndex:indexPath.row];  </li>
<li></li>
<li>//发送者  </li>
<li>NSString *sender = [dict objectForKey:@”sender”];  </li>
<li>//消息  </li>
<li>NSString *message = [dict objectForKey:@”msg”];  </li>
<li>//时间  </li>
<li>NSString *time = [dict objectForKey:@”time”];  </li>
<li></li>
<li>CGSize textSize = {260.0 ,10000.0};  </li>
<li>CGSize size = [message sizeWithFont:[UIFont boldSystemFontOfSize:13] constrainedToSize:textSize lineBreakMode:UILineBreakModeWordWrap];  </li>
<li></li>
<li>size.width +=(padding/2);  </li>
<li></li>
<li>cell.messageContentView.text = message;  </li>
<li>cell.accessoryType = UITableViewCellAccessoryNone;  </li>
<li>cell.userInteractionEnabled = NO;  </li>
<li></li>
<li>UIImage *bgImage = nil;  </li>
<li></li>
<li>//发送消息  </li>
<li>if ([sender isEqualToString:@”you”]) {  </li>
<li>//背景图  </li>
<li>bgImage = [[UIImage imageNamed:@”BlueBubble2.png”] stretchableImageWithLeftCapWidth:20 topCapHeight:15];  </li>
<li>[cell.messageContentView setFrame:CGRectMake(padding, padding*2, size.width, size.height)];  </li>
<li></li>
<li>[cell.bgImageView setFrame:CGRectMake(cell.messageContentView.frame.origin.x - padding/2, cell.messageContentView.frame.origin.y - padding/2, size.width + padding, size.height + padding)];  </li>
<li>}else {  </li>
<li></li>
<li>bgImage = [[UIImage imageNamed:@”GreenBubble2.png”] stretchableImageWithLeftCapWidth:14 topCapHeight:15];  </li>
<li></li>
<li>[cell.messageContentView setFrame:CGRectMake(320-size.width - padding, padding*2, size.width, size.height)];  </li>
<li>[cell.bgImageView setFrame:CGRectMake(cell.messageContentView.frame.origin.x - padding/2, cell.messageContentView.frame.origin.y - padding/2, size.width + padding, size.height + padding)];  </li>
<li>}  </li>
<li></li>
<li>cell.bgImageView.image = bgImage;  </li>
<li>cell.senderAndTimeLabel.text = [NSString stringWithFormat:@”%@ %@”, sender, time];  </li>
<li></li>
<li>return cell;  </li>
<li></li>
<li>}  </li>
</ol>
<p>在这个Cell里设置了发送的消息的背景图和接收消息的背景图<br>这里在字典里有一个”time”<br>这是我们接收和发送消息的时间</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. +(NSString *)getCurrentTime{  </p>
<ol>
<li></li>
<li>NSDate *nowUTC = [NSDate date];  </li>
<li></li>
<li>NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];  </li>
<li>[dateFormatter setTimeZone:[NSTimeZone localTimeZone]];  </li>
<li>[dateFormatter setDateStyle:NSDateFormatterMediumStyle];  </li>
<li>[dateFormatter setTimeStyle:NSDateFormatterMediumStyle];  </li>
<li></li>
<li>return [dateFormatter stringFromDate:nowUTC];  </li>
<li></li>
<li>}  </li>
</ol>
<p>在AppDelegate.m中<br>将我们收到消息的内容也做一下调整</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. - (void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message{  </p>
<ol>
<li></li>
<li>//   ……  </li>
<li></li>
<li>NSMutableDictionary *dict = [NSMutableDictionary dictionary];  </li>
<li>[dict setObject:msg forKey:@”msg”];  </li>
<li>[dict setObject:from forKey:@”sender”];  </li>
<li>//消息接收到的时间  </li>
<li>[dict setObject:[Statics getCurrentTime] forKey:@”time”];  </li>
<li></li>
<li>……  </li>
<li></li>
<li>}  </li>
</ol>
<p>最后我们再设置一下每一行显示的高度</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. //每一行的高度  </p>
<ol>
<li>-(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath{  </li>
<li></li>
<li>NSMutableDictionary *dict  = [messages objectAtIndex:indexPath.row];  </li>
<li>NSString *msg = [dict objectForKey:@”msg”];  </li>
<li></li>
<li>CGSize textSize = {260.0 , 10000.0};  </li>
<li>CGSize size = [msg sizeWithFont:[UIFont boldSystemFontOfSize:13] constrainedToSize:textSize lineBreakMode:UILineBreakModeWordWrap];  </li>
<li></li>
<li>size.height += padding*2;  </li>
<li></li>
<li>CGFloat height = size.height &lt; 65 ? 65 : size.height;  </li>
<li></li>
<li>return height;  </li>
<li></li>
<li>}  </li>
</ol>
<p>，对了，在发送消息的时候，别忘了也加上</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. - (IBAction)sendButton:(id)sender {  </p>
<ol>
<li></li>
<li>//本地输入框中的信息  </li>
<li>……  </li>
<li></li>
<li>if (message.length &gt; 0) {  </li>
<li></li>
<li>…..  </li>
<li></li>
<li>NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];  </li>
<li></li>
<li>[dictionary setObject:message forKey:@”msg”];  </li>
<li>[dictionary setObject:@”you” forKey:@”sender”];  </li>
<li>[dictionary setObject:[Statics getCurrentTime] forKey:@”time”];  </li>
<li></li>
<li>[messages addObject:dictionary];  </li>
<li></li>
<li>//重新刷新tableView  </li>
<li>[self.tView reloadData];  </li>
<li></li>
<li>}  </li>
<li></li>
<li></li>
<li>}  </li>
</ol>
<p>好了，这里关于XMPP发送消息的教程就结束了，以后我们会详细介绍其他关于XMPP的内容<br><a href="http://download.csdn.net/detail/kangkangz4/4431399" target="_blank" rel="external">源码下载</a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之社交软件/">iOS应用开发之社交软件</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/XMPP/">XMPP</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/聊天/">聊天</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
    <a href="/tags/ios/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  
    <form>
      <input id="st-search-input" type="search" placeholder="Search">
    </form>
    <div id="st-results-container"></div>
  
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <div class="entry">
    
      <span><a href="/tags/2d/">2d<small>1</small></a></span>
    
      <span><a href="/tags/AFNetworking/">AFNetworking<small>2</small></a></span>
    
      <span><a href="/tags/CoreData/">CoreData<small>2</small></a></span>
    
      <span><a href="/tags/Drawing/">Drawing<small>1</small></a></span>
    
      <span><a href="/tags/MagicalRecord/">MagicalRecord<small>1</small></a></span>
    
      <span><a href="/tags/NSDate/">NSDate<small>1</small></a></span>
    
      <span><a href="/tags/NSString/">NSString<small>1</small></a></span>
    
      <span><a href="/tags/Swift/">Swift<small>9</small></a></span>
    
      <span><a href="/tags/UIAlertView/">UIAlertView<small>1</small></a></span>
    
      <span><a href="/tags/UITabBarController/">UITabBarController<small>1</small></a></span>
    
      <span><a href="/tags/UITableViewControlle/">UITableViewControlle<small>1</small></a></span>
    
      <span><a href="/tags/UIWebView/">UIWebView<small>1</small></a></span>
    
      <span><a href="/tags/URL-Scheme/">URL Scheme<small>1</small></a></span>
    
      <span><a href="/tags/URL编码/">URL编码<small>1</small></a></span>
    
      <span><a href="/tags/XMPP/">XMPP<small>3</small></a></span>
    
      <span><a href="/tags/Xcode5-1/">Xcode5.1<small>1</small></a></span>
    
      <span><a href="/tags/api/">api<small>5</small></a></span>
    
      <span><a href="/tags/appStore审核/">appStore审核<small>1</small></a></span>
    
      <span><a href="/tags/block/">block<small>1</small></a></span>
    
      <span><a href="/tags/bytearray/">bytearray<small>1</small></a></span>
    
      <span><a href="/tags/cell自适应高度/">cell自适应高度<small>1</small></a></span>
    
      <span><a href="/tags/cocos2d/">cocos2d<small>3</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发font/">fontfontiPhone开发font<small>1</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发fontfont/">fontfontiPhone开发fontfont<small>1</small></a></span>
    
      <span><a href="/tags/fontfontios的fontfont/">fontfontios的fontfont<small>2</small></a></span>
    
      <span><a href="/tags/fontfont动画fontfont/">fontfont动画fontfont<small>1</small></a></span>
    
      <span><a href="/tags/framework/">framework<small>1</small></a></span>
    
      <span><a href="/tags/iOS8/">iOS8<small>2</small></a></span>
    
      <span><a href="/tags/iOS8-1-1/">iOS8.1.1<small>1</small></a></span>
    
      <span><a href="/tags/iOS8定位/">iOS8定位<small>1</small></a></span>
    
      <span><a href="/tags/iOS国际化/">iOS国际化<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之app上架/">iOS应用开发之app上架<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之第三方框架/">iOS应用开发之第三方框架<small>1</small></a></span>
    
      <span><a href="/tags/iOS开发/">iOS开发<small>5</small></a></span>
    
      <span><a href="/tags/iOS自定义Tabbar/">iOS自定义Tabbar<small>1</small></a></span>
    
      <span><a href="/tags/ios/">ios<small>53</small></a></span>
    
      <span><a href="/tags/ios7/">ios7<small>1</small></a></span>
    
      <span><a href="/tags/ios7适配/">ios7适配<small>1</small></a></span>
    
      <span><a href="/tags/ios国际化/">ios国际化<small>1</small></a></span>
    
      <span><a href="/tags/ios开发/">ios开发<small>27</small></a></span>
    
      <span><a href="/tags/iphone/">iphone<small>4</small></a></span>
    
      <span><a href="/tags/iphone开发/">iphone开发<small>59</small></a></span>
    
      <span><a href="/tags/itunes/">itunes<small>1</small></a></span>
    
      <span><a href="/tags/objective-c/">objective-c<small>1</small></a></span>
    
      <span><a href="/tags/svn/">svn<small>1</small></a></span>
    
      <span><a href="/tags/uiimage/">uiimage<small>2</small></a></span>
    
      <span><a href="/tags/uitableview/">uitableview<small>1</small></a></span>
    
      <span><a href="/tags/uitableviewcell/">uitableviewcell<small>1</small></a></span>
    
      <span><a href="/tags/uitextfield/">uitextfield<small>1</small></a></span>
    
      <span><a href="/tags/uiview/">uiview<small>3</small></a></span>
    
      <span><a href="/tags/uiviewcontroller/">uiviewcontroller<small>1</small></a></span>
    
      <span><a href="/tags/uiwebview/">uiwebview<small>1</small></a></span>
    
      <span><a href="/tags/xcode/">xcode<small>2</small></a></span>
    
      <span><a href="/tags/xmpp/">xmpp<small>1</small></a></span>
    
      <span><a href="/tags/二维码/">二维码<small>1</small></a></span>
    
      <span><a href="/tags/企业/">企业<small>1</small></a></span>
    
      <span><a href="/tags/动画/">动画<small>5</small></a></span>
    
      <span><a href="/tags/国际化/">国际化<small>1</small></a></span>
    
      <span><a href="/tags/在线工具/">在线工具<small>1</small></a></span>
    
      <span><a href="/tags/多线程/">多线程<small>1</small></a></span>
    
      <span><a href="/tags/存储/">存储<small>1</small></a></span>
    
      <span><a href="/tags/宏/">宏<small>1</small></a></span>
    
      <span><a href="/tags/导航/">导航<small>1</small></a></span>
    
      <span><a href="/tags/屏幕旋转/">屏幕旋转<small>2</small></a></span>
    
      <span><a href="/tags/应用程序/">应用程序<small>2</small></a></span>
    
      <span><a href="/tags/微信开放平台ios/">微信开放平台ios<small>1</small></a></span>
    
      <span><a href="/tags/打开AppStore/">打开AppStore<small>1</small></a></span>
    
      <span><a href="/tags/数据库/">数据库<small>1</small></a></span>
    
      <span><a href="/tags/缓存/">缓存<small>1</small></a></span>
    
      <span><a href="/tags/聊天/">聊天<small>1</small></a></span>
    
      <span><a href="/tags/苹果应用商店/">苹果应用商店<small>1</small></a></span>
    
      <span><a href="/tags/获取iP地址/">获取iP地址<small>1</small></a></span>
    
  </div>
</div>




  <script type="text/javascript">
    (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
    })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

    _st('install','6xH6jcZvsZxn2a9rcU4t');
  </script>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div id="foot-nav">
  <ul class="social">
    
      <li><a class="github" href="https://github.com/DaiXiang" title="github">github</a></li>
    
      <li><a class="rss" href="/atom.xml" title="rss">rss</a></li>
    
  </ul>
</div>
<div>
  
    &copy; 2014 尹现伟
  
</div>
<div class="clearfix"></div></footer>
  


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<script type="text/javascript">
  function navbar() {
    var top = $('#nav-top').innerHeight();
    $('#header').css('min-height', top);
  }
  navbar();
  $(window).resize(navbar);
</script>
<div id="totop" class="footer-btn">
  <a title="Return to Top"><img src="/img/scrollup.png"/></a>
</div>

<script type="text/javascript">
  $(function(){ 
	// When to show the scroll link
	// higher number = scroll link appears further down the page   
	var upperLimit = 800;
	
	// Our scroll link element
	var scrollElem = $('#totop');
   
	// Scroll to top speed
	var scrollSpeed = 500;
   
	// Show and hide the scroll to top link based on scroll position   
	scrollElem.hide();
	$(window).scroll(function () {            
		var scrollTop = $(document).scrollTop();       
		if ( scrollTop > upperLimit ) {
		  $(scrollElem).stop().fadeTo(300, 1); // fade back in
		  $(scrollElem).animate({bottom: "50px"}, { queue: false, duration: 10 });
		} else {
		  $(scrollElem).stop().fadeTo(300, 0); // fade out
	      $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
			
		}
	});

	// Scroll to top animation on click
	$(scrollElem).click(function(){
	  $('html, body').animate({scrollTop:0}, scrollSpeed);
	  $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
	  return false;
	});
  });
</script>
</body>
</html>