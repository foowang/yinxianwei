<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014/1 | 一枝红杏出墙来</title>
  <meta name="author" content="尹现伟">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="一枝红杏出墙来"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="shortcut icon">
  <link rel="alternate" href="/atom.xml" title="一枝红杏出墙来" type="application/atom+xml">
  <link rel="stylesheet" href="/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
  

</head>


<body>
  <header id="header" class="inner"><div id="nav-top">
  <div class="alignleft main-title">
    <h1>一枝红杏出墙来</h1>
    <h2></h2>
  </div>
  <nav id="main-nav" class="alignright">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2014/1</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-21T09:12:00.000Z"><a href="/2014/01/21/关于UIView 的autoresizingMask属性，即UIViewAutoresizing/">1月 21 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/21/关于UIView 的autoresizingMask属性，即UIViewAutoresizing/">关于UIView 的autoresizingMask属性，即UIViewAutoresizing</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><strong>作者：舍得333<br> 主页：</strong><a href="http://blog.sina.com.cn/u/1509658847" target="_blank" rel="external">http://blog.sina.com.cn/u/1509658847</a><br><strong>版权声明</strong>：原创作品，允许转载，转载时请务必以超链接形式标明文章原始出版、作者信息和本声明，否则将追究法律责任。</p>
<p>enum<br> {<br>   UIViewAutoresizingNone                 =<br> 0,<br>   UIViewAutoresizingFlexibleLeftMargin   =<br> 1 &lt;&lt; 0,<br>   UIViewAutoresizingFlexibleWidth        =<br> 1 &lt;&lt; 1,<br>   UIViewAutoresizingFlexibleRightMargin  =<br> 1 &lt;&lt; 2,<br>   UIViewAutoresizingFlexibleTopMargin    =<br> 1 &lt;&lt; 3,<br>   UIViewAutoresizingFlexibleHeight       =<br> 1 &lt;&lt; 4,<br>   UIViewAutoresizingFlexibleBottomMargin<br> = 1 &lt;&lt; 5<br>};<br>typedef NSUInteger UIViewAutoresizing;<br>这六个值与xib文件里面的图形显示怎么对应起来，这个说起来很坑爹的。<br>代码设置与xib图形设置很不一至。</p>
<p>根据UIView的API文档说明，autoresizingMask的默认值是UIViewAutoresizingNone<br>那么再xib文件里面对应的图形是：</p>
<p>即四周选中，中间2个没有选中。这个真是有点变态啊，我刚开始以为是全都不选呢。</p>
<p>再举个例子：<br>我想要view一直与左下角对齐，高度自由伸缩，xib设置如图：</p>
<p>那么代码应该怎么写呢？一定要注意看清每个单词哦！！！，如下：<br>subView.autoresizingMask =<br>    UIViewAutoresizingFlexibleTopMargin<br> |<br>    UIViewAutoresizingFlexibleRightMargin<br> |<br>    UIViewAutoresizingFlexibleHeight;</p>
<p>下面的文章参考自：<a href="http://www.cnblogs.com/kiao295338444/articles/2308903.html" target="_blank" rel="external">http://www.cnblogs.com/kiao295338444/articles/2308903.html</a><br>在 UIView 中有一个autoresizingMask的属性，它对应的是一个枚举的值（如下），属性的意思就是自动调整子控件与父控件中间的位置，宽高。<br>enum {<br>   UIViewAutoresizingNone                 = 0,<br>   UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,<br>   UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,<br>   UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,<br>   UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,<br>   UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,<br>   UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5<br>};<br>typedef NSUInteger UIViewAutoresizing;</p>
<p>分别解释以上意思。<br>UIViewAutoresizingNone就是不自动调整。<br>UIViewAutoresizingFlexibleLeftMargin就是自动调整与superView左边的距离，也就是说，与superView右边的距离不变。<br>UIViewAutoresizingFlexibleRightMargin就是自动调整与superView的右边距离，也就是说，与superView左边的距离不变。<br>UIViewAutoresizingFlexibleTopMargin</p>
<p>UIViewAutoresizingFlexibleBottomMargin<br>UIViewAutoresizingFlexibleWidth<br>UIViewAutoresizingFlexibleHeight<br>以上就不多解释了，参照上面的。<br>也可以多个枚举同时设置。如下：<br>subView.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin  |UIViewAutoresizingFlexibleRightMargin;<br>如果有多个，就用“|”关联。<br>还有一个属性就是autoresizesSubviews，此属性的意思就是，是否可以让其subviews自动进行调整，默认状态是YES，就是允许，如果设置成NO，那么subView的autoresizingMask属性失效。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之UI/">iOS应用开发之UI</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone/">iphone</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/uiview/">uiview</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-21T01:57:00.000Z"><a href="/2014/01/21/iOS屏幕旋转，屏幕自适应方向变化/">1月 21 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/21/iOS屏幕旋转，屏幕自适应方向变化/">iOS屏幕旋转，屏幕自适应方向变化</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>文章转自:<a href="http://moto0421.iteye.com/blog/1586791" target="_blank" rel="external">http://moto0421.iteye.com/blog/1586791</a></p>
<ol>
<li>iOS有四个方向的旋转，为了保证自己的代码能够支持旋转，我们必须首先处理一个函数：<br>Objective-c代码  <a href="&quot;收藏这段代码&quot;"><img src="http://moto0421.iteye.com/images/icon_star.png" alt="收藏代码"></a>1. - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation {  </li>
<li></li>
<li>return YES;  </li>
<li><p>}  </p>
<ol>
<li>这个函数时用来确定我们的应用所支持的旋转方向。如果想要支持每个方向则直接返回YES就行，还可以单独判断某一方向：</li>
</ol>
</li>
</ol>
<p>Objective-c代码  <a href="&quot;收藏这段代码&quot;"><img src="http://moto0421.iteye.com/images/icon_star.png" alt="收藏代码"></a>1. - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation {  </p>
<ol>
<li></li>
<li>if (interfaceOrientation==UIInterfaceOrientationLandscapeLeft) {  </li>
<li></li>
<li>//left  </li>
<li></li>
<li>}  </li>
<li></li>
<li>if (interfaceOrientation==UIInterfaceOrientationLandscapeRight) {  </li>
<li></li>
<li>//right  </li>
<li></li>
<li>}  </li>
<li></li>
<li>if (interfaceOrientation==UIInterfaceOrientationPortrait) {  </li>
<li></li>
<li>//up  </li>
<li></li>
<li>}  </li>
<li></li>
<li>if (interfaceOrientation==UIInterfaceOrientationPortraitUpsideDown) {  </li>
<li></li>
<li>//down  </li>
<li></li>
<li>}  </li>
<li></li>
<li>return YES;  </li>
<li>}  </li>
</ol>
<p>3.IOS6之后又不太一样</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(NSUInteger)supportedInterfaceOrientations{</div><div class="line">    <span class="keyword">return</span> UIInterfaceOrientationMaskAllButUpsideDown ;</div><div class="line">	<span class="comment">//支持旋转的方向</span></div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)shouldAutorotate{ <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">	<span class="comment">//是否旋转</span></div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">UIInterfaceOrientationMaskPortrait = (<span class="number">1</span> &lt;&lt; UIInterfaceOrientationPortrait),</div><div class="line">   UIInterfaceOrientationMaskLandscapeLeft = (<span class="number">1</span> &lt;&lt; UIInterfaceOrientationLandscapeLeft),</div><div class="line">   UIInterfaceOrientationMaskLandscapeRight = (<span class="number">1</span> &lt;&lt; UIInterfaceOrientationLandscapeRight),</div><div class="line">   UIInterfaceOrientationMaskPortraitUpsideDown = (<span class="number">1</span> &lt;&lt; UIInterfaceOrientationPortraitUpsideDown),</div><div class="line">   UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),</div><div class="line">   UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown),</div><div class="line">   UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),</div></pre></td></tr></table></figure>



<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

<ol>
<li>当然旋转还有一些函数可触发：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//旋转方向发生改变时  </span></div><div class="line">  </div><div class="line">-(<span class="keyword">void</span>)willAnimateRotationToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration {  </div><div class="line">}  </div><div class="line"><span class="comment">//视图旋转动画前一半发生之前自动调用  </span></div><div class="line">  </div><div class="line">-(<span class="keyword">void</span>)willAnimateFirstHalfOfRotationToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration {  </div><div class="line">}  </div><div class="line"><span class="comment">//视图旋转动画后一半发生之前自动调用  </span></div><div class="line">  </div><div class="line">-(<span class="keyword">void</span>)willAnimateSecondHalfOfRotationFromInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)fromInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration {  </div><div class="line">}  </div><div class="line"><span class="comment">//视图旋转之前自动调用  </span></div><div class="line">  </div><div class="line">-(<span class="keyword">void</span>)willRotateToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration {  </div><div class="line">}  </div><div class="line"><span class="comment">//视图旋转完成之后自动调用  </span></div><div class="line">  </div><div class="line">-(<span class="keyword">void</span>)didRotateFromInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)fromInterfaceOrientation {  </div><div class="line">}  </div><div class="line"><span class="comment">//视图旋转动画前一半发生之后自动调用  </span></div><div class="line">  </div><div class="line">-(<span class="keyword">void</span>)didAnimateFirstHalfOfRotationToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation {  </div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之UI/">iOS应用开发之UI</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/屏幕旋转/">屏幕旋转</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-15T09:06:00.000Z"><a href="/2014/01/15/iOS 7, 导航栏和状态栏自定义/">1月 15 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/15/iOS 7, 导航栏和状态栏自定义/">iOS 7, 导航栏和状态栏自定义</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <h1 id="本文转自:http://beyondvincent-com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6">本文转自:<a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6" target="_blank" rel="external">http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6</a></h1>
<p><a href="http://beyondvincent.com/images/2013/11/7.png" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/7.png" alt=""></a><br>注：本文译自<a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/" target="_blank" rel="external"><code>Customizing
 Navigation Bar and Status Bar in iOS 7</code></a><br>近期，跟大多数开发者一样，我也正忙于对程序进行升级以适配iOS 7。最新的iOS 7外观上有大量的改动。从开发者的角度来看，导航栏和状态栏就发生了明显的变化。状态栏现在是半透明的了，这也就意味着导航栏会显示在状态栏后面。有些情况下，导航栏的背景图片可以延伸显示到状态栏后面。<br>之前我曾经写过一篇关于<a href="http://www.appcoda.com/customize-navigation-bar-back-butto/" target="_blank" rel="external">如何定制导航栏</a>的文章。不过现在是时候对其进行更新了。下面就是本文将要介绍的内容：</p>
<ul>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#0" target="_blank" rel="external">iOS 7中默认的导航栏</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#1" target="_blank" rel="external">设置导航栏的背景颜色</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#2" target="_blank" rel="external">在导航栏中使用背景图片</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#3" target="_blank" rel="external">定制返回按钮的颜色</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#4" target="_blank" rel="external">修改导航栏标题的字体</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#44" target="_blank" rel="external">修改导航栏标题为图片</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#5" target="_blank" rel="external">添加多个按钮</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#6" target="_blank" rel="external">修改状态栏的风格</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#7" target="_blank" rel="external">隐藏状态栏</a></li>
<li><a href="http://beyondvincent.com/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/#8" target="_blank" rel="external">总结</a></li>
</ul>
<p><a href="http://beyondvincent.com/images/2013/11/9.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/9.jpg" alt=""></a><br>本文提供的代码需要用Xcode 5来执行。如果你还在使用老版本的Xcode，那么在运行示例之前请将Xcode升级到Xcode 5。</p>
<h3 id="iOS_7中默认的导航栏"><a href=""></a>iOS 7中默认的导航栏</h3>
<p>在开始定制之前，我们先来看看iOS 7中默认导航栏的外观。通过Xcode用<code>Single
 View Controller</code>模板创建一个工程。然后将view controller嵌入到一个navigation controller中。如果你不想从头开始，那么也可以在这里下载到这个<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip" target="_blank" rel="external">示例工程</a>。<br>Xcode 5包含有iOS 6和iOS 7模拟器，我们可以在这两个不同的模拟器版本中运行示例程序，进行对比，如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/10.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/10.jpg" alt=""></a><br>如上图所示，在iOS 7中的导航栏默认情况下跟状态栏是交织在一起的，并且它的颜色也被修改为亮灰色。</p>
<h3 id="设置导航栏的背景颜色"><a href=""></a>设置导航栏的背景颜色</h3>
<p>在iOS 7中，不再使用tintColor属性来设置导航栏的颜色，而是使用barTintColor属性来修改背景色。我们可以在<code>AppDelegate.m</code>文件中的方法<code>didFinishLaunchingWithOptions:</code>里面添加如下代码来修改颜色：<br>    1</p>
<pre><code><span class="string">[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]]</span>;
</code></pre><p>效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/11.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/11.jpg" alt=""></a><br>一般情况，我们都会使用自己的颜色，下面这个宏用来设置RGB颜色非常方便：<br>    1</p>
<pre><code>#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((<span class="built_in">float</span>)((rgbValue &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>))/<span class="number">255.0</span> green:((<span class="built_in">float</span>)((rgbValue &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>))/<span class="number">255.0</span> blue:((<span class="built_in">float</span>)(rgbValue &amp; <span class="number">0xFF</span>))/<span class="number">255.0</span> alpha:<span class="number">1.0</span>]
</code></pre><p>将上面这个宏放到<code>AppDelegate.m</code>文件中，然后通过这个宏来创建一个UIColor对象(根据指定的RGB)。如下示例：<br>    1</p>
<pre><code><span class="attr_selector">[[UINavigationBar appearance]</span> setBarTintColor<span class="value">:<span class="function">UIColorFromRGB</span>(<span class="number">0</span>x067AB5)];</span>
</code></pre><p>默认情况下，导航栏的translucent属性为YES。另外，系统还会对所有的导航栏做模糊处理，这样可以让iOS 7中导航栏的颜色更加饱和。如下图，是translucent值为NO和YES的对比效果：<br><a href="http://beyondvincent.com/images/2013/11/12.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/12.jpg" alt=""></a><br>要想禁用translucent属性，可以在Storyboard中选中导航栏，然后在Attribute Inspectors中，取消translucent的勾选。</p>
<h3 id="在导航栏中使用背景图片"><a href=""></a>在导航栏中使用背景图片</h3>
<p>如果希望在导航栏中使用一个图片当做背景，那么你需要提供一个稍微高一点的图片(这样可以延伸到导航栏背后)。导航栏的高度从44 points(88 pixels)变为了64 points(128 pixels)。<br>我们依然可以使用<code>setBackgroundImage:</code>方法为导航栏设置自定义图片。如下代码所示：<br>    1</p>
<pre><code>[[UINavigationBar appearance] <span class="keyword">set</span>BackgroundImage:[UIImage imageNamed:@<span class="string">"nav_bg.png"</span>] <span class="keyword">for</span>BarMetrics:UIBarMetricsDefault];
</code></pre><p>示例工程中提供了两个背景图片：nav_bg.png 和 nav_bg_ios7.png。运行一下试试看吧，如下效果：<br><a href="http://beyondvincent.com/images/2013/11/13.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/13.jpg" alt=""></a></p>
<h3 id="定制返回按钮的颜"><a href=""></a>定制返回按钮的颜</h3>
<p>在iOS 7中，所有的按钮都是无边框的。其中返回按钮会有一个V型箭头，以及上一个屏幕中的标题(如果上一屏幕的标题是空，那么就显示”返回”)。要想给返回按钮着色，可以使用tintColor属性。如下代码所示：<br>    1</p>
<pre><code><span class="string">[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]]</span>;
</code></pre><p>除了返回按钮，tintColor属性会影响到所有按钮标题和图片。<br><a href="http://beyondvincent.com/images/2013/11/14.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/14.jpg" alt=""></a><br>如果想要用自己的图片替换V型，可以设置图片的<code>backIndicatorImage</code>和<code>backIndicatorTransitionMaskImage</code>。如下代码所示：<br>    1<br>    2</p>
<pre><code><span class="string">[[UINavigationBarappearance]setBackIndicatorImage:[UIImageimageNamed:@"back_btn.png"]]</span>;<span class="string">[[UINavigationBarappearance]setBackIndicatorTransitionMaskImage:[UIImageimageNamed:@"back_btn.png"]]</span>;
</code></pre><p>图片的颜色是由tintColor属性控制的。<br><a href="http://beyondvincent.com/images/2013/11/15.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/15.jpg" alt=""></a></p>
<h3 id="修改导航栏标题的字体"><a href=""></a>修改导航栏标题的字体</h3>
<p>跟iOS 6一样，我们可以使用导航栏的<code>titleTextAttributes</code>属性来定制导航栏的文字风格。在text<br> attributes字典中使用如下一些key，可以指定字体、文字颜色、文字阴影色以及文字阴影偏移量：</p>
<ul>
<li>UITextAttributeFont – 字体key</li>
<li>UITextAttributeTextColor – 文字颜色key</li>
<li>UITextAttributeTextShadowColor – 文字阴影色key</li>
<li>UITextAttributeTextShadowOffset – 文字阴影偏移量key</li>
</ul>
<p>如下代码所示，对导航栏的标题风格做了修改：<br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7</p>
<pre><code>NSShadow*<span class="built_in">shadow</span>=[[NSShadowalloc]init];<span class="built_in">shadow</span>.shadowColor=[UIColorcolorWithRed:<span class="number">0.0</span>green:<span class="number">0.0</span>blue:<span class="number">0.0</span>alpha:<span class="number">0.8</span>];<span class="built_in">shadow</span>.shadowOffset=CGSizeMake(<span class="number">0</span>,<span class="number">1</span>);[[UINavigationBarappearance]setTitleTextAttributes:[NSDictionarydictionaryWithObjectsAndKeys:[UIColorcolorWithRed:<span class="number">245.0</span>/<span class="number">255.0</span>green:<span class="number">245.0</span>/<span class="number">255.0</span>blue:<span class="number">245.0</span>/<span class="number">255.0</span>alpha:<span class="number">1.0</span>],NSForegroundColorAttributeName,<span class="built_in">shadow</span>,NSShadowAttributeName,[UIFontfontWithName:@<span class="string">"HelveticaNeue-CondensedBlack"</span>size:<span class="number">21.0</span>],NSFontAttributeName,nil]];
</code></pre><p>运行效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/16.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/16.jpg" alt=""></a></p>
<h3 id="修改导航栏标题为图片"><a href=""></a>修改导航栏标题为图片</h3>
<p>如果要想将导航栏标题修改为一个图片或者logo，那么只需要使用下面这行代码即可：<br>    1</p>
<pre><code>self.navigationItem.titleView = <span class="string">[[UIImageView alloc] initWithImage:[UIImage imageNamed:@"appcoda-logo.png"]]</span>;
</code></pre><p>上面的代码简单的修改了titleView属性，将一个图片赋值给它。 注意：这不是iOS 7中的新功能，之前的iOS版本就可以已经有了。<br>具体效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/17.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/17.jpg" alt=""></a></p>
<h3 id="添加多个按钮"><a href=""></a>添加多个按钮</h3>
<p>同样，这个技巧也不是iOS 7的，开发者经常会在导航栏中添加多个按钮，所以我决定在这里进行介绍。我们可以在导航栏左边或者右边添加多个按钮。例如，我们希望在导航栏右边添加一个照相机和分享按钮，那只需要使用下面的代码即可：<br>    1<br>    2<br>    3<br>    4<br>    5</p>
<pre><code><span class="built_in">UIBarButtonItem</span>*shareItem=[[UIBarButtonItemalloc]initWithBarButtonSystemItem:UIBarButtonSystemItemActiontarget:selfaction:<span class="literal">nil</span>];<span class="built_in">UIBarButtonItem</span>*cameraItem=[[UIBarButtonItemalloc]initWithBarButtonSystemItem:UIBarButtonSystemItemCameratarget:selfaction:<span class="literal">nil</span>];<span class="built_in">NSArray</span>*actionButtonItems=@[shareItem,cameraItem];<span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.rightBarButtonItems</span>=actionButtonItems;
</code></pre><p>如下效果：<br><a href="http://beyondvincent.com/images/2013/11/18.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/18.jpg" alt=""></a></p>
<h3 id="修改状态栏的风格"><a href=""></a>修改状态栏的风格</h3>
<p>在老版本的iOS中，状态栏永远都是白色风格。而在iOS 7中，我们可以修改每个view controller中状态栏的外观。通过UIStatusBarStyle常量可以指定状态栏的内容是暗色或亮色。默认情况下，状态栏的显示是暗色。也就是说，状态栏上的时间、电池指示器和Wi-Fi信号显示为暗色。如果导航栏中使用暗色为背景，那么看起来的效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/19.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/19.jpg" alt=""></a><br>如上图这种情况下，我们可能希望将导航栏的风格修改为亮色。这里有两个方法可以实现。在iOS 7中，我们可以在每个view controller中overriding<code>preferredStatusBarStyle:</code>方法，如下所示：<br>    1<br>    2<br>    3<br>    4</p>
<pre><code>-(UIStatusBarStyle)preferredStatusBarStyle{<span class="keyword">return</span>UIStatusBarStyleLightContent;}
</code></pre><p>上面代码的效果如下图所示：<br><a href="http://beyondvincent.com/images/2013/11/20.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/20.jpg" alt=""></a><br>在iOS 7中，通过上面的方法来修改状态栏风格非常的棒。另外，我们也可以使用UIApplication的statusBarStyle方法来设置状态栏，不过，首先需要停止使用<code>View
 controller-based status bar appearance</code>。在project target的Info tab中，插入一个新的key，名字为<code>View
 controller-based status bar appearance</code>，并将其值设置为NO。<br><a href="http://beyondvincent.com/images/2013/11/21.jpg" target="_blank" rel="external"><img src="http://beyondvincent.com/images/2013/11/21.jpg" alt=""></a><br>然后就可以使用下面的代码来设置状态栏风格了：<br>    1</p>
<pre><code><span class="attr_selector">[[UIApplication sharedApplication]</span> <span class="tag">setStatusBarStyle</span><span class="pseudo">:UIStatusBarStyleLightContent</span>];
</code></pre><h3 id="隐藏状态栏"><a href=""></a>隐藏状态栏</h3>
<p>有时候我们需要隐藏状态栏，那么此时我们在view controller中override方法prefersStatusBarHidden:即可，如下代码所示：<br>    1<br>    2<br>    3<br>    4</p>
<pre><code>-(BOOL)prefersStatusBarHidden{<span class="keyword">return</span>YES;}
</code></pre><h3 id="总结"><a href=""></a>总结</h3>
<p>iOS 7给开发者提供了一些新的自由度来定制导航栏和状态栏的外观。希望上面的这些技巧能对你有用。<br>这里可以下载到<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip" target="_blank" rel="external">示例工程源码</a>。只需要取消相关代码注释即可进行测试。<br><a href="&quot;分享到新浪微博&quot;"></a><a href="&quot;分享到腾讯微博&quot;"></a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之UI/">iOS应用开发之UI</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios/">ios</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios7适配/">ios7适配</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-08T11:15:00.000Z"><a href="/2014/01/08/铁道部12306官网如何体现了互联网思维？/">1月 8 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/08/铁道部12306官网如何体现了互联网思维？/">铁道部12306官网如何体现了互联网思维？</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>本文转自:<a href="http://www.yixieshi.com/it/15563.html" target="_blank" rel="external">互联网的一些事</a><br><img src="http://www.yixieshi.com/uploads/allimg/140108/1-14010Q02412O4.jpg" alt="铁道部12306官网如何体现了互联网思维？,互联网的一些事">　　年关将近，12306果断成为被上与被骂的最多网站。可是你们知道12306有多努力吗?<br>　　攥着在网吧刷了三小时才抢到的无座票，你终于可以登上回家的火车了。被挤悬空的你也许没空思考，这张小小的票根上凝聚了多少比特智慧和科技情怀。<br>　　现在连卖煎饼果子的、卖牛腩的、卖山寨手机的、卖避孕套的，都恨不能说自己是互联网思维的化身，可是咋整委员会要告诉你，12306才是真正运用互联网思维的天才之作!!!<br>　　<strong>1、用户思维：得屌丝者得天下</strong><br>　　“得屌丝者得天下”已是互联网圈内人所皆知的真理。12306不惜花费数亿，为众多坐不起灰机的屌丝们开发了该网站，找到了屌丝用户的硬需求，狠击痛点，抓住了互联网的“长尾”。<br><img src="http://mmbiz.qpic.cn/mmbiz/884XsHGHibP5bianFoD137OSCiaUhMGoW2LQsmsIwjb4ANZCcKnia3tPrpd52zu7bebOw1esQc6R3novNm3QySuZfw/0" alt="铁道部12306官网如何体现了互联网思维？,互联网的一些事">　　<strong>2、极致思维：丑的极致是美</strong><br>　　极致思维，是把产品、服务和用户体验做到超越用户的预期。12306的页面设计做到了极简。复古的配色，不羁的线条，甚至一直缓冲的小logo，都大大出乎目前互联网用户的理解水准。所以，看不懂就是你格调的问题了。<br><img src="http://mmbiz.qpic.cn/mmbiz/884XsHGHibP5bianFoD137OSCiaUhMGoW2LNiamFsjYHF7MraxY7umIgiacwlphjY9tgXHePOwagSkyHhnOjQibibcHvg/0" alt="铁道部12306官网如何体现了互联网思维？,互联网的一些事">　　<strong>3、让用户参与其中：排排队，散散心</strong><br>　　好的用户体验应该从细节入手，让用户在使用过程中有所思考、有所感动是12306网站设计的初衷，在特别安排的排队环节中便可见一斑。<br>　　浮躁的社会，快节奏的生活，人们似乎忘记了内心安宁是什么状态了。而在排队等票的过程中，用户们可以安静地喝杯茶、看部电影、思考自己所理解的生活。据统计，每一位购票者在抢购春节车票期间，平均获得30分钟以上的宁静时间。<br><img src="http://mmbiz.qpic.cn/mmbiz/884XsHGHibP5bianFoD137OSCiaUhMGoW2L8zsR2eSH5w75ZhzrR6PbhZ4viboBNbhUC77RMHOic9RR78O1wlQicQm5A/0" alt="铁道部12306官网如何体现了互联网思维？,互联网的一些事">　　<strong>4、人机交互：跟着验证码练视力</strong><br>　　在用户参与和反馈过程中，12306的验证码环节也在不断迭代升级，从“小数值算术题”进化为“彩色动态验证码机制”，完美体现了凯文·凯利的人机交互思维——12306调动起你眼珠转动的体感，了解你的状态，调节你的视力，提供更符合你眼神儿的购票时间。<br><img src="http://mmbiz.qpic.cn/mmbiz/884XsHGHibP5bianFoD137OSCiaUhMGoW2LQclUia96ibPe5tvCvr75Qg8MDNtQpJSrib9WUNEibs4yg7PyhoRefxxqibg/0" alt="铁道部12306官网如何体现了互联网思维？,互联网的一些事">　　<strong>5、开放平台：拉动产业链</strong><br>　　“开放、共享、共赢”是互联网思维的基本要素，秉承这一理念的12306已成为一个巨大的孵化器，造就了多种抢票衍生品的出现：软件、浏览器、手机客户端……<br>　　同时，12306也鼓舞着人们不断进行众包尝试、云端协作，一个买票任务，十人分工协作，每次任务成功都是UGC的成果。<br><img src="http://mmbiz.qpic.cn/mmbiz/884XsHGHibP5bianFoD137OSCiaUhMGoW2LciaP54phccOicT6w4D4QzEiaMM9J75icZshCDBuSv9ibkHnTknesNownlkA/0" alt="铁道部12306官网如何体现了互联网思维？,互联网的一些事">　　<strong>6、饥饿营销：秒到就是赢，让用户尖叫起来！</strong><br>　　巧妙调动用户心理也是互联网巨头们惯用的手法。面对旺盛的用户需求，12306着重突出几个板块：开票日期、剩余票量、支付时限。<br>　　还有1天!!只剩9张!!还有9秒!!!不到支付的最后一步，抢票就不算成功，从来没有什么消费能做到让用户这般大声尖叫，12306才是饥饿营销的真正王者。<br><img src="http://mmbiz.qpic.cn/mmbiz/884XsHGHibP5bianFoD137OSCiaUhMGoW2LzWbZWic3Hnwd8PYibibqpeJ1EyUUCobB7yTicQWpJpdKyqDpOcKqK3fjxw/0" alt="铁道部12306官网如何体现了互联网思维？,互联网的一些事">　　来自：咋整</p>

      
    </div>
    <footer>
      
      
      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-08T05:09:00.000Z"><a href="/2014/01/08/IOS开发之Block 编程（翻译官方文档）/">1月 8 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/08/IOS开发之Block 编程（翻译官方文档）/">IOS开发之Block 编程（翻译官方文档）</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>本文转自：<a href="http://blog.csdn.net/perfect_promise/article/details/7757746" target="_blank" rel="external">http://blog.csdn.net/perfect_promise/article/details/7757746</a></p>
<p>注：小弟才疏学浅，英文水平够烂，若有不正确或误导的地方，请大家指出，欢迎大家指正和修改。本文中涉及的词法范围：作用范围，例如if{}else{}，两个{}分别是if和else的作用范围。#<a href=""></a>介绍<br>Block对象是一个C级别的语法和运行机制。它与标准的C函数类似，不同之处在于，它除了有可执行代码以外，它还包含了与堆、栈内存绑定的变量。因此，Block对象包含着一组状态数据，这些数据在程序执行时用于对行为产生影响。</p>
<p>你可以用Block来写一些可以传到API中的函数语句，可选择性地存储，并可以使用多线程。作为一个回调，Block特别的有用，因为block既包含了回调期间的代码，又包含了执行期间需要的数据。<br>作为Mac OS X v10.6 Xcode开发工具附带的工具，Block在GCC和Clang中同样可用。你能在Mac OS X v10.6 及其以上版本和iOS 4.0及其以上版本中使用Block。.Block的运行是开源的，因此你能在<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/" target="_blank" rel="external">LLVM’s<br> compiler-rt subproject repository</a>里面找到它。Block也已经被提交到C标准工作组作为 <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1370.pdf" target="_blank" rel="external">N1370:<br> Apple’s Extensions to C</a>。 由于Objective-C 和 C++ 都是衍生自 C，block被设计为可同时兼容这三种语言。<br>你应该阅读这篇文档，去学习Block是什么，以及在C、C++和OC中如何使用Block使你的程序更加的高效和更易于维护。</p>
<h2 id="声明和使用Block"><a href=""></a>声明和使用Block</h2>
<p>用^操作符来声明一个Block变量，并指明Block述句的开始。Block的主体部分包含在 <code>{}内，像下面的例子中一样（与C语法一样，“；”指明语句的结束）：</code><br>    int multiplier = 7;<br>    int (^myBlock)(int) = ^(int num) {<br>        return num <em> multiplier;<br>    };<br><img src="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Art/blocks.jpg" alt="image: ../Art/blocks.jpg">注意：Block可以使用定义范围之内的任何变量。<br>如果你把Block声明为一个变量，你以后就可以像调用一个方法一样使用它：<br>    int multiplier = 7;<br>    int (^myBlock)(int) = ^(int num) {<br>        return num </em> multiplier;<br>    };</p>
<pre><code><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>"</span>, myBlock(<span class="number">3</span>));
<span class="regexp">//</span> prints <span class="string">"21"</span>
</code></pre><h1 id="直接使用Block"><a href=""></a>直接使用Block</h1>
<p>很多情况下，你不需要声明Block变量；你只是简单地写一个Block语句内联在需要使用它作为参数的地方。下面的例子使用了 <code>qsort_b方法，</code>qsort_b方法与标准的qsort_r类似，只是用Block作为它的最后一个参数。``<br>    char *myCharacters[3] = { “TomJohn”, “George”, “Charles Condomine” };</p>
<pre><code>qsort_b(myCharacters, 3, sizeof(char <span class="keyword">*</span>), ^(const void <span class="keyword">*</span>l, const void <span class="keyword">*</span>r) {
    char <span class="keyword">*</span>left = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)l;
    char <span class="keyword">*</span>right = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)r;
    return strncmp(left, right, 1);
});

// myCharacters is now { <span class="string">"Charles Condomine"</span>, <span class="string">"George"</span>, <span class="string">"TomJohn"</span> }
</code></pre><h1 id="Cocoa_Block"><a href=""></a>Cocoa Block</h1>
<p>Cocoa框架中有几个方法使用Block作为参数，通常是在执行对象的操作集合，或者操作完成后使用它作为回调。下面的例子向我们展示了<br><code>在NSArray</code> 对象的方法<code>[sortedArrayUsingComparator:怎样使用Block](http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/NSArray.html#//apple_ref/occ/instm/NSArray/sortedArrayUsingComparator:)</code>.。这个方法只有单一的参数，block被定义为<code>[NSComparator](http://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/c/tdef/NSComparator)</code> 局部变量：<br>    NSArray *stringsArray = [NSArray arrayWithObjects:<br>                                     @”string 1”,<br>                                     @”String 21”,<br>                                     @”string 12”,<br>                                     @”String 11”,<br>                                     @”String 02”, nil];</p>
<pre><code>static NSStringCompareOptions comparisonOptions = NSCaseInsensitiveSearch | NSNumericSearch |
        NSWidthInsensitiveSearch | NSForcedOrderingSearch;
NSLocale *currentLocale = [NSLocale currentLocale];

NSComparator finderSortBlock = ^(<span class="property">id</span> string1, <span class="property">id</span> string2) {

    NSRange string1Range = NSMakeRange(<span class="number">0</span>, [string1 <span class="property">length</span>]);
<span class="command">    return</span> [string1 compare:string2 options:comparisonOptions range:string1Range locale:currentLocale];
};

NSArray *finderSortArray = [stringsArray sortedArrayUsingComparator:finderSortBlock];
NSLog(@<span class="string">"finderSortArray: %@"</span>, finderSortArray);

/*
Output:
finderSortArray: (
    <span class="string">"string 1"</span>,
    <span class="string">"String 02"</span>,
    <span class="string">"String 11"</span>,
    <span class="string">"string 12"</span>,
    <span class="string">"String 21"</span>
)
*/
</code></pre><h2 id="_block变量"><a href=""></a>_block变量</h2>
<p>Block的一个强大的特性是，它能在相同的词法范围内修改变量值。Block能修改变量是通过_block存储类型标示符。与 <a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxGettingStarted.html#//apple_ref/doc/uid/TP40007502-CH7-SW4" target="_blank" rel="external">“Cocoa<br> Block”</a> 中的例子一样，你能使用一个block变量来计算有多少字符串与下面例子中是相同的。 Block直接被用，并且用 <code>currentLocale作为一个只读变量在block中。</code><br>    NSArray *stringsArray = [NSArray arrayWithObjects:<br>                             @”string 1”,<br>                             @”String 21”, // &lt;-<br>                             @”string 12”,<br>                             @”String 11”,<br>                             @”Strîng 21”, // &lt;-<br>                             @”Striñg 21”, // &lt;-<br>                             @”String 02”, nil];</p>
<pre><code>NSLocale *currentLocale = [NSLocale currentLocale];
__block NSUInteger orderedSameCount = <span class="number">0</span>;

NSArray *diacriticInsensitiveSortArray = [stringsArray sortedArrayUsingComparator:^(<span class="property">id</span> string1, <span class="property">id</span> string2) {

    NSRange string1Range = NSMakeRange(<span class="number">0</span>, [string1 <span class="property">length</span>]);
    NSComparisonResult comparisonResult = [string1 compare:string2 options:NSDiacriticInsensitiveSearch range:string1Range locale:currentLocale];

    <span class="keyword">if</span> (comparisonResult == NSOrderedSame) {
        orderedSameCount++;
    }
<span class="command">    return</span> comparisonResult;
}];

NSLog(@<span class="string">"diacriticInsensitiveSortArray: %@"</span>, diacriticInsensitiveSortArray);
NSLog(@<span class="string">"orderedSameCount: %d"</span>, orderedSameCount);

/*
Output:

diacriticInsensitiveSortArray: (
    <span class="string">"String 02"</span>,
    <span class="string">"string 1"</span>,
    <span class="string">"String 11"</span>,
    <span class="string">"string 12"</span>,
    <span class="string">"String 21"</span>,
    <span class="string">"Str\U00eeng 21"</span>,
    <span class="string">"Stri\U00f1g 21"</span>
)
orderedSameCount: <span class="number">2</span>
*/
</code></pre><p>更详细的内容请查看 <a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW1" target="_blank" rel="external">“Blocks<br> 和变量.”</a></p>
<h1 id="Block功能"><a href=""></a>Block功能</h1>
<p>Block是一个匿名的内嵌代码集：</p>
<ul>
<li><p>与方法一样，有一个类型参数列表</p>
</li>
<li><p>有一个隐形或声明的返回类型</p>
</li>
<li><p>能从它定义的词法范围内获取状态</p>
</li>
<li><p>能有选择性地修改词法范围中的状态</p>
</li>
<li><p>能共享相同词法范围内其他块定义的修改的潜在性</p>
</li>
<li><p>词法范围被销毁后仍能继续在已定义的词法范围内共享和修改状态</p>
</li>
</ul>
<p>你能复制一个block，并把它传递给其他线程来延迟执行（或者，在它自己的线程内，做一个运行环）。编译和运行过程中，从block中引用的所有变量都保留乐一份block的副本。block不仅适用于纯 C 和 C++，同时block也是一个Objective-C 对象。</p>
<h1 id="用法"><a href=""></a>用法</h1>
<p>Blocks通常表示比较小的，独立的代码段。因此，它特别适用于可能被同时执行的封装单元工作的模式，或者是集合中的项目，或者是当另一个操作完成后的一个回调。<br>Blocks之所以能替代传统的回调方法主要有以下两个理由：</p>
<ol>
<li><p>它允许你在调用点写代码，调用点稍后会在方法实现段被执行。<br>Blocks通常也是框架方法中的参数。</p>
</li>
<li><p>它允许访问局部变量。<br>与其使用回调，需要一个包含所有上下文信息的数据结构，你只需要执行一个操作，直接访问局部变量即可。</p>
</li>
</ol>
<h1 id="声明block参考"><a href=""></a>声明block参考</h1>
<p>Block变量持有Block引用。 声明它的语法与在函数中声明指针类似，用 <code>^代替</code> <code>*。</code> 其余部分，与C类型系统，具有完全的互操作性。以下时所有有效块的变量声明：<br>    void (^blockReturningVoidWithVoidArgument)(void);<br>    int (^blockReturningIntWithIntAndCharArguments)(int, char);<br>    void (^arrayOfTenBlocksReturningVoidWithIntArgument[10])(int);<br>Block支持可变参数 (<code>...</code>)参数。 不带任何参数的block，在参数列表中必须指定为void。Block的设计考虑到类型安全，通过提供给编译器全套的元数据来验证block的使用、传递参数到block中和返回值分配。一个块引用可以转换到任意类型的指针，反之亦然。但是，你不能通过*来获得block的值，因而在编译时，block的大小也不能被计算出来。<br>你可以创建一个block类型，当你在多个地方使用到同一个签名的block时，这种方式时很好的。<br>    typedef float (^MyBlockType)(float, float);</p>
<pre><code>MyBlockType myFirstBlock = // <span class="keyword">...</span> ;
MyBlockType mySecondBlock = // <span class="keyword">...</span> ;
</code></pre><h1 id="创建block"><a href=""></a>创建block</h1>
<p>用^指明block语句的开始。在它后面的（）是参数列表。block的主体部分在{ }里面.。下面的例子定义了一个简单的block，并把先前定义的变量（oneForm）分配给它。<br>    int (^oneFrom)(int);</p>
<pre><code>oneFrom = ^(<span class="keyword">int</span> anInt) {
    <span class="keyword">return</span> anInt - <span class="number">1</span>;
};
</code></pre><p>如果你不显式声明块表达式的返回值，它可以根据block的内容进行自动匹配。如果返回类型和参数列表都是void，你也可以省略参数列表。 如果存在多个返回语句，应该正确的进行匹配(又需要的话，可以使用类型转换)。</p>
<h1 id="全局block"><a href=""></a>全局block</h1>
<p>在文件级别，你可以使用block作为一个全局表达式。</p>
<pre><code><span class="preprocessor">#import &lt;stdio.h&gt;</span>

<span class="keyword">int</span> GlobalInt = <span class="number">0</span>;
<span class="keyword">int</span> (^getGlobalInt)(<span class="keyword">void</span>) = ^{ <span class="keyword">return</span> GlobalInt; };
</code></pre><h1 id="变量类型"><a href=""></a>变量类型</h1>
<p>block对象的代码中，变量被看成五种不同的方式。<br>与函数一样，block支持三种标准类型的变量：</p>
<ul>
<li><p>全局变量，带有static修饰符的变量</p>
</li>
<li><p>全局函数（不是专门的变量）</p>
</li>
<li><p>局部变量和参数</p>
</li>
</ul>
<p>Blocks也支持其他两种变量类型：</p>
<ol>
<li><p>函数级别的_block变量。如有引用块被复制到堆，block中的_block变量是可变的。</p>
</li>
<li><p><code>const</code></p>
</li>
</ol>
<p>最后，在一个方法的实现，块可能引用的Objective-C的实例变量—参考<a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW3" target="_blank" rel="external">“Object<br> and Block Variables.”</a><br>以下是在block中使用变量的规则：</p>
<ol>
<li><p>可以访问全局变量，包括词法范围内存在的static变量。</p>
</li>
<li><p>可以传参给block，与传参给函数的方式是一样的。</p>
</li>
<li><p>局部词法范围内的堆栈变量被看成时const变量。<br>他们的值存放在程序内的block语句中。 在嵌套block中，他们的值来自于最近的词法范围内。</p>
</li>
<li><p>声明为_block类型的<br>局部词法范围内的变量是可改变的。更改的适用范围仅为局部词法范围，包括词法范围内定义的其他block。 在<a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6" target="_blank" rel="external">“The<br>__block Storage Type.”</a>中有更详细的描述。</p>
</li>
<li>block作用范围内声明的局部变量，与函数中的局部变量一样。<br>block的每一次调用，都重新生成此变量的新的副本。这些变量可以被转换为const或引用变量在块内的作用域。</li>
</ol>
<p>下面的例子说明了局部非静态变量的使用：</p>
<pre><code><span class="keyword">int</span> <span class="keyword">x</span> = <span class="number">123</span>;

void (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> <span class="keyword">y</span>) {

    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> <span class="variable">%d</span>\n"</span>, <span class="keyword">x</span>, <span class="keyword">y</span>);
};

printXAndY(<span class="number">456</span>); <span class="regexp">//</span> prints: <span class="number">123</span> <span class="number">456</span>
</code></pre><p>如上所述，在block内试图分配一个新的x的值将会报错：<br>    int x = 123;</p>
<pre><code>void (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> <span class="keyword">y</span>) {

    <span class="keyword">x</span> = <span class="keyword">x</span> + <span class="keyword">y</span>; <span class="regexp">//</span> error
    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span> <span class="variable">%d</span>\n"</span>, <span class="keyword">x</span>, <span class="keyword">y</span>);
};
</code></pre><p>为了使一个变量在block内部可以被修改，你应该使用_block来修饰这个变量—参考 <a href="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6" target="_blank" rel="external">“The<br> __block Storage Type.”</a></p>
<h1 id="_block存储类型"><a href=""></a>_block存储类型</h1>
<p>在变量前面加上_block类型修饰符，我们可以指定传进来的变量是可变或者可读写的。_block存储与它类似，但是局部变量的寄存器、auto变量和static存储类型之间相互排斥。<br><code>_block变量共享变量之间的作用域和块之间的作用域拷贝变量存储范围内。因此，如果block中定义的所有拷贝在框架内的生存超越帧结束（例如，正在排队等待执行），堆栈帧被破坏后存储也将继续存在</code>。在一个给定的词法范围的多个块，可以同时使用共享变量。<br>作为优化，在堆栈上的块存储块启动就像自身调用一样。如果块被复制，使用Block_copy（或在Objective-C中块发送一个副本），变量将被复制到堆。因此，_block块的地址可以随时更改。<br>_block变量有两个进一步的限制：他们不能是可变数组，不能包含C99的可变长数组的结构。<br>下面的例子说明了_block变量的作用：<br>    __block int x = 123; //  x lives in block storage</p>
<pre><code><span class="keyword">void</span> (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> y) {

    x = x + y;
    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);
};
printXAndY(<span class="number">456</span>); <span class="comment">// prints: 579 456</span>
<span class="comment">// x is now 579</span>
</code></pre><p>下面的例子显示了几种类型的变量块的相互作用：<br>    extern NSInteger CounterGlobal;<br>    static NSInteger CounterStatic;</p>
<pre><code>{
    <span class="built_in">NSInteger</span> localCounter = <span class="number">42</span>;
    __block <span class="keyword">char</span> localCharacter;

    <span class="keyword">void</span> (^aBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) {
        ++CounterGlobal;
        ++CounterStatic;
        CounterGlobal = localCounter; <span class="comment">// localCounter fixed at block creation</span>
        localCharacter = <span class="string">'a'</span>; <span class="comment">// sets localCharacter in enclosing scope</span>
    };

    ++localCounter; <span class="comment">// unseen by the block</span>
    localCharacter = <span class="string">'b'</span>;

    aBlock(); <span class="comment">// execute the block</span>
    <span class="comment">// localCharacter now 'a'</span>
}
</code></pre><h1 id="对象和block变量"><a href=""></a>对象和block变量</h1>
<p>Block提供支持的Objective-C和C+ +的对象，和其他块，作为变量。</p>
<h3 id="Objective-C_对象"><a href=""></a>Objective-C 对象</h3>
<p>在手动引用计数的环境， 复制块时，块内使用局部变量保留。Block内使用的局部变量引用技术将retain。如果您想覆盖一个特定对象变量的这种行为，你可以标记_block修饰符来修饰该变量。<br>如果您使用ARC，当block被copy时对象变量被保留，并自动释放，和延迟释放。<br><a href="&quot;Note&quot;"></a><strong>注：在垃圾收集的环境，如果你给变量同时使用_weak和_block修饰符，那么该block将无法确保是否还存在。</strong></p>
<p>如果你在执行方法内使用block，实例变量对象的内存管理规则更加微妙：</p>
<ul>
<li><p>如果您访问实例变量的参照，对象retain；</p>
</li>
<li><p>如果您访问实例变量的值，对象retain；</p>
</li>
</ul>
<p>下面的例子说明了两种不同的情况：<br>    dispatch_async(queue, ^{<br>        // instanceVariable is used by reference, self is retained<br>        doSomethingWithObject(instanceVariable);<br>    });</p>
<pre><code>id localVariable = instanceVariable;
dispatch_async(queue, ^{
    <span class="regexp">//</span> localVariable <span class="keyword">is</span> used <span class="keyword">by</span> value, localVariable <span class="keyword">is</span> retained (<span class="keyword">not</span> self)
    doSomethingWithObject(localVariable);
});
</code></pre><h1 id="调用block"><a href=""></a>调用block</h1>
<p>如果你声明block作为一个变量，你可以像使用函数一样使用它，就像下面两个示例所示一样：<br>    int (^oneFrom)(int) = ^(int anInt) {<br>        return anInt - 1;<br>    };</p>
<pre><code><span class="built_in">printf</span>(<span class="string">"1 from 10 is %d"</span>, oneFrom(<span class="number">10</span>));
<span class="comment">// Prints "1 from 10 is 9"</span>

<span class="keyword">float</span> (^distanceTraveled) (<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>) =
                          ^(<span class="keyword">float</span> startingSpeed, <span class="keyword">float</span> acceleration, <span class="keyword">float</span> time) {

    <span class="keyword">float</span> <span class="built_in">distance</span> = (startingSpeed * time) + (<span class="number">0.5</span> * acceleration * time * time);
    <span class="keyword">return</span> <span class="built_in">distance</span>;
};

<span class="keyword">float</span> howFar = distanceTraveled(<span class="number">0.0</span>, <span class="number">9.8</span>, <span class="number">1.0</span>);
<span class="comment">// howFar = 4.9</span>
</code></pre><p>然而，通常情况下，你使用block作为一个函数或方法的参数，在这些情况下，你通常创建一个块“内联”。</p>
<h1 id="使用block作为函数参数"><a href=""></a>使用block作为函数参数</h1>
<p>可以把block作为函数参数进行传递，就像其他参数一样。然后，很多时候你不需要声明block；而你只需把他们内联到需要使用block作为一个参数的地方。下面的例子使用了 <code>qsort_b方法，</code>qsort_b方法与标准的qsort_r类似，只是用Block作为它的最后一个参数。``<br>    char *myCharacters[3] = { “TomJohn”, “George”, “Charles Condomine” };</p>
<pre><code>qsort_b(myCharacters, 3, sizeof(char <span class="keyword">*</span>), ^(const void <span class="keyword">*</span>l, const void <span class="keyword">*</span>r) {
    char <span class="keyword">*</span>left = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)l;
    char <span class="keyword">*</span>right = <span class="keyword">*</span>(char <span class="keyword">*</span><span class="keyword">*</span>)r;
    return strncmp(left, right, 1);
});
// Block implementation ends at <span class="string">"}"</span>

// myCharacters is now { <span class="string">"Charles Condomine"</span>, <span class="string">"George"</span>, <span class="string">"TomJohn"</span> }
</code></pre><p>请注意，该块包含在函数的参数列表。<br>下面的示例显示如何使用block的dispatch_apply函数。 <code>dispatch_apply``使用以下方式进行定义：</code><br>    void dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));<br>功能是提交一个block到一个调度队列进行多次调用。它携带了三个参数；第一个参数指定执行的迭代的数量；第二个参数指定block被提交到哪个队列； 点歌参数就是block自身，反过来这需要一个参数迭代的当前索引。<br>可以使用<code>dispatch_apply</code> 分别打印出迭代索引，如下所示：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;dispatch/dispatch.h&gt;</span>
size_t count = <span class="number">10</span>;
dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);

dispatch_apply(count, <span class="built_in">queue</span>, ^(size_t i) {
    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, i);
});
</code></pre><h1 id="使用block作为方法参数"><a href=""></a>使用block作为方法参数</h1>
<p><a href="">Cocoa提供了一种方法，使用blocks。传递block作为参数与传递其他参数的方式是一样的。</a><br>下面的示例，确定一个数组前五个元素中任意一个在过滤集中的索引数。<br>    NSArray <em>array = [NSArray arrayWithObjects: @”A”, @”B”, @”C”, @”A”, @”B”, @”Z”,@”G”, @”are”, @”Q”, nil];<br>    NSSet </em>filterSet = [NSSet setWithObjects: @”A”, @”Z”, @”Q”, nil];</p>
<pre><code><span class="built_in">BOOL</span> (^test)(<span class="keyword">id</span> obj, NSUInteger idx, <span class="built_in">BOOL</span> *stop);

test = ^ (<span class="keyword">id</span> obj, NSUInteger idx, <span class="built_in">BOOL</span> *stop) {

    <span class="keyword">if</span> (idx &lt; <span class="number">5</span>) {
        <span class="keyword">if</span> ([filterSet containsObject: obj]) {
            <span class="keyword">return</span> <span class="literal">YES</span>;
        }
    }
    <span class="keyword">return</span> <span class="literal">NO</span>;
};

<span class="built_in">NSIndexSet</span> *indexes = [array indexesOfObjectsPassingTest:test];

<span class="built_in">NSLog</span>(<span class="string">@"indexes: %@"</span>, indexes);

<span class="comment">/*
Output:
indexes: &lt;NSIndexSet: 0x10236f0&gt;[number of indexes: 2 (in 2 ranges), indexes: (0 3)]
*/</span>
</code></pre><p>下方的例子是确定一个NSSet对象中是否包含有局部变量指定的一个单词，如果包含的话，设置另一个局部变量的值为YES。found也被声明为一个_block变量， 这个block是定义联：<br>    __block BOOL found = NO;<br>    NSSet <em>aSet = [NSSet setWithObjects: @”Alpha”, @”Beta”, @”Gamma”, @”X”, nil];<br>    NSString </em>string = @”gamma”;</p>
<pre><code>[aSet enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) {
    <span class="keyword">if</span> ([obj localizedCaseInsensitiveCompare:string] == NSOrderedSame) {
        *stop = <span class="literal">YES</span>;
        found = <span class="literal">YES</span>;
    }
}];

<span class="comment">// At this point, found == YES</span>
</code></pre><h1 id="复制block"><a href=""></a>复制block</h1>
<p>通常情况下，你不需要复制（或保留）一个块。如果你想要block在它的定义域被销毁后仍可以被使用，你仅仅只需要创建一个副本。复制移动block到堆中。.<br>你能用C函数来复制和释放block：<br>    Block_copy();<br>    Block_release();<br>如果你使用Objective-C，block的属性可以使用copy、retain、release和autorelease。<br>为了避免产生内存泄露，block的copy和retain的使用必须平衡。使用了copy和retain的地方必须进行release（autorelease除外）——除非在一个垃圾收集环境。</p>
<h1 id="避免的模式"><a href=""></a>避免的模式</h1>
<p>块文本（即，^{…}）是一个堆栈的本地数据结构的地址块。因此堆栈的本地数据结构的范围是封闭的复合语句，所以你应该避免使用下例中的模式：,<br>    void dontDoThis() {<br>        void (^blockArray[3])(void);  // an array of 3 block references</p>
<pre><code>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {
        blockArray[i] = ^{ printf(<span class="string">"hello, %d\n"</span>, i); };
        // <span class="type">WRONG</span>: <span class="type">The</span> <span class="keyword">block</span> literal scope <span class="keyword">is</span> the <span class="string">"for"</span> loop
    }
}

<span class="type">void</span> dontDoThisEither() {
    <span class="type">void</span> (^<span class="keyword">block</span>)(<span class="type">void</span>);

    <span class="type">int</span> i = random():
    <span class="keyword">if</span> (i &gt; <span class="number">1000</span>) {
        <span class="keyword">block</span> = ^{ printf(<span class="string">"got i at: %d\n"</span>, i); };
        // <span class="type">WRONG</span>: <span class="type">The</span> <span class="keyword">block</span> literal scope <span class="keyword">is</span> the <span class="string">"then"</span> clause
    }
    // ...
}
</code></pre><h1 id="调试"><a href=""></a>调试</h1>
<p>在block中你可以设置断点进行单步调试。你可以从调用块内GDB会议调用一个block，如下例所示：<br>    $ invoke-block myBlock 10 20<br>如果你想传一个C字符串值，你必须使用引用。例如， 把这个字符串传到<code>doSomethingWithString</code> block中，你可以像下面这样写：<br>    $ invoke-block doSomethingWithString “\”this string\””</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-08T02:29:00.000Z"><a href="/2014/01/08/IOS应用如何配置iTunes文件共享/">1月 8 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/08/IOS应用如何配置iTunes文件共享/">IOS应用如何配置iTunes文件共享</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>info.plist里设置UIFileSharingEnabled = YES;</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之Xcode配置/">iOS应用开发之Xcode配置</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/itunes/">itunes</a>, <a href="/tags/应用程序/">应用程序</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-07T07:36:00.000Z"><a href="/2014/01/07/基于XMPP的IOS聊天客户端程序(IOS端三)/">1月 7 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/07/基于XMPP的IOS聊天客户端程序(IOS端三)/">基于XMPP的IOS聊天客户端程序(IOS端三)</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><a href="http://blog.csdn.net/kangx6/article/details/7750765" target="_blank" rel="external"> 本文转自：http://blog.csdn.net/kangx6/article/details/7750765</a></p>
<p>前两篇介绍了如何通过XMPP来发送消息和接收消息，这一篇我们主要介绍如何来美化我们的聊天程序，看一下最终效果呢，当然源程序也会在最后放出<br><img src="http://my.csdn.net/uploads/201207/16/1342409417_2820.png" alt=""></p>
<p>好了，我们来看一下我们写的程序<br>这里我们自定义了TableViewCell<br><img src="http://my.csdn.net/uploads/201207/16/1342411906_4192.png" alt=""></p>
<p>一行是显示发布日期，一行是显示发送的消息，还有一个是背景</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. -(id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier{  </p>
<ol>
<li></li>
<li>self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];  </li>
<li>if (self) {  </li>
<li>//日期标签  </li>
<li>senderAndTimeLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 5, 300, 20)];  </li>
<li>//居中显示  </li>
<li>senderAndTimeLabel.textAlignment = UITextAlignmentCenter;  </li>
<li>senderAndTimeLabel.font = [UIFont systemFontOfSize:11.0];  </li>
<li>//文字颜色  </li>
<li>senderAndTimeLabel.textColor = [UIColor lightGrayColor];  </li>
<li>[self.contentView addSubview:senderAndTimeLabel];  </li>
<li></li>
<li>//背景图  </li>
<li>bgImageView = [[UIImageView alloc] initWithFrame:CGRectZero];  </li>
<li>[self.contentView addSubview:bgImageView];  </li>
<li></li>
<li>//聊天信息  </li>
<li>messageContentView = [[UITextView alloc] init];  </li>
<li>messageContentView.backgroundColor = [UIColor clearColor];  </li>
<li>//不可编辑  </li>
<li>messageContentView.editable = NO;  </li>
<li>messageContentView.scrollEnabled = NO;  </li>
<li>[messageContentView sizeToFit];  </li>
<li>[self.contentView addSubview:messageContentView];  </li>
<li></li>
<li>}  </li>
<li></li>
<li>return self;  </li>
<li></li>
<li>}  </li>
</ol>
<p>定义好，在UITableViewCell中将Cell改成我们自己定义的Cell</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. -(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{  </p>
<ol>
<li></li>
<li>static NSString *identifier = @”msgCell”;  </li>
<li></li>
<li>KKMessageCell <em>cell =(KKMessageCell </em>)[tableView dequeueReusableCellWithIdentifier:identifier];  </li>
<li></li>
<li>if (cell == nil) {  </li>
<li>cell = [[KKMessageCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:identifier];  </li>
<li>}  </li>
<li></li>
<li>NSMutableDictionary *dict = [messages objectAtIndex:indexPath.row];  </li>
<li></li>
<li>//发送者  </li>
<li>NSString *sender = [dict objectForKey:@”sender”];  </li>
<li>//消息  </li>
<li>NSString *message = [dict objectForKey:@”msg”];  </li>
<li>//时间  </li>
<li>NSString *time = [dict objectForKey:@”time”];  </li>
<li></li>
<li>CGSize textSize = {260.0 ,10000.0};  </li>
<li>CGSize size = [message sizeWithFont:[UIFont boldSystemFontOfSize:13] constrainedToSize:textSize lineBreakMode:UILineBreakModeWordWrap];  </li>
<li></li>
<li>size.width +=(padding/2);  </li>
<li></li>
<li>cell.messageContentView.text = message;  </li>
<li>cell.accessoryType = UITableViewCellAccessoryNone;  </li>
<li>cell.userInteractionEnabled = NO;  </li>
<li></li>
<li>UIImage *bgImage = nil;  </li>
<li></li>
<li>//发送消息  </li>
<li>if ([sender isEqualToString:@”you”]) {  </li>
<li>//背景图  </li>
<li>bgImage = [[UIImage imageNamed:@”BlueBubble2.png”] stretchableImageWithLeftCapWidth:20 topCapHeight:15];  </li>
<li>[cell.messageContentView setFrame:CGRectMake(padding, padding*2, size.width, size.height)];  </li>
<li></li>
<li>[cell.bgImageView setFrame:CGRectMake(cell.messageContentView.frame.origin.x - padding/2, cell.messageContentView.frame.origin.y - padding/2, size.width + padding, size.height + padding)];  </li>
<li>}else {  </li>
<li></li>
<li>bgImage = [[UIImage imageNamed:@”GreenBubble2.png”] stretchableImageWithLeftCapWidth:14 topCapHeight:15];  </li>
<li></li>
<li>[cell.messageContentView setFrame:CGRectMake(320-size.width - padding, padding*2, size.width, size.height)];  </li>
<li>[cell.bgImageView setFrame:CGRectMake(cell.messageContentView.frame.origin.x - padding/2, cell.messageContentView.frame.origin.y - padding/2, size.width + padding, size.height + padding)];  </li>
<li>}  </li>
<li></li>
<li>cell.bgImageView.image = bgImage;  </li>
<li>cell.senderAndTimeLabel.text = [NSString stringWithFormat:@”%@ %@”, sender, time];  </li>
<li></li>
<li>return cell;  </li>
<li></li>
<li>}  </li>
</ol>
<p>在这个Cell里设置了发送的消息的背景图和接收消息的背景图<br>这里在字典里有一个”time”<br>这是我们接收和发送消息的时间</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. +(NSString *)getCurrentTime{  </p>
<ol>
<li></li>
<li>NSDate *nowUTC = [NSDate date];  </li>
<li></li>
<li>NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];  </li>
<li>[dateFormatter setTimeZone:[NSTimeZone localTimeZone]];  </li>
<li>[dateFormatter setDateStyle:NSDateFormatterMediumStyle];  </li>
<li>[dateFormatter setTimeStyle:NSDateFormatterMediumStyle];  </li>
<li></li>
<li>return [dateFormatter stringFromDate:nowUTC];  </li>
<li></li>
<li>}  </li>
</ol>
<p>在AppDelegate.m中<br>将我们收到消息的内容也做一下调整</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. - (void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message{  </p>
<ol>
<li></li>
<li>//   ……  </li>
<li></li>
<li>NSMutableDictionary *dict = [NSMutableDictionary dictionary];  </li>
<li>[dict setObject:msg forKey:@”msg”];  </li>
<li>[dict setObject:from forKey:@”sender”];  </li>
<li>//消息接收到的时间  </li>
<li>[dict setObject:[Statics getCurrentTime] forKey:@”time”];  </li>
<li></li>
<li>……  </li>
<li></li>
<li>}  </li>
</ol>
<p>最后我们再设置一下每一行显示的高度</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. //每一行的高度  </p>
<ol>
<li>-(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath{  </li>
<li></li>
<li>NSMutableDictionary *dict  = [messages objectAtIndex:indexPath.row];  </li>
<li>NSString *msg = [dict objectForKey:@”msg”];  </li>
<li></li>
<li>CGSize textSize = {260.0 , 10000.0};  </li>
<li>CGSize size = [msg sizeWithFont:[UIFont boldSystemFontOfSize:13] constrainedToSize:textSize lineBreakMode:UILineBreakModeWordWrap];  </li>
<li></li>
<li>size.height += padding*2;  </li>
<li></li>
<li>CGFloat height = size.height &lt; 65 ? 65 : size.height;  </li>
<li></li>
<li>return height;  </li>
<li></li>
<li>}  </li>
</ol>
<p>，对了，在发送消息的时候，别忘了也加上</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7750765#" title="copy" target="_blank" rel="external">copy</a>1. - (IBAction)sendButton:(id)sender {  </p>
<ol>
<li></li>
<li>//本地输入框中的信息  </li>
<li>……  </li>
<li></li>
<li>if (message.length &gt; 0) {  </li>
<li></li>
<li>…..  </li>
<li></li>
<li>NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];  </li>
<li></li>
<li>[dictionary setObject:message forKey:@”msg”];  </li>
<li>[dictionary setObject:@”you” forKey:@”sender”];  </li>
<li>[dictionary setObject:[Statics getCurrentTime] forKey:@”time”];  </li>
<li></li>
<li>[messages addObject:dictionary];  </li>
<li></li>
<li>//重新刷新tableView  </li>
<li>[self.tView reloadData];  </li>
<li></li>
<li>}  </li>
<li></li>
<li></li>
<li>}  </li>
</ol>
<p>好了，这里关于XMPP发送消息的教程就结束了，以后我们会详细介绍其他关于XMPP的内容<br><a href="http://download.csdn.net/detail/kangkangz4/4431399" target="_blank" rel="external">源码下载</a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之社交软件/">iOS应用开发之社交软件</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/XMPP/">XMPP</a>, <a href="/tags/ios/">ios</a>, <a href="/tags/聊天/">聊天</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-07T07:35:00.000Z"><a href="/2014/01/07/基于XMPP的IOS聊天客户端程序(IOS端二)/">1月 7 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/07/基于XMPP的IOS聊天客户端程序(IOS端二)/">基于XMPP的IOS聊天客户端程序(IOS端二)</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><a href="http://blog.csdn.net/kangx6/article/details/7744304" target="_blank" rel="external">本文转自：http://blog.csdn.net/kangx6/article/details/7744304</a></p>
<p>接上一章的，这一章我们着重介绍XMPP<br>为了方便程序调用，我们把XMPP的一些主要方法写在AppDelegate中<br><img src="http://my.csdn.net/uploads/201207/13/1342165427_8599.png" alt=""></p>
<p>在AppDelegate.m下这几个方法为：</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. -(void)setupStream{  </p>
<ol>
<li></li>
<li>//初始化XMPPStream  </li>
<li>xmppStream = [[XMPPStream alloc] init];  </li>
<li>[xmppStream addDelegate:self delegateQueue:dispatch_get_current_queue()];  </li>
<li></li>
<li>}  </li>
<li></li>
<li>-(void)goOnline{  </li>
<li></li>
<li>//发送在线状态  </li>
<li>XMPPPresence *presence = [XMPPPresence presence];  </li>
<li>[[self xmppStream] sendElement:presence];  </li>
<li></li>
<li>}  </li>
<li></li>
<li>-(void)goOffline{  </li>
<li></li>
<li>//发送下线状态  </li>
<li>XMPPPresence *presence = [XMPPPresence presenceWithType:@”unavailable”];  </li>
<li>[[self xmppStream] sendElement:presence];  </li>
<li></li>
<li>}  </li>
<li></li>
<li>-(BOOL)connect{  </li>
<li></li>
<li>[self setupStream];  </li>
<li></li>
<li>//从本地取得用户名，密码和服务器地址  </li>
<li>NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];  </li>
<li></li>
<li>NSString *userId = [defaults stringForKey:USERID];  </li>
<li>NSString *pass = [defaults stringForKey:PASS];  </li>
<li>NSString *server = [defaults stringForKey:SERVER];  </li>
<li></li>
<li>if (![xmppStream isDisconnected]) {  </li>
<li>return YES;  </li>
<li>}  </li>
<li></li>
<li>if (userId == nil || pass == nil) {  </li>
<li>return NO;  </li>
<li>}  </li>
<li></li>
<li>//设置用户  </li>
<li>[xmppStream setMyJID:[XMPPJID jidWithString:userId]];  </li>
<li>//设置服务器  </li>
<li>[xmppStream setHostName:server];  </li>
<li>//密码  </li>
<li>password = pass;  </li>
<li></li>
<li>//连接服务器  </li>
<li>NSError *error = nil;  </li>
<li>if (![xmppStream connect:&amp;error]) {  </li>
<li>NSLog(@”cant connect %@”, server);  </li>
<li>return NO;  </li>
<li>}  </li>
<li></li>
<li>return YES;  </li>
<li></li>
<li>}  </li>
<li></li>
<li>-(void)disconnect{  </li>
<li></li>
<li>[self goOffline];  </li>
<li>[xmppStream disconnect];  </li>
<li></li>
<li>}  </li>
</ol>
<p>这几个是基础方法，接下来就是XMPPStreamDelegate中的方法，也是接受好友状态，接受消息的重要方法</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. //连接服务器  </p>
<ol>
<li><ul>
<li>(void)xmppStreamDidConnect:(XMPPStream *)sender{  </li>
</ul>
</li>
<li></li>
<li>isOpen = YES;  </li>
<li>NSError *error = nil;  </li>
<li>//验证密码  </li>
<li>[[self xmppStream] authenticateWithPassword:password error:&amp;error];  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//验证通过  </li>
<li><ul>
<li>(void)xmppStreamDidAuthenticate:(XMPPStream *)sender{  </li>
</ul>
</li>
<li></li>
<li>[self goOnline];  </li>
<li>}  </li>
<li></li>
<li>//收到消息  </li>
<li><ul>
<li>(void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message{  </li>
</ul>
</li>
<li></li>
<li>//    NSLog(@”message = %@”, message);  </li>
<li></li>
<li>NSString *msg = [[message elementForName:@”body”] stringValue];  </li>
<li>NSString *from = [[message attributeForName:@”from”] stringValue];  </li>
<li></li>
<li>NSMutableDictionary *dict = [NSMutableDictionary dictionary];  </li>
<li>[dict setObject:msg forKey:@”msg”];  </li>
<li>[dict setObject:from forKey:@”sender”];  </li>
<li></li>
<li>//消息委托(这个后面讲)  </li>
<li>[messageDelegate newMessageReceived:dict];  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//收到好友状态  </li>
<li><ul>
<li>(void)xmppStream:(XMPPStream <em>)sender didReceivePresence:(XMPPPresence </em>)presence{  </li>
</ul>
</li>
<li></li>
<li>//    NSLog(@”presence = %@”, presence);  </li>
<li></li>
<li>//取得好友状态  </li>
<li>NSString *presenceType = [presence type]; //online/offline  </li>
<li>//当前用户  </li>
<li>NSString *userId = [[sender myJID] user];  </li>
<li>//在线用户  </li>
<li>NSString *presenceFromUser = [[presence from] user];  </li>
<li></li>
<li>if (![presenceFromUser isEqualToString:userId]) {  </li>
<li></li>
<li>//在线状态  </li>
<li>if ([presenceType isEqualToString:@”available”]) {  </li>
<li></li>
<li>//用户列表委托(后面讲)  </li>
<li>[chatDelegate newBuddyOnline:[NSString stringWithFormat:@”%@@%@”, presenceFromUser, @”nqc1338a”]];  </li>
<li></li>
<li>}else if ([presenceType isEqualToString:@”unavailable”]) {  </li>
<li>//用户列表委托(后面讲)  </li>
<li>[chatDelegate buddyWentOffline:[NSString stringWithFormat:@”%@@%@”, presenceFromUser, @”nqc1338a”]];  </li>
<li>}  </li>
<li></li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>这里面有两个委托方法，一个是用户列表委托，还有一个就是消息委托，用户列表委托主要就是取得在线用户，更新用户TableView，消息委托就是取得好友发送的消息，并更新消息TableView，当然这两个TableView是在不同的Controller中的<br><img src="http://my.csdn.net/uploads/201207/13/1342166381_8738.png" alt=""></p>
<p><img src="http://my.csdn.net/uploads/201207/13/1342166396_5139.png" alt=""></p>
<p>定义完两个委托，我们就要在不同的Controller中实现这两个委托了<br>在好友Controller中实现<kkchatdelegate>并写入如下方法</kkchatdelegate></p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. //取得当前程序的委托  </p>
<ol>
<li>-(KKAppDelegate *)appDelegate{  </li>
<li></li>
<li>return (KKAppDelegate *)[[UIApplication sharedApplication] delegate];  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//取得当前的XMPPStream  </li>
<li>-(XMPPStream *)xmppStream{  </li>
<li></li>
<li>return [[self appDelegate] xmppStream];  </li>
<li>}  </li>
<li></li>
<li>//在线好友  </li>
<li>-(void)newBuddyOnline:(NSString *)buddyName{  </li>
<li></li>
<li>if (![onlineUsers containsObject:buddyName]) {  </li>
<li>[onlineUsers addObject:buddyName];  </li>
<li>[self.tView reloadData];  </li>
<li>}  </li>
<li></li>
<li>}  </li>
<li></li>
<li>//好友下线  </li>
<li>-(void)buddyWentOffline:(NSString *)buddyName{  </li>
<li></li>
<li>[onlineUsers removeObject:buddyName];  </li>
<li>[self.tView reloadData];  </li>
<li></li>
<li>}  </li>
</ol>
<p>在viewDidLoad中加入</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. //设定在线用户委托  </p>
<ol>
<li>KKAppDelegate *del = [self appDelegate];  </li>
<li>del.chatDelegate = self;  </li>
</ol>
<p>这两行代码，让好友列表的委托实现方法在本程序中<br>在viewWillAppear中加入</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. [super viewWillAppear:animated];  </p>
<ol>
<li></li>
<li>NSString *login = [[NSUserDefaults standardUserDefaults] objectForKey:@”userId”];  </li>
<li></li>
<li>if (login) {  </li>
<li></li>
<li>if ([[self appDelegate] connect]) {  </li>
<li>NSLog(@”show buddy list”);  </li>
<li></li>
<li>}  </li>
<li></li>
<li>}else {  </li>
<li></li>
<li>//设定用户  </li>
<li>[self Account:self];  </li>
<li></li>
<li>}  </li>
</ol>
<p>判断本地保存的数据中是否有userId，没有的话就跳转到登录页面<br>这里最重要的就是connect了，这一句话就是登录了，成功的话，页面就会显示好友列表了。</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. #pragma mark UITableViewDelegate  </p>
<ol>
<li>-(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath{  </li>
<li></li>
<li>//start a Chat  </li>
<li>chatUserName = (NSString *)[onlineUsers objectAtIndex:indexPath.row];  </li>
<li></li>
<li>[self performSegueWithIdentifier:@”chat” sender:self];  </li>
<li></li>
<li>}  </li>
<li>-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{  </li>
<li></li>
<li>if ([segue.identifier isEqualToString:@”chat”]) {  </li>
<li>KKChatController *chatController = segue.destinationViewController;  </li>
<li>chatController.chatWithUser = chatUserName;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>当显示出好友列表，我们选择一个好友进行聊天<br>将当前好友名称发送给聊天页面<br>下面是聊天Controller了<br>在KKChatController.h中加入</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. NSMutableArray *messages;  </p>
<p>这是我们要显示的消息，每一条消息为一条字典<br>接下来就是每一条消息的显示了</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. -(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{  </p>
<ol>
<li></li>
<li>static NSString *identifier = @”msgCell”;  </li>
<li></li>
<li>UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];  </li>
<li></li>
<li>if (cell == nil) {  </li>
<li>cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:identifier];  </li>
<li>}  </li>
<li></li>
<li>NSMutableDictionary *dict = [messages objectAtIndex:indexPath.row];  </li>
<li></li>
<li>cell.textLabel.text = [dict objectForKey:@”msg”];  </li>
<li>cell.detailTextLabel.text = [dict objectForKey:@”sender”];  </li>
<li>cell.accessoryType = UITableViewCellAccessoryNone;  </li>
<li></li>
<li>return cell;  </li>
<li></li>
<li>}  </li>
</ol>
<p>跟上面好友Controller一样，这里我们也需要XMPPStream</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. -(KKAppDelegate *)appDelegate{  </p>
<ol>
<li></li>
<li>return (KKAppDelegate *)[[UIApplication sharedApplication] delegate];  </li>
<li>}  </li>
<li></li>
<li>-(XMPPStream *)xmppStream{  </li>
<li></li>
<li>return [[self appDelegate] xmppStream];  </li>
<li>}  </li>
</ol>
<p>在ViewDidLoad中加入</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. KKAppDelegate *del = [self appDelegate];  </p>
<ol>
<li>del.messageDelegate = self;  </li>
</ol>
<p>设定消息委托由自己来接收和处理</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. #pragma mark KKMessageDelegate  </p>
<ol>
<li>-(void)newMessageReceived:(NSDictionary *)messageCotent{  </li>
<li></li>
<li>[messages addObject:messageCotent];  </li>
<li></li>
<li>[self.tView reloadData];  </li>
<li></li>
<li>}  </li>
</ol>
<p>接下来最重要的就是发送消息了</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7744304#" title="copy" target="_blank" rel="external">copy</a>1. - (IBAction)sendButton:(id)sender {  </p>
<ol>
<li></li>
<li>//本地输入框中的信息  </li>
<li>NSString *message = self.messageTextField.text;  </li>
<li></li>
<li>if (message.length &gt; 0) {  </li>
<li></li>
<li>//XMPPFramework主要是通过KissXML来生成XML文件  </li>
<li>//生成<body>文档  </body></li>
<li>NSXMLElement *body = [NSXMLElement elementWithName:@”body”];  </li>
<li>[body setStringValue:message];  </li>
<li></li>
<li>//生成XML消息文档  </li>
<li>NSXMLElement *mes = [NSXMLElement elementWithName:@”message”];  </li>
<li>//消息类型  </li>
<li>[mes addAttributeWithName:@”type” stringValue:@”chat”];  </li>
<li>//发送给谁  </li>
<li>[mes addAttributeWithName:@”to” stringValue:chatWithUser];  </li>
<li>//由谁发送  </li>
<li>[mes addAttributeWithName:@”from” stringValue:[[NSUserDefaults standardUserDefaults] stringForKey:USERID]];  </li>
<li>//组合  </li>
<li>[mes addChild:body];  </li>
<li></li>
<li>//发送消息  </li>
<li>[[self xmppStream] sendElement:mes];  </li>
<li></li>
<li>self.messageTextField.text = @””;  </li>
<li>[self.messageTextField resignFirstResponder];  </li>
<li></li>
<li>NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];  </li>
<li></li>
<li>[dictionary setObject:message forKey:@”msg”];  </li>
<li>[dictionary setObject:@”you” forKey:@”sender”];  </li>
<li></li>
<li>[messages addObject:dictionary];  </li>
<li></li>
<li>//重新刷新tableView  </li>
<li>[self.tView reloadData];  </li>
<li></li>
<li>}  </li>
<li></li>
<li></li>
<li>}  </li>
</ol>
<p>上面都加了注释，大家应该能明白，接下来还有一个章节，我们会对发送的消息在界面进行美化，跟苹果自带的消息一样。谢谢大家有耐心看完，我这个人比较不喜欢打字，所以有的地方注释比较少，希望大家别介意，还有希望大家能够多多支持， 以后会接着介绍XMPP文件传输之类的内容。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之社交软件/">iOS应用开发之社交软件</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/iphone/">iphone</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/XMPP/">XMPP</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-07T07:27:00.000Z"><a href="/2014/01/07/基于XMPP的IOS聊天客户端程序(IOS端一)/">1月 7 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/07/基于XMPP的IOS聊天客户端程序(IOS端一)/">基于XMPP的IOS聊天客户端程序(IOS端一)</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><a href="http://blog.csdn.net/kangx6/article/details/7740135" target="_blank" rel="external">本文转自：http://blog.csdn.net/kangx6/article/details/7740135</a></p>
<p>介绍完了服务器，这篇我们就要介绍重点了，写我们自己的IOS客户端程序<br>先看一下我们完成的效果图<br><img src="http://my.csdn.net/uploads/201207/13/1342164575_2627.png" alt=""><img src="http://my.csdn.net/uploads/201207/13/1342164555_1035.png" alt=""></p>
<p><img src="http://my.csdn.net/uploads/201207/13/1342164590_1834.png" alt=""></p>
<p>首先下载xmppframework这个框架,<a href="https://github.com/robbiehanson/XMPPFramework" target="_blank" rel="external">下载</a><br><img src="http://my.csdn.net/uploads/201207/12/1342074297_5170.png" alt=""><br>点ZIP下载<br>接下来，用Xcode新建一个工程<br>将以下这些文件拖入新建工程中<br><img src="http://my.csdn.net/uploads/201207/12/1342077119_4696.png" alt=""></p>
<p><img src="http://my.csdn.net/uploads/201207/12/1342074830_1517.png" alt=""></p>
<p>加入framework<br><img src="http://my.csdn.net/uploads/201207/12/1342077141_6924.png" alt=""></p>
<p>并设置<br><img src="http://my.csdn.net/uploads/201207/12/1342077154_5471.png" alt=""><br>到这里我们就全部设好了，跑一下试试，看有没有错呢<br>如果没有错的话，我们的xmppframework就加入成功了。</p>
<p>我们设置我们的页面如下图：<br><img src="http://my.csdn.net/uploads/201207/12/1342077701_5655.png" alt=""></p>
<p>我们的KKViewController.h</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7740135#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7740135#" title="copy" target="_blank" rel="external">copy</a>1. #import <uikit uikit.h="">  </uikit></p>
<ol>
<li></li>
<li>@interface KKViewController : UIViewController<uitableviewdelegate, uitableviewdatasource="">  </uitableviewdelegate,></li>
<li></li>
<li>@property (strong, nonatomic) IBOutlet UITableView *tView;  </li>
<li></li>
<li><ul>
<li>(IBAction)Account:(id)sender;  </li>
</ul>
</li>
<li>@end  </li>
</ol>
<p>KKViewController.m</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7740135#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7740135#" title="copy" target="_blank" rel="external">copy</a>1. #import “KKViewController.h”  </p>
<ol>
<li></li>
<li>@interface KKViewController (){  </li>
<li></li>
<li>//在线用户  </li>
<li>NSMutableArray *onlineUsers;  </li>
<li></li>
<li>}  </li>
<li></li>
<li>@end  </li>
<li></li>
<li>@implementation KKViewController  </li>
<li>@synthesize tView;  </li>
<li></li>
<li><ul>
<li>(void)viewDidLoad  </li>
</ul>
</li>
<li>{  </li>
<li>[super viewDidLoad];  </li>
<li>self.tView.delegate = self;  </li>
<li>self.tView.dataSource = self;  </li>
<li></li>
<li>onlineUsers = [NSMutableArray array];  </li>
<li>// Do any additional setup after loading the view, typically from a nib.  </li>
<li>}  </li>
<li></li>
<li><ul>
<li>(void)viewDidUnload  </li>
</ul>
</li>
<li>{  </li>
<li>[self setTView:nil];  </li>
<li>[super viewDidUnload];  </li>
<li>// Release any retained subviews of the main view.  </li>
<li>}  </li>
<li></li>
<li><ul>
<li>(BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation  </li>
</ul>
</li>
<li>{  </li>
<li>return (interfaceOrientation != UIInterfaceOrientationPortraitUpsideDown);  </li>
<li>}  </li>
<li></li>
<li><ul>
<li>(IBAction)Account:(id)sender {  </li>
</ul>
</li>
<li>}  </li>
<li></li>
<li><h1 id="pragma_mark_UITableViewDataSource">pragma mark UITableViewDataSource</h1>
</li>
<li></li>
<li>-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{  </li>
<li></li>
<li>return [onlineUsers count];  </li>
<li>}  </li>
<li></li>
<li>-(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{  </li>
<li></li>
<li>static NSString *identifier = @”userCell”;  </li>
<li>UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];  </li>
<li>if (cell == nil) {  </li>
<li>cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];  </li>
<li>}  </li>
<li></li>
<li></li>
<li>return cell;  </li>
<li></li>
<li></li>
<li>}  </li>
<li></li>
<li><ul>
<li>(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{  </li>
</ul>
</li>
<li></li>
<li>return 1;  </li>
<li>}  </li>
<li></li>
<li><h1 id="pragma_mark_UITableViewDelegate">pragma mark UITableViewDelegate</h1>
</li>
<li>-(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath{  </li>
<li></li>
<li></li>
<li>}  </li>
<li></li>
<li></li>
<li>@end  </li>
</ol>
<p>这里的代码相信大家学过UITableView的话应该很熟悉了，如果不知道的话，就查一下UITableView的简单应用学习一下吧<br>接下来是登录的页面<br><img src="http://my.csdn.net/uploads/201207/13/1342164193_4863.png" alt=""></p>
<p>KKLoginController.m</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7740135#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7740135#" title="copy" target="_blank" rel="external">copy</a>1. - (IBAction)LoginButton:(id)sender {  </p>
<ol>
<li></li>
<li>if ([self validateWithUser:userTextField.text andPass:passTextField.text andServer:serverTextField.text]) {  </li>
<li></li>
<li>NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];  </li>
<li>[defaults setObject:self.userTextField.text forKey:USERID];  </li>
<li>[defaults setObject:self.passTextField.text forKey:PASS];  </li>
<li>[defaults setObject:self.serverTextField.text forKey:SERVER];  </li>
<li>//保存  </li>
<li>[defaults synchronize];  </li>
<li></li>
<li>[self dismissModalViewControllerAnimated:YES];  </li>
<li>}else {  </li>
<li>UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@”提示” message:@”请输入用户名，密码和服务器” delegate:nil cancelButtonTitle:@”确定” otherButtonTitles:nil, nil];  </li>
<li>[alert show];  </li>
<li>}  </li>
<li></li>
<li>}  </li>
<li></li>
<li><ul>
<li>(IBAction)closeButton:(id)sender {  </li>
</ul>
</li>
<li></li>
<li>[self dismissModalViewControllerAnimated:YES];  </li>
<li>}  </li>
<li></li>
<li>-(BOOL)validateWithUser:(NSString <em>)userText andPass:(NSString </em>)passText andServer:(NSString *)serverText{  </li>
<li></li>
<li>if (userText.length &gt; 0 &amp;&amp; passText.length &gt; 0 &amp;&amp; serverText.length &gt; 0) {  </li>
<li>return YES;  </li>
<li>}  </li>
<li></li>
<li>return NO;  </li>
<li>}  </li>
</ol>
<p>下面是聊天的页面<br><img src="http://my.csdn.net/uploads/201207/13/1342164714_9508.png" alt=""><br>这里着重的还是UITableView<br>KKChatController.m</p>
<p><strong>[java]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7740135#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7740135#" title="copy" target="_blank" rel="external">copy</a>1. -(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{  </p>
<ol>
<li></li>
<li>return 1;  </li>
<li>}  </li>
<li></li>
<li>-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{  </li>
<li>return [messages count];  </li>
<li>}  </li>
<li></li>
<li>-(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{  </li>
<li></li>
<li>static NSString *identifier = @”msgCell”;  </li>
<li></li>
<li>UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];  </li>
<li></li>
<li>if (cell == nil) {  </li>
<li>cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:identifier];  </li>
<li>}  </li>
<li></li>
<li>NSMutableDictionary *dict = [messages objectAtIndex:indexPath.row];  </li>
<li></li>
<li>cell.textLabel.text = [dict objectForKey:@”msg”];  </li>
<li>cell.detailTextLabel.text = [dict objectForKey:@”sender”];  </li>
<li>cell.accessoryType = UITableViewCellAccessoryNone;  </li>
<li></li>
<li>return cell;  </li>
<li></li>
<li>}  </li>
</ol>
<p>这些都比较简单，相信大家应该都能看得懂<br>把这些都设置好以后，我们就要着重介绍XMPP了，怕太长了，接下一章吧。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之社交软件/">iOS应用开发之社交软件</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/iphone/">iphone</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/XMPP/">XMPP</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-01-07T07:25:00.000Z"><a href="/2014/01/07/IOS开发之XMPP个人服务器搭建/">1月 7 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/01/07/IOS开发之XMPP个人服务器搭建/">IOS开发之XMPP个人服务器搭建</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>本文转自：<a href="http://blog.csdn.net/kangx6/article/details/7739828" target="_blank" rel="external">http://blog.csdn.net/kangx6/article/details/7739828</a><br>最近看了关于XMPP的框架，以文本聊天为例，需要发送的消息为：</p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/kangx6/article/details/7739828#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/kangx6/article/details/7739828#" title="copy" target="_blank" rel="external">copy</a>1. <message type="chat" from="kang@server.com" to="test@server.com">  </message></p>
<ol>
<li><body>helloWord</body>  </li>
<li>  </li>
</ol>
<p>基中from是从哪个用户发送的消息，to是发给谁的消息，XMPP的用户都是以邮箱形式。body就是我们发送的消息文本。<br>好了，说到这里，我们就来开发一个基于XMPP的IOS聊天客户端程序，首先我们需要XMPP服务器，这里，我就拿本机做服务器，首先从<a href="http://xmpp.org/xmpp-software/servers/" target="_blank" rel="external">xmpp Server</a>下载ejabberd这个服务器，ejabberd支持Linux<br> / Mac OS X / Solaris / Windows，所以任何操作系统都可以做我们的聊天服务器。好了，下载完后，一步一步安装就可以了，这里我们要注意一下<br><img src="http://my.csdn.net/uploads/201207/12/1342070037_2898.png" alt=""></p>
<p>这里我们的服务器就是dpc1338a（一般就是机器名，默认就可以了，不需要改），每台机器的用户名都不一样，这里的服务器域名就是机器名，这个我们需要记住哦<br>接着一步一步，还要设置管理员密码，密码当然也需要记住了，不然我们没办法登录管理员页面去。<br>好了，安装完后启动，显示如下：<br><img src="http://my.csdn.net/uploads/201207/12/1342070399_4001.png" alt=""><br>我们点击admin interface，会要求我们输入用户名和密码：<br><img src="http://my.csdn.net/uploads/201207/12/1342070515_1408.png" alt=""></p>
<p>这里用户名是前面我们安装的时候有一个管理员名，将管理员名跟我们的服务器组合就可以了，我这里是admin@dpc1338a，每一台机器都不一样，不要照抄哦，这样你是登录不了的，密码就是安装的时候设置的密码<br>登录成功后就会显示如下页面：<br><img src="http://my.csdn.net/uploads/201207/12/1342070689_8102.png" alt=""></p>
<p>这里我们需要解释的就是&lt;访问控制列表&gt;，这里是设置管理员的，我们可以在这里创建其他管理员，这个不是我们的重点，我们的重点是&lt;虚拟主机&gt;<br>点开&lt;虚拟主机&gt;，下面有一个<dpc1338a>，也点开</dpc1338a></p>
<p><img src="http://my.csdn.net/uploads/201207/12/1342071704_5702.png" alt=""></p>
<p>这里有一个&lt;用户&gt;，我们需要创建几个用户来进行数据交互。<br>我创建了kang@dpc1338a，test@dpc1338a, abc@dpc1338a这几个用户，过一会我们就用这几个用户进行聊天<br><img src="http://my.csdn.net/uploads/201207/12/1342071856_8163.png" alt=""></p>
<p>好了，服务器装好了以后，我们就需要下载个客户端来进行聊天，这里有一些客户端工具<br><a href="http://xmpp.org/xmpp-software/clients/" target="_blank" rel="external">http://xmpp.org/xmpp-software/clients/</a>，这里我们主要推荐MAC用Adium,Windows用Citron，下一章我们要介绍IOS的xmpp<br> framework。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之社交软件/">iOS应用开发之社交软件</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios/">ios</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/xmpp/">xmpp</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  
    <form>
      <input id="st-search-input" type="search" placeholder="Search">
    </form>
    <div id="st-results-container"></div>
  
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <div class="entry">
    
      <span><a href="/tags/2d/">2d<small>1</small></a></span>
    
      <span><a href="/tags/AFNetworking/">AFNetworking<small>2</small></a></span>
    
      <span><a href="/tags/CoreData/">CoreData<small>2</small></a></span>
    
      <span><a href="/tags/Drawing/">Drawing<small>1</small></a></span>
    
      <span><a href="/tags/MagicalRecord/">MagicalRecord<small>1</small></a></span>
    
      <span><a href="/tags/NSDate/">NSDate<small>1</small></a></span>
    
      <span><a href="/tags/NSString/">NSString<small>1</small></a></span>
    
      <span><a href="/tags/Swift/">Swift<small>9</small></a></span>
    
      <span><a href="/tags/UIAlertView/">UIAlertView<small>1</small></a></span>
    
      <span><a href="/tags/UITabBarController/">UITabBarController<small>1</small></a></span>
    
      <span><a href="/tags/UITableViewControlle/">UITableViewControlle<small>1</small></a></span>
    
      <span><a href="/tags/UIWebView/">UIWebView<small>1</small></a></span>
    
      <span><a href="/tags/URL-Scheme/">URL Scheme<small>1</small></a></span>
    
      <span><a href="/tags/URL编码/">URL编码<small>1</small></a></span>
    
      <span><a href="/tags/XMPP/">XMPP<small>3</small></a></span>
    
      <span><a href="/tags/Xcode5-1/">Xcode5.1<small>1</small></a></span>
    
      <span><a href="/tags/api/">api<small>5</small></a></span>
    
      <span><a href="/tags/appStore审核/">appStore审核<small>1</small></a></span>
    
      <span><a href="/tags/block/">block<small>1</small></a></span>
    
      <span><a href="/tags/bytearray/">bytearray<small>1</small></a></span>
    
      <span><a href="/tags/cell自适应高度/">cell自适应高度<small>1</small></a></span>
    
      <span><a href="/tags/cocos2d/">cocos2d<small>3</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发font/">fontfontiPhone开发font<small>1</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发fontfont/">fontfontiPhone开发fontfont<small>1</small></a></span>
    
      <span><a href="/tags/fontfontios的fontfont/">fontfontios的fontfont<small>2</small></a></span>
    
      <span><a href="/tags/fontfont动画fontfont/">fontfont动画fontfont<small>1</small></a></span>
    
      <span><a href="/tags/framework/">framework<small>1</small></a></span>
    
      <span><a href="/tags/iOS8/">iOS8<small>2</small></a></span>
    
      <span><a href="/tags/iOS8-1-1/">iOS8.1.1<small>1</small></a></span>
    
      <span><a href="/tags/iOS8定位/">iOS8定位<small>1</small></a></span>
    
      <span><a href="/tags/iOS国际化/">iOS国际化<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之app上架/">iOS应用开发之app上架<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之第三方框架/">iOS应用开发之第三方框架<small>1</small></a></span>
    
      <span><a href="/tags/iOS开发/">iOS开发<small>5</small></a></span>
    
      <span><a href="/tags/iOS自定义Tabbar/">iOS自定义Tabbar<small>1</small></a></span>
    
      <span><a href="/tags/ios/">ios<small>53</small></a></span>
    
      <span><a href="/tags/ios7/">ios7<small>1</small></a></span>
    
      <span><a href="/tags/ios7适配/">ios7适配<small>1</small></a></span>
    
      <span><a href="/tags/ios国际化/">ios国际化<small>1</small></a></span>
    
      <span><a href="/tags/ios开发/">ios开发<small>27</small></a></span>
    
      <span><a href="/tags/iphone/">iphone<small>4</small></a></span>
    
      <span><a href="/tags/iphone开发/">iphone开发<small>59</small></a></span>
    
      <span><a href="/tags/itunes/">itunes<small>1</small></a></span>
    
      <span><a href="/tags/objective-c/">objective-c<small>1</small></a></span>
    
      <span><a href="/tags/svn/">svn<small>1</small></a></span>
    
      <span><a href="/tags/uiimage/">uiimage<small>2</small></a></span>
    
      <span><a href="/tags/uitableview/">uitableview<small>1</small></a></span>
    
      <span><a href="/tags/uitableviewcell/">uitableviewcell<small>1</small></a></span>
    
      <span><a href="/tags/uitextfield/">uitextfield<small>1</small></a></span>
    
      <span><a href="/tags/uiview/">uiview<small>3</small></a></span>
    
      <span><a href="/tags/uiviewcontroller/">uiviewcontroller<small>1</small></a></span>
    
      <span><a href="/tags/uiwebview/">uiwebview<small>1</small></a></span>
    
      <span><a href="/tags/xcode/">xcode<small>2</small></a></span>
    
      <span><a href="/tags/xmpp/">xmpp<small>1</small></a></span>
    
      <span><a href="/tags/二维码/">二维码<small>1</small></a></span>
    
      <span><a href="/tags/企业/">企业<small>1</small></a></span>
    
      <span><a href="/tags/动画/">动画<small>5</small></a></span>
    
      <span><a href="/tags/国际化/">国际化<small>1</small></a></span>
    
      <span><a href="/tags/在线工具/">在线工具<small>1</small></a></span>
    
      <span><a href="/tags/多线程/">多线程<small>1</small></a></span>
    
      <span><a href="/tags/存储/">存储<small>1</small></a></span>
    
      <span><a href="/tags/宏/">宏<small>1</small></a></span>
    
      <span><a href="/tags/导航/">导航<small>1</small></a></span>
    
      <span><a href="/tags/屏幕旋转/">屏幕旋转<small>2</small></a></span>
    
      <span><a href="/tags/应用程序/">应用程序<small>2</small></a></span>
    
      <span><a href="/tags/微信开放平台ios/">微信开放平台ios<small>1</small></a></span>
    
      <span><a href="/tags/打开AppStore/">打开AppStore<small>1</small></a></span>
    
      <span><a href="/tags/数据库/">数据库<small>1</small></a></span>
    
      <span><a href="/tags/缓存/">缓存<small>1</small></a></span>
    
      <span><a href="/tags/聊天/">聊天<small>1</small></a></span>
    
      <span><a href="/tags/苹果应用商店/">苹果应用商店<small>1</small></a></span>
    
      <span><a href="/tags/获取iP地址/">获取iP地址<small>1</small></a></span>
    
  </div>
</div>




  <script type="text/javascript">
    (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
    })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

    _st('install','6xH6jcZvsZxn2a9rcU4t');
  </script>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div id="foot-nav">
  <ul class="social">
    
      <li><a class="github" href="https://github.com/DaiXiang" title="github">github</a></li>
    
      <li><a class="rss" href="/atom.xml" title="rss">rss</a></li>
    
  </ul>
</div>
<div>
  
    &copy; 2014 尹现伟
  
</div>
<div class="clearfix"></div></footer>
  


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<script type="text/javascript">
  function navbar() {
    var top = $('#nav-top').innerHeight();
    $('#header').css('min-height', top);
  }
  navbar();
  $(window).resize(navbar);
</script>
<div id="totop" class="footer-btn">
  <a title="Return to Top"><img src="/img/scrollup.png"/></a>
</div>

<script type="text/javascript">
  $(function(){ 
	// When to show the scroll link
	// higher number = scroll link appears further down the page   
	var upperLimit = 800;
	
	// Our scroll link element
	var scrollElem = $('#totop');
   
	// Scroll to top speed
	var scrollSpeed = 500;
   
	// Show and hide the scroll to top link based on scroll position   
	scrollElem.hide();
	$(window).scroll(function () {            
		var scrollTop = $(document).scrollTop();       
		if ( scrollTop > upperLimit ) {
		  $(scrollElem).stop().fadeTo(300, 1); // fade back in
		  $(scrollElem).animate({bottom: "50px"}, { queue: false, duration: 10 });
		} else {
		  $(scrollElem).stop().fadeTo(300, 0); // fade out
	      $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
			
		}
	});

	// Scroll to top animation on click
	$(scrollElem).click(function(){
	  $('html, body').animate({scrollTop:0}, scrollSpeed);
	  $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
	  return false;
	});
  });
</script>
</body>
</html>