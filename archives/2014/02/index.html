<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014/2 | 一枝红杏出墙来</title>
  <meta name="author" content="尹现伟">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="一枝红杏出墙来"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="shortcut icon">
  <link rel="alternate" href="/atom.xml" title="一枝红杏出墙来" type="application/atom+xml">
  <link rel="stylesheet" href="/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
  

</head>


<body>
  <header id="header" class="inner"><div id="nav-top">
  <div class="alignleft main-title">
    <h1>一枝红杏出墙来</h1>
    <h2></h2>
  </div>
  <nav id="main-nav" class="alignright">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2014/2</h2>


  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-28T15:39:00.000Z"><a href="/2014/02/28/URL Scheme/">2月 28 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/28/URL Scheme/">URL Scheme</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>iOS 的设计思路是原则上禁止不同的应用程序之间相互访问彼此的数据。虽然对于像我这样的桌面应用开发人员而言，不能访问程序以外的数据是不能想象的。但是从安全角度来说不失为一个有效的策略。不过凡事总有例外，所以乔布斯还是为程序间通讯开放了几个接口。</p>
<h2 id="URL_Scheme">URL Scheme</h2>
<p>iOS 上的应用程序可以通过向其它应用程序发送一个URL 格式的字符串来向其发送数据。这个特性通常用于在应用程序中启动另外一个应用程序来打开一种特定格式的数据。例如：你的程序可以向Map 发送一个URL ，要求其打开指定的地图；或者在邮件程序里向Adobe Reader 发送一个URL ，要求其打开指定的PDF 文件。</p>
<p>iOS 预定义了如下几种URL Scheme 。<br>Mail:          <a href="mailto:frank@wwdcdemo.example.com" target="_blank" rel="external">mailto:frank@wwdcdemo.example.com</a><br>Tel:            <a href="tel:1-408-555-5555" target="_blank" rel="external">tel:1-408-555-5555</a><br>SMS:        1-408-555-1212<br>Map:                  <a href="http://maps.google.com/maps?q=cupertino" target="_blank" rel="external">http://maps.google.com/maps?q=cupertino</a><br>YouTube: <a href="http://www.youtube.com/watch?v=VIDEO_IDENTIFIER" target="_blank" rel="external">http://www.youtube.com/watch?v=VIDEO_IDENTIFIER</a><br>iTunes:<br><a href="http://phobos.apple.com/WebObjects/MZStore.woa/wa/viewAlbum?i=156093464&amp;id=156093462&amp;s=143441" target="_blank" rel="external">http://phobos.apple.com/WebObjects/MZStore.woa/wa/viewAlbum?i=156093464&amp;id=156093462&amp;s=143441</a></p>
<p>你也可以自定义URL Scheme 。需要注意的是：在多个应用程序注册了同一种URL Scheme 的时候，iOS 系统程序的优先级高于第三方开发程序。但是如果一种URL Scheme 的注册应用程序都是第三方开发的，那么这些程序的优先级关系是不确定的。<br>(1)  注册URL Scheme<br>在应用程序的Info.plist 中添加CFBundleURLTypes 项。<br><em><key><strong>CFBundleURLTypes</strong> </key></em><br><em><array></array></em></p>
<ul>
<li><dict>*</dict></li>
<li><key><strong>CFBundleURLName</strong> </key>*</li>
<li><string>com.acme.todolist</string>*</li>
<li><key><strong>CFBundleURLScheme</strong> </key>*</li>
<li><array>*</array></li>
<li><string>todolist</string>*</li>
<li>*</li>
<li><em>
</em>*</li>
</ul>
<p>(2)  发送 URL Scheme<br><strong><em>NSURL **</em></strong>myURL = [NSURL URLWithString:@”URL Scheme”];<em>
</em>[[<strong>UIApplication sharedApplication</strong> ] openURL:myURL];<em>
</em><br>*<br>(3)    接收 URL Scheme<br>URL Schemes 由系统发送给 application delegate ，而 delegate 通常应该实现如下几个代理函数：<br>l  application:didFinishLaunchingWithOptions:<br>判断是否应该启动程序来处理传入的 URL Scheme 。这个函数只在程序从 not running 到running 时被调用。如果程序在 URL Scheme 传入时处于 Background 或者 Suspending 状态，那么校验工作应该在下面两个代理函数中实现。<br>l  application:openURL:sourceApplication:annotation<br>在 4.2 及之后版本的 iOS 中实现。<br>l  application:handleOpenURL:<br>在 4.1 及之前版本的 iOS 中实现。<br>(4)    安全性<br>            参考 Secure Coding Guide 中 Validating Input 部分。<br>本文转自:<a href="http://blog.csdn.net/flower4wine/article/details/6454957" target="_blank" rel="external">http://blog.csdn.net/flower4wine/article/details/6454957</a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/URL-Scheme/">URL Scheme</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-27T02:12:00.000Z"><a href="/2014/02/27/iOS 应用程序内部国际化，不跟随系统语言/">2月 27 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/27/iOS 应用程序内部国际化，不跟随系统语言/">iOS 应用程序内部国际化，不跟随系统语言</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>前言：网络上关于iOS国际化的文章很多，但基本上都是基于跟随系统语言的国际化，笔者就不赘述了-0 –<br>今天要讲的是不跟随系统的切换语言版本方案，即程序内部的切换语言版本方案。</p>
<p><strong>一、总则：</strong><br>       应用内部语言不跟随系统语言，由应用自己进行控制，通过配置多个语言文件，根据用户的选择动态获取不同文件夹下的语言文件，显示在界面上。<br>       最后把用户选择的语言持久化到本地，下次运行时读取。</p>
<p><strong>二、应用内的国际化</strong><br><strong>1、新建工程</strong><br>      新建Single View Application工程，取名为MyInternational。<br>                                                      <img src="http://img.blog.csdn.net/20130925230149234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZzg0NTYyMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>2、添加多语言文件</strong><br>      我们选择使用自己的语言文件，而不是系统的localizable.string，因为在项目开发使用svn时，多人操作同一文件可能会造成冲突。<br>在Resource中添加新的Strings File：<br>                                                            <img src="http://img.blog.csdn.net/20130925230247031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZzg0NTYyMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<pre><code>  取名为hello（记得Targets要勾选项目）
                                                             ![](http:<span class="comment">//img.blog.csdn.net/20130925230328453)</span>

  新建完成之后会生成hello.<span class="keyword">string</span>文件，把它拖进Supporting Files里。
</code></pre><p><strong>3、配置hello.string国际化</strong><br>      首先配置刚才的hello.string文件。<br>      点击hello.strings文件，点击圈中的Make localized（本地化）。<br>                                                                             <img src="http://img.blog.csdn.net/20130925230418656" alt=""></p>
<pre><code>  只有English，没关系点击确定。
                                                            ![](http:<span class="comment">//img.blog.csdn.net/20130925230550453)</span>
</code></pre><p><strong>4、配置项目国际化</strong><br>      网络上很多配置方法不靠谱，因为新版的Xcode位置“+”号的位置换了，这里教大家正确的方法，点击项目—&gt;选择Project—&gt;选择Info—&gt;点击“+”号。<br>                                                     <img src="http://img.blog.csdn.net/20130925230623281" alt=""></p>
<pre><code>  点击“+”号后，添加中文，当然也可以添加其他的语言，弹出对话框，infoPlist是配置系统的国际化文件，可以配置图标之类的多语言环境，不属于本文范围，nib文件看需要配，这里选择不配。
                                                  ![](http:<span class="comment">//img.blog.csdn.net/20130925230628156)</span>

  配置完成之后，再看hello.<span class="keyword">string</span>便分成了两个文件。
                                                                             ![](http:<span class="comment">//img.blog.csdn.net/20130925230701593)</span>
  完成上面的四步便完成了项目内的多语言环境配置，下面来看看代码怎么写。
</code></pre><p><strong>5、添加需要的字符串</strong><br>      分别在hello.strings（English）与hello.strings（Chinese）里面添加对应语言的字符串。<br>      字符串的格式为“key”=“value”;键值对（别忘记分号！）<br>      接下来配置项目需要的字符串，一个用于lable的显示，一个用于button的显示。</p>
<pre><code>hello.strings（English）
<span class="string">"invite"</span> =<span class="string">"hello atany,come to join in us!"</span>;
</code></pre><p>   “buttonInfo” =”change Language”;</p>
<pre><code>hello.strings（Chinese）
<span class="string">"invite"</span> =<span class="string">"你好 atany,快来加入我们吧！"</span>;
<span class="string">"buttonInfo"</span> =<span class="string">"切换语言"</span>;
</code></pre><p><strong>6、看看流程</strong><br>                                                     <img src="http://img.blog.csdn.net/20130925230801343" alt=""></p>
<p>【实现思路:】<br>      在初始化首个Controller的时候，进行应用语言的加载。首次加载因为userLanguage（应用内语言）不存在，则使用系统当前的语言，保存到userlanguage，下次直接读。读出来之后，获取到对应文件路径，得到文件的索引，储存到工具类InternationalControl的静态变量bundle中。<br>其他地方需要用字符串时，用工具类获得bundle即可读取相应文件中的字符串。</p>
<p><strong>7、新建工具类InternationalControl</strong><br>                           <img src="http://img.blog.csdn.net/20130925230849375" alt=""></p>
<p><strong>InternationalControl.h</strong><br><strong>[cpp]</strong> <a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="copy" target="_blank" rel="external">copy</a>1. #import <foundation foundation.h="">  </foundation></p>
<ol>
<li></li>
<li><h1 id="import_">import <uikit uikit.h=""></uikit></h1>
</li>
<li></li>
<li>@interface InternationalControl : NSObject  </li>
<li></li>
<li>+(NSBundle *)bundle;//获取当前资源文件  </li>
<li></li>
<li>+(void)initUserLanguage;//初始化语言文件  </li>
<li></li>
<li>+(NSString *)userLanguage;//获取应用当前语言  </li>
<li></li>
<li>+(void)setUserlanguage:(NSString *)language;//设置当前语言  </li>
<li></li>
<li>@end  </li>
</ol>
<p><strong>InternationalControl.m</strong><br>1）创建静态变量bundle，以及获取方法bundle（注：此处不要使用getBundle）。</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="copy" target="_blank" rel="external">copy</a>1. static NSBundle *bundle = nil;  </p>
<ol>
<li></li>
<li><ul>
<li>( NSBundle * )bundle{  </li>
</ul>
</li>
<li></li>
<li>return bundle;  </li>
<li></li>
<li>}  </li>
</ol>
<p>2）初始化方法：<br> userLanguage储存在NSUserDefaults中，首次加载时要检测是否存在，如果不存在的话读AppleLanguages，并赋值给userLanguage。<br><strong>[cpp]</strong> <a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="copy" target="_blank" rel="external">copy</a>1. +(void)initUserLanguage{  </p>
<ol>
<li></li>
<li>NSUserDefaults *def = [NSUserDefaults standardUserDefaults];  </li>
<li></li>
<li>NSString *string = [def valueForKey:@”userLanguage”];  </li>
<li></li>
<li>if(string.length == 0){  </li>
<li></li>
<li>//获取系统当前语言版本(中文zh-Hans,英文en)  </li>
<li></li>
<li>NSArray* languages = [def objectForKey:@”AppleLanguages”];  </li>
<li></li>
<li><pre class="cpp" name="code">        NSString *current = [languages objectAtIndex:0];  </pre></li>
<li></li>
<li>string = current;  </li>
<li></li>
<li>[def setValue:current forKey:@”userLanguage”];  </li>
<li></li>
<li>[def synchronize];//持久化，不加的话不会保存  </li>
<li>}  </li>
<li></li>
<li>//获取文件路径  </li>
<li>NSString *path = [[NSBundle mainBundle] pathForResource:string ofType:@”lproj”];  </li>
<li></li>
<li>bundle = [NSBundle bundleWithPath:path];//生成bundle  </li>
<li>}  </li>
<li>  </li>
</ol>
<p>3）获得当前语言方法<br><strong>[cpp]</strong> <a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="copy" target="_blank" rel="external">copy</a>1. +(NSString *)userLanguage{  </p>
<ol>
<li></li>
<li>NSUserDefaults *def = [NSUserDefaults standardUserDefaults];  </li>
<li></li>
<li>NSString *language = [def valueForKey:@”userLanguage”];  </li>
<li></li>
<li>return language;  </li>
<li>}  </li>
</ol>
<p>4）设置语言方法<br><strong>[cpp]</strong> <a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="copy" target="_blank" rel="external">copy</a>1. +(void)setUserlanguage:(NSString *)language{  </p>
<ol>
<li></li>
<li>NSUserDefaults *def = [NSUserDefaults standardUserDefaults];  </li>
<li></li>
<li>//1.第一步改变bundle的值  </li>
<li>NSString *path = [[NSBundle mainBundle] pathForResource:language ofType:@”lproj” ];  </li>
<li></li>
<li>bundle = [NSBundle bundleWithPath:path];  </li>
<li></li>
<li>//2.持久化  </li>
<li>[def setValue:language forKey:@”userLanguage”];  </li>
<li></li>
<li>[def synchronize];  </li>
<li>}  </li>
</ol>
<p><strong>8、拖nib，配置点击事件</strong><br>一个button，一个label，button用于切换语言，label用于显示信息。<br>                                                                        <img src="http://img.blog.csdn.net/20130925231125046" alt=""></p>
<p><strong>9、配置加载的第一个Controller，这里是YGViewController</strong><br><strong>YGViewController.h</strong><br><strong>[cpp]</strong> <a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="copy" target="_blank" rel="external">copy</a>1. #import <uikit uikit.h="">  </uikit></p>
<ol>
<li></li>
<li>@interface YGViewController : UIViewController  </li>
<li></li>
<li>@property (retain, nonatomic) IBOutlet UILabel *inviteLabel;//label  </li>
<li></li>
<li><ul>
<li>(IBAction)changeLanguage:(id)sender;//点击事件  </li>
</ul>
</li>
<li></li>
<li>@property (retain, nonatomic) IBOutlet UIButton *btChange;//button  </li>
<li></li>
<li>@end  </li>
</ol>
<p><strong>
</strong><br><strong>YGViewController.m</strong><br>1）加载：<br><strong>[cpp]</strong> <a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="copy" target="_blank" rel="external">copy</a>1. - (void)viewDidLoad  </p>
<ol>
<li>{  </li>
<li>//注册通知，用于接收改变语言的通知  </li>
<li>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeLanguage) name:@”changeLanguage” object:nil];  </li>
<li></li>
<li>[InternationalControl initUserLanguage];//初始化应用语言  </li>
<li></li>
<li>NSBundle *bundle = [InternationalControl bundle];  </li>
<li></li>
<li>NSString *inviteMsg = [bundle localizedStringForKey:@”invite” value:nil table:@”hello”];  </li>
<li></li>
<li>NSString *buttonInfo = [bundle localizedStringForKey:@”buttonInfo” value:nil table:@”hello”];//table为hello.string的文件名  </li>
<li></li>
<li>[_btChange setTitle:buttonInfo forState:UIControlStateNormal];  </li>
<li></li>
<li>_inviteLabel.text = inviteMsg;  </li>
<li></li>
<li>[super viewDidLoad];  </li>
<li>}  </li>
</ol>
<p>2）点击修改语言方法<br><strong>[cpp]</strong> <a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="copy" target="_blank" rel="external">copy</a>1. - (IBAction)changeLanguage:(id)sender {  </p>
<ol>
<li></li>
<li>NSString *lan = [InternationalControl userLanguage];  </li>
<li></li>
<li>if([lan isEqualToString:@”en”]){//判断当前的语言，进行改变  </li>
<li></li>
<li>[InternationalControl setUserlanguage:@”zh-Hans”];  </li>
<li></li>
<li>}else{  </li>
<li></li>
<li>[InternationalControl setUserlanguage:@”en”];  </li>
<li>}  </li>
<li></li>
<li>//改变完成之后发送通知，告诉其他页面修改完成，提示刷新界面  </li>
<li>[[NSNotificationCenter defaultCenter] postNotificationName:@”changeLanguage” object:nil];  </li>
<li>}  </li>
</ol>
<p>3）接收到通知执行方法，刷新界面<br><strong>[cpp]</strong> <a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/yang8456211/article/details/12031667#" title="copy" target="_blank" rel="external">copy</a>1. -(void)changeLanguage{  </p>
<ol>
<li></li>
<li>[_btChange setTitle:[[InternationalControl bundle] localizedStringForKey:@”buttonInfo” value:nil table:@”hello”] forState:UIControlStateNormal];  </li>
<li></li>
<li>_inviteLabel.text =[[InternationalControl bundle] localizedStringForKey:@”invite” value:nil table:@”hello”];  </li>
<li>}  </li>
</ol>
<p>如果有多个界面的话，需要每个界面都配置接收通知，用于修改界面。</p>
<p><strong>10、运行界面</strong><br>                                                                             <img src="http://img.blog.csdn.net/20130925231323250" alt=""></p>
<pre><code>                                                                         ![](http:<span class="comment">//img.blog.csdn.net/20130925231423796)</span>
</code></pre><p>可以看到点击切换语言之后，语言切换成功。<br>退出程序再次进入，保留了上次选择的语言。</p>
<p>atany原创，转载请注明博主与博文链接,3Q<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/tongue.gif" alt="吐舌头"><br> <a href="http://blog.csdn.net/yang8456211/article/details/12031667" target="_blank" rel="external">http://blog.csdn.net/yang8456211/article/details/12031667</a><a href="http://blog.csdn.net/yang8456211/article/details/11783823" target="_blank" rel="external">
</a><br> —— by atany</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iOS国际化/">iOS国际化</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-26T06:16:00.000Z"><a href="/2014/02/26/IOS离线缓存致内存和本地的方法/">2月 26 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/26/IOS离线缓存致内存和本地的方法/">IOS离线缓存致内存和本地的方法</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>缓存由四个文件组成。</p>
<p>FlashDiskCacheManager.h<br>FlashDiskCacheManager.m</p>
<p>这个类是以单例的模式提供的，您可以在您想要缓存的地方来share</p>
<p>URLCacheElement.h<br>URLCacheElement.m</p>
<p>这个类您永远都不要使用，每一个缓存就是一个URLCacheElement的对象，然后归档到文件中，实现磁盘缓存。</p>
<p>具体见FlashDiskCacheManager类的注释部分。</p>
<p>FlashDiskCacheManager.h</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="copy" target="_blank" rel="external">copy</a>1. //  </p>
<ol>
<li>//  FlashDiskCacheManager.h  </li>
<li>//    </li>
<li>//  </li>
<li>//  Created by jeffrey on 10-12-21.  </li>
<li>//  Copyright 2010 AppUFO. All rights reserved.  </li>
<li>//  </li>
<li><h1 id="import_">import <foundation foundation.h=""></foundation></h1>
</li>
<li><h1 id="import_“URLCacheElement-h”">import “URLCacheElement.h”</h1>
</li>
<li>@interface FlashDiskCacheManager : NSObject  </li>
<li>{  </li>
<li>/<strong> 存储已经缓存的url </strong>/  </li>
<li>NSMutableDictionary* urlDictionary;  </li>
<li></li>
<li>NSKeyedUnarchiver* reader;  </li>
<li>}  </li>
<li>@property (nonatomic, retain) NSMutableDictionary *urlDictionary;  </li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>设置保存时间 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(void) setMinStoreInterval:(double)interval;  </li>
</ul>
</li>
<li><ul>
<li>(FlashDiskCacheManager*) sharedManager;  </li>
</ul>
</li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>获取缓存的对象 如果为nil，则缓存已经失效，或者无缓存 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(URLCacheElement<em>) cachedForWithURL:(NSURL</em>)url;  </li>
</ul>
</li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>缓存请求1 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(void) cachedWithURLResponse:(NSCachedURLResponse*) cachedResponse;  </li>
</ul>
</li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>缓存请求2 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(void) cachedWithData:(NSData<em>)data theUrl:(NSURL</em>)url;  </li>
</ul>
</li>
<li>/** </li>
<li>* </li>
<li><ul>
<li>写入闪存 </li>
</ul>
</li>
<li>* </li>
<li>*/  </li>
<li><ul>
<li>(void) storeToDisk;  </li>
</ul>
</li>
<li>@end  </li>
</ol>
<p>FlashDiskCacheManager.m</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="copy" target="_blank" rel="external">copy</a>1. //  </p>
<ol>
<li>//  FlashDiskCacheManager.m  </li>
<li>//    </li>
<li>//  </li>
<li>//  Created by jeffrey on 10-12-21.  </li>
<li>//  Copyright 2010 AppUFO. All rights reserved.  </li>
<li><h1 id="import_“FlashDiskCacheManager-h”">import “FlashDiskCacheManager.h”</h1>
</li>
<li></li>
<li>@implementation FlashDiskCacheManager  </li>
<li>@synthesize urlDictionary;  </li>
<li>static FlashDiskCacheManager* defaultManager = nil;  </li>
<li>/<strong> 存储实效时间 </strong>/  </li>
<li>static NSTimeInterval minStoreInterval = 10 <em> 60 </em> 60;  </li>
<li><ul>
<li>(void) setMinStoreInterval:(double)interval  </li>
</ul>
</li>
<li>{  </li>
<li>minStoreInterval = interval;  </li>
<li>}  </li>
<li><ul>
<li>(FlashDiskCacheManager*) sharedManager  </li>
</ul>
</li>
<li>{  </li>
<li>@synchronized(self)  </li>
<li>{  </li>
<li>if (defaultManager == nil)  </li>
<li>{  </li>
<li>defaultManager = [[self alloc] init];  </li>
<li>}  </li>
<li>return defaultManager;  </li>
<li>}  </li>
<li>}  </li>
<li><ul>
<li>(id) init  </li>
</ul>
</li>
<li>{  </li>
<li>self = [super init];  </li>
<li>if (self)  </li>
<li>{  </li>
<li>NSArray* path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  </li>
<li>self.urlDictionary = [[NSMutableDictionary alloc] init];  </li>
<li>[urlDictionary release];  </li>
<li></li>
<li>//解档  </li>
<li>for (NSInteger index = 0; index &lt; 100000; ++index)  </li>
<li>{  </li>
<li>NSString* document = [path objectAtIndex:0];  </li>
<li>document = [document stringByAppendingPathComponent:[NSString stringWithFormat:@”cache%d”, index]];  </li>
<li>if ([[NSFileManager defaultManager] fileExistsAtPath:document])  </li>
<li>{  </li>
<li>NSMutableData* data = [[NSMutableData alloc] initWithContentsOfFile:document];  </li>
<li>reader = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];  </li>
<li>URLCacheElement* element = [reader decodeObjectForKey:[NSString stringWithFormat:@”cache%d”, index]];  </li>
<li>[reader finishDecoding];  </li>
<li>NSURL* urlKey = [[NSURL alloc] initWithString:element.name];  </li>
<li>NSTimeInterval now = [element.date timeIntervalSinceNow];  </li>
<li></li>
<li>if (fabs(now) - minStoreInterval &gt; 0)  </li>
<li>{  </li>
<li>[data release];  </li>
<li>[urlKey release];  </li>
<li>[reader release];  </li>
<li>continue;  </li>
<li>}  </li>
<li></li>
<li>[urlDictionary setObject:element forKey:urlKey];  </li>
<li>[data release];  </li>
<li>[urlKey release];  </li>
<li>[reader release];  </li>
<li>}  </li>
<li>else  </li>
<li>{  </li>
<li>break;  </li>
<li>}  </li>
<li>}  </li>
<li>return self;  </li>
<li>}  </li>
<li>return nil;  </li>
<li>}  </li>
<li><ul>
<li>(URLCacheElement<em>) cachedForWithURL:(NSURL</em>)url  </li>
</ul>
</li>
<li>{  </li>
<li>URLCacheElement* element =  [urlDictionary objectForKey:url];  </li>
<li>if (element == nil)  </li>
<li>{  </li>
<li>return nil;  </li>
<li>}  </li>
<li></li>
<li>NSTimeInterval now = [element.date timeIntervalSinceNow];  </li>
<li>if (fabs(now) - minStoreInterval &gt; 0)  </li>
<li>{  </li>
<li>[self.urlDictionary removeObjectForKey:url];  </li>
<li>return nil;  </li>
<li>}  </li>
<li>return element;  </li>
<li>}  </li>
<li><ul>
<li>(void) cachedWithURLResponse:(NSCachedURLResponse*) cachedResponse  </li>
</ul>
</li>
<li>{  </li>
<li>NSURLResponse* response = [cachedResponse response];  </li>
<li></li>
<li>//要存储的url  </li>
<li>NSURL* url = [response URL];  </li>
<li></li>
<li>//要存储的数据  </li>
<li>NSData* data = [cachedResponse data];  </li>
<li></li>
<li>//存储的时间  </li>
<li>NSDate* date = [NSDate date];  </li>
<li></li>
<li>// 存储的用户信息  </li>
<li>NSDictionary* user = [cachedResponse userInfo];  </li>
<li></li>
<li>URLCacheElement* element = [[URLCacheElement alloc] initWithData:data :date :user];  </li>
<li>[self.urlDictionary setObject:element forKey:url];  </li>
<li></li>
<li>[element release];  </li>
<li>}  </li>
<li><ul>
<li>(void) cachedWithData:(NSData<em>)data theUrl:(NSURL</em>)url  </li>
</ul>
</li>
<li>{  </li>
<li>//存储的时间  </li>
<li>NSDate* date = [NSDate date];  </li>
<li></li>
<li>// 存储的用户信息  </li>
<li>NSDictionary* user = nil;  </li>
<li></li>
<li>URLCacheElement* element = [[URLCacheElement alloc] initWithData:data :date :user];  </li>
<li>[self.urlDictionary setObject:element forKey:url];  </li>
<li></li>
<li>[element release];    </li>
<li>}  </li>
<li><ul>
<li>(void) storeToDisk  </li>
</ul>
</li>
<li>{  </li>
<li>NSArray* path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  </li>
<li>NSArray* arrayOfKeys = [urlDictionary allKeys];  </li>
<li></li>
<li>//归档  </li>
<li>for (NSInteger index = 0; index &lt; [arrayOfKeys count]; ++index)  </li>
<li>{  </li>
<li>NSURL<em> url = (NSURL</em>)[arrayOfKeys objectAtIndex:index];  </li>
<li>NSString* name = [url absoluteString];  </li>
<li></li>
<li>//初始化路径  </li>
<li>NSString* document = [path objectAtIndex:0];  </li>
<li>document = [document stringByAppendingPathComponent:[NSString stringWithFormat:@”cache%d”, index]];  </li>
<li></li>
<li>NSMutableData* tData = [[NSMutableData alloc] init];  </li>
<li>NSKeyedArchiver* write = [[NSKeyedArchiver alloc] initForWritingWithMutableData:tData];  </li>
<li>URLCacheElement* element = [urlDictionary objectForKey:[arrayOfKeys objectAtIndex:index]];  </li>
<li></li>
<li>//记录这个缓存的名字  </li>
<li>element.name = name;  </li>
<li></li>
<li>[write encodeObject:element forKey:[NSString stringWithFormat:@”cache%d”, index]];  </li>
<li></li>
<li>[write finishEncoding];  </li>
<li>[tData writeToFile:document atomically:YES];  </li>
<li></li>
<li>[tData release];  </li>
<li>[write release];  </li>
<li>}  </li>
<li>}  </li>
<li><ul>
<li>(void) dealloc  </li>
</ul>
</li>
<li>{  </li>
<li>[super dealloc];  </li>
<li>[urlDictionary release];  </li>
<li>}  </li>
<li>@end  </li>
</ol>
<p>URLCacheElement.h</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="copy" target="_blank" rel="external">copy</a>1. //  </p>
<ol>
<li>//  URLCacheElement.h  </li>
<li>//    </li>
<li>//  </li>
<li>//  Created by jeffrey on 10-12-21.  </li>
<li>//  Copyright 2010 AppUFO. All rights reserved.  </li>
<li>//  </li>
<li><h1 id="import_-1">import <foundation foundation.h=""></foundation></h1>
</li>
<li><h1 id="define_KData_@”urlData”">define KData @”urlData”</h1>
</li>
<li><h1 id="define_KUserInfo_@”userInfo”">define KUserInfo @”userInfo”</h1>
</li>
<li><h1 id="define_KDate_@”date”">define KDate @”date”</h1>
</li>
<li><h1 id="define_KName_@”name”">define KName @”name”</h1>
</li>
<li>@interface URLCacheElement : NSObject<nscoding, nscopying="">  </nscoding,></li>
<li>{  </li>
<li>/<strong> url存储的数据 </strong>/  </li>
<li>NSData* data;  </li>
<li></li>
<li>/<strong> 存储的用户信息 </strong>/  </li>
<li>NSDictionary* userInfo;  </li>
<li></li>
<li>/<strong> 存储的时间 </strong>/  </li>
<li>NSDate* date;  </li>
<li></li>
<li>NSString* name;  </li>
<li>}  </li>
<li><ul>
<li>(id) initWithData:(NSData<em>)indata :(NSDate</em>)indate :(NSDictionary*)inuserInfo;  </li>
</ul>
</li>
<li>@property (nonatomic, retain) NSData *data;  </li>
<li>@property (nonatomic, retain) NSDictionary *userInfo;  </li>
<li>@property (nonatomic, retain) NSDate *date;  </li>
<li>@property (nonatomic, retain) NSString *name;  </li>
<li>@end  </li>
</ol>
<p>URLCacheElement.m</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/windows_star/article/details/6117392#" title="copy" target="_blank" rel="external">copy</a>1. //  </p>
<ol>
<li>//  URLCacheElement.m  </li>
<li>//    </li>
<li>//  </li>
<li>//  Created by jeffrey on 10-12-21.  </li>
<li>//  Copyright 2010 AppUFO. All rights reserved.  </li>
<li><h1 id="import_“URLCacheElement-h”-1">import “URLCacheElement.h”</h1>
</li>
<li></li>
<li>@implementation URLCacheElement  </li>
<li>@synthesize data;  </li>
<li>@synthesize date;  </li>
<li>@synthesize userInfo;  </li>
<li>@synthesize name;  </li>
<li><ul>
<li>(id) initWithData:(NSMutableData<em>)indata :(NSDate</em>)indate :(NSMutableDictionary*)inuserInfo  </li>
</ul>
</li>
<li>{  </li>
<li>self = [super init];  </li>
<li>if (self)  </li>
<li>{  </li>
<li>self.data = indata;  </li>
<li>self.date = indate;  </li>
<li>self.userInfo = inuserInfo;  </li>
<li>return self;  </li>
<li>}  </li>
<li>return nil;  </li>
<li>}  </li>
<li></li>
<li><ul>
<li>(id) initWithCoder:(NSCoder *)aDecoder  </li>
</ul>
</li>
<li>{  </li>
<li>self = [super init];  </li>
<li>if (self)  </li>
<li>{  </li>
<li>self.data = [aDecoder decodeObjectForKey:KData];  </li>
<li>self.date = [aDecoder decodeObjectForKey:KDate];  </li>
<li>self.userInfo = [aDecoder decodeObjectForKey:KUserInfo];  </li>
<li>self.name = [aDecoder decodeObjectForKey:KName];  </li>
<li>return self;  </li>
<li>}  </li>
<li>return nil;  </li>
<li>}  </li>
<li></li>
<li><ul>
<li>(void) encodeWithCoder:(NSCoder *)aCoder  </li>
</ul>
</li>
<li>{  </li>
<li>[aCoder encodeObject:data forKey:KData];  </li>
<li>[aCoder encodeObject:date forKey:KDate];  </li>
<li>[aCoder encodeObject:userInfo forKey:KUserInfo];  </li>
<li>[aCoder encodeObject:name forKey:KName];  </li>
<li>}  </li>
<li><ul>
<li>(id) copyWithZone:(NSZone *)zone  </li>
</ul>
</li>
<li>{  </li>
<li>URLCacheElement *copy = [[[self class] allocWithZone:zone] init];  </li>
<li></li>
<li>self.data = [data copy];  </li>
<li>self.date = [date copy];  </li>
<li>self.userInfo = [userInfo copy];  </li>
<li>name = [name copy];  </li>
<li></li>
<li>return copy;  </li>
<li>}  </li>
<li><ul>
<li>(void) dealloc  </li>
</ul>
</li>
<li>{  </li>
<li>[super dealloc];  </li>
<li>}  </li>
<li>@end  </li>
</ol>
<p>本文转自:<a href="http://blog.csdn.net/windows_star/article/details/6117392" target="_blank" rel="external">http://blog.csdn.net/windows_star/article/details/6117392</a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/缓存/">缓存</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-26T02:07:00.000Z"><a href="/2014/02/26/如何改进iOS App的离线使用体验/">2月 26 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/26/如何改进iOS App的离线使用体验/">如何改进iOS App的离线使用体验</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <h2 id="App_Store中的App分析">App Store中的App分析</h2>
<p>App已经与我们形影不离了，不管在地铁上、公交上还是在会场你总能看到很多人拿出来手机，刷一刷微博，看看新闻。<br>据不完全统计有近一半的用户在非Wifi环境打开App，以下为一个典型iPhone和Android App（50W+用户）的友盟后台数据：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726375773.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726382086.jpg" alt="1" title="1"></a><br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726391398.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726403250.jpg" alt="2" title="2"></a><br>3G、2G的数据连接往往不稳定（特别在公交或者地铁上），这时打开一些App就会像这样：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726451850.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172647539.png" alt="IMG_2159" title="IMG_2159"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726512651.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101726521091.png" alt="IMG_2163" title="IMG_2163"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101727107846.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172713863.png" alt="IMG_2160" title="IMG_2160"></a><br>当然也会有一些体验很好的App，在离线状态下也能顺畅使用：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172726622.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101727298830.png" alt="IMG_2149" title="IMG_2149"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101727449787.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172750588.png" alt="IMG_2150" title="IMG_2150"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728085325.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728128767.png" alt="IMG_2161" title="IMG_2161"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728301279.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728369845.png" alt="IMG_2162" title="IMG_2162"></a><br>甚至提供了离线阅读功能：<br><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172846151.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101728494804.png" alt="IMG_2158" title="IMG_2158"></a></p>
<h2 id="如何做？">如何做？</h2>
<p>打开过的文章、下载过的音频、查看过的图片我们都希望Cache到本地，下次不用再向服务器请求。<br>首先，我们为了最快让用户看到内容，会在ViewDidLoad加载Cache数据，如：<br>1234<code>-
 (``void``)viewDidLoad
 {</code> <code>``[self
 getArticleList:0 length:SECTION_LENGTH useCacheFirst:YES];``}</code>然后在viewDidAppear中向服务器请求最新数据，如<br>12345678<code>-
 (``void``)viewDidAppear:(``BOOL``)animated
 {`` </code> <code>``[super
 viewDidAppear:animated];</code> <code>``//...</code> <code>``[self
 getArticleList:0 length:SECTION_LENGTH useCacheFirst:NO]``}</code>当然这里的getArticleList接口有useCacheFirst参数，我们需要网络请求模块能够支持这一点，下面就介绍这些库和工具。（借助一些工具很容易能做到这些，而不用自己造轮子。遵循“凡事都应该最简单，而不过于简陋”的原则，这里整理一下，方便项目中使用）。</p>
<h3 id="1-NSMutableURLRequest">1.NSMutableURLRequest</h3>
<p>Sample(参考麒麟的文章《<a href="http://www.cnblogs.com/zhuqil/archive/2011/07/30/2122127.html" target="_blank" rel="external">iOS开发之缓存（一）：内存缓存</a>》来使用NSURLCache)：<br>1234567891011121314151617181920212223242526272829303132<code>NSString
 *paramURLAsString= @``&quot;[http://www.baidu.com/](http://www.baidu.com/)&quot;``;``if</code> <code>([paramURLAsString
 length] == 0){``    ``NSLog(@``&quot;Nil
 or empty URL is given&quot;``);``    ``return``;``}``NSURLCache
 *urlCache = [NSURLCache sharedURLCache];``/*
 设置缓存的大小为1M*/``[urlCache
 setMemoryCapacity:1*1024*1024];`` ``//创建一个nsurl``NSURL
 *url = [NSURL URLWithString:paramURLAsString];``    ``//创建一个请求``NSMutableURLRequest
 *request =``[NSMutableURLRequest`` ``requestWithURL:url`` ``cachePolicy:NSURLRequestUseProtocolCachePolicy`` ``timeoutInterval:60.0f];`` ``//从请求中获取缓存输出``NSCachedURLResponse
 *response =``[urlCache
 cachedResponseForRequest:request];``//判断是否有缓存``if</code> <code>(response
 != nil){``    ``NSLog(@``&quot;如果有缓存输出，从缓存中获取数据&quot;``);``    ``[request
 setCachePolicy:NSURLRequestReturnCacheDataDontLoad];``}``self.connection
 = nil;``/*
 创建NSURLConnection*/``NSURLConnection
 *newConnection =``[[NSURLConnection
 alloc] initWithRequest:request``                                ``delegate:self``                        ``startImmediately:YES];``self.connection
 = newConnection;``[newConnection
 release];</code>但是NSMutableURLRequest使用起来不够简便，在实际项目中我很少用它，而基本使用ASIHTTPRequest来代替。</p>
<h3 id="2-ASIHTTPRequest">2.ASIHTTPRequest</h3>
<p>你可以从这里找到它的介绍：<a href="http://allseeing-i.com/ASIHTTPRequest/" target="_blank" rel="external">http://allseeing-i.com/ASIHTTPRequest/</a>，在5.0/4.0及之前iOS版本，ASIHTTPRequest基本是主力的<br> HTTP requests library，它本身也是Github中的开源项目，但是从iOS 5.0之后逐渐停止维护了。未来的项目可以使用<strong><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a></strong>或者<strong><a href="https://github.com/MugunthKumar/MKNetworkKit" target="_blank" rel="external">MKNetworkKit</a></strong>代替ASIHTTPRequest。<br>ASIHTTPRequest的简介如下：</p>
<blockquote>
<p>ASIHTTPRequest is an easy to use wrapper around the CFNetwork API that makes some of the more tedious aspects of communicating with web servers easier. It is written in Objective-C and works in both Mac OS X and<br> iPhone applications.<br>It is suitable performing basic HTTP requests and interacting with REST-based services (GET / POST / PUT / DELETE). The included ASIFormDataRequest subclass makes it easy to submit POST data and files using<a href="http://en.wikipedia.org/wiki/MIME#Form_Data" target="_blank" rel="external">multipart/form-data</a>.<br>ASIHTTPRequest库API设计的简单易用，并且支持block、queue、gzip等丰富的功能，这是该开源项目如此受欢迎的主要原因。<br>ASIHTTPRequest库中提供了ASIWebPageRequest组件用于请求网页，并且能把网页中的外部资源一并请求下来，但是我在实际项目中使用后发现有严重Bug，所以不建议使用。<br>ASIHTTPRequest库的介绍中也提到了它可以支持REST-based service，但是与Restfull API打交道我们往往使用下面介绍的的RestKit。<br>Sample：<br>12345678910111213141516171819202122232425262728293031323334353637383940<code>NSMutableString
 *requestedUrl = [[NSMutableString alloc] initWithString:self.url];</code> <code>//如果优先使用本地数据``ASICachePolicy
 policy = _useCacheFirst ? ASIOnlyLoadIfNotCachedCachePolicy ``    ``:
 (ASIAskServerIfModifiedCachePolicy | ASIFallbackToCacheIfLoadFailsCachePolicy);</code> <code>asiRequest
 = [ASIHTTPRequest requestWithURL:``                   ``[NSURL
 URLWithString:[requestedUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]]];</code> <code>[asiRequest
 setDownloadCache:[ASIDownloadCache sharedCache]];``[asiRequest
 setCachePolicy:policy];``[asiRequest
 setCacheStoragePolicy:ASICachePermanentlyCacheStoragePolicy];</code> <code>//
 Connection``if</code> <code>(_connectionType
 == ConnectionTypeAsynchronously) {`` </code> <code>``[asiRequest
 setDelegate:self];``    ``[asiRequest
 startAsynchronous];`` </code> <code>``//
 Tell we&#39;re receiving.``    ``if</code> <code>(!_canceled
 &amp;&amp; [_delegate respondsToSelector:@selector(downloaderDidStart:)])``        ``[_delegate
 downloaderDidStart:self];``}``else``{``    ``[asiRequest
 startSynchronous];`` </code> <code>``NSError
 *error = [asiRequest error];`` </code> <code>``if</code> <code>(!error)
``    ``{``        ``[self
 requestFinished:asiRequest];``    ``}``    ``else``    ``{``        ``[self
 requestFailed:asiRequest];``    ``}``}</code> <code>[requestedUrl
 release];</code> </p>
<h3 id="3-RestKit">3.RestKit</h3>
<p>官方网站：<a href="http://restkit.org/" target="_blank" rel="external">http://restkit.org/</a>，Github开源项目，与 Restfull<br> API 的 Web服务打交道，这个库非常便捷，它也提供了很完整的Cache机制。<br>Sample：<br>123456789101112<code>+
 (``void``)setCachePolicy:(``BOOL``)useCacheFirst``{``    ``RKObjectManager*
 objectManager = [RKObjectManager sharedManager];`` </code> <code>``if</code> <code>(useCacheFirst)
 {``        ``objectManager.client.cachePolicy
 = RKRequestCachePolicyEnabled; ``//使用本地Cache，如果没有Cache请求服务器``    ``}``    ``else``    ``{``        ``objectManager.client.cachePolicy
 = RKRequestCachePolicyLoadIfOffline|RKRequestCachePolicyTimeout; ``//离线或者超时时使用本地Cache``    ``}``}</code>123456789101112<code>+
 (``BOOL``)getHomeTimeline:(NSInteger)maxId
``                 ``length:(NSInteger)length``               ``delegate:(id&lt;RKObjectLoaderDelegate&gt;)delegate``          ``useCacheFirst:(``BOOL``)useCacheFirst``{``    ``if</code> <code>(delegate
 == nil)``        ``return</code> <code>NO;`` </code> <code>``[iKnowAPI
 setCachePolicy:useCacheFirst];</code> <code>``//...``}</code>Cache请求只是RestKit最基本的功能，RestKit真正强大的地方在于处理与RESTful web services交互时的相关工作非常简便（<a href="https://github.com/RestKit/RestKit/wiki" target="_blank" rel="external">https://github.com/RestKit/RestKit/wiki</a>），RestKit还可以Cache<br> data model到Core Data中：<br>Core Data support. Building on top of the object mapping layer, RestKit provides integration with Apple’s Core Data framework. This support allows RestKit to persist remotely loaded objects directly back into a local<br> store, either as a fast local cache or a primary data store that is periodically synced with the cloud. RestKit can populate Core Data associations for you, allowing natural property based traversal of your data model. It also provides a nice API on top of<br> the Core Data primitives that simplifies configuration and querying use cases through an implementation of the Active Record access pattern.<br>但实际上RKRequestCachePolicy已经解决了大部分Cache需求。</p>
</blockquote>
<h3 id="4-SDWebImage">4.SDWebImage</h3>
<p>SDWebImage是Github开源项目：<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a>，它用于方便的请求、Cache网络图片，并且请求完毕后交由UIImageView显示。</p>
<blockquote>
<p>Asynchronous image downloader with cache support with an UIImageView category.<br>SDWebImage作为UIImageView的一个Category提供的，所以使用起来非常简单：<br>123<code>//
 Here we use the new provided setImageWithURL: method to load the web image``[imageView
 setImageWithURL:[NSURL URLWithString:@``&quot;[http://www.domain.com/path/to/image.jpg](http://www.domain.com/path/to/image.jpg)&quot;``]``               ``placeholderImage:[UIImage
 imageNamed:@``&quot;placeholder.png&quot;``]];</code>AFNetworking也提供了类似功能（<a href="http://afnetworking.github.com/AFNetworking/Categories/UIImageView+AFNetworking.html" target="_blank" rel="external">UIImageView+AFNetworking</a>）：<br>12<code>UIImageView
 *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0.0f, 0.0f, 100.0f, 100.0f)];``[imageView
 setImageWithURL:[NSURL URLWithString:@``&quot;[http://i.imgur.com/r4uwx.jpg](http://i.imgur.com/r4uwx.jpg)&quot;``]
 placeholderImage:[UIImage imageNamed:@``&quot;placeholder-avatar&quot;``]];</code> </p>
<h3 id="5-UIWebView中的图片Cache">5.UIWebView中的图片Cache</h3>
<p>如果你使用UIWebView来展示内容，在离线情况下如果也想能显示的话需要实现2点：</p>
<ul>
<li>Cache Html页面</li>
<li>Cache 图片等元素</li>
</ul>
</blockquote>
<p>使用上面介绍的网络组件来Cache Html页面比较便捷，之后使用webView loadHTMLString即可加载本地Html页面，而Cache图片需要更换NSURLCache公共实例为自定义的NSURLCache（UIWebView使用的即是+[NSURLCache sharedURLCache]）：<br>12345<code>//设置使用自定义Cache机制``LocalSubstitutionCache
 *cache = [[[LocalSubstitutionCache alloc] init] autorelease];``[cache
 setMemoryCapacity:4 * 1024 * 1024];``[cache
 setDiskCapacity:10 * 1024 * 1024];``[NSURLCache
 setSharedURLCache:cache];</code>自定义NSURLCache：<br>12345678910<code>#import
 &lt;Foundation/Foundation.h&gt;</code> <code>@interface
 LocalSubstitutionCache : NSURLCache``{``    ``NSMutableDictionary
 *cachedResponses;``}</code> <code>+
 (NSString *)pathForURL:(NSURL*)url;</code> <code>@end</code>详细的见NewsReader中的LocalSubstitutionCache.h/.m和WebViewController.m中的viewDidLoad，<a href="http://www.cnblogs.com/wangkewei/archive/2012/09/29/2708373.html" target="_blank" rel="external">News<br> Reader开源项目</a>这里参考的是：<a href="http://cocoawithlove.com/2010/09/substituting-local-data-for-remote.html" target="_blank" rel="external">http://cocoawithlove.com/2010/09/substituting-local-data-for-remote.html</a></p>
<h2 id="NewsReader中的介绍">NewsReader中的介绍</h2>
<h4 id="《iOS_News_Reader开源项目》这篇文章介绍到的开源项目改进了离线使用体验：">《<a href="http://www.cnblogs.com/wangkewei/archive/2012/09/29/2708373.html" target="_blank" rel="external">iOS News Reader开源项目</a>》这篇文章介绍到的开源项目改进了离线使用体验：</h4>
<p><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172859401.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101729043286.png" alt="IMG_2155" title="IMG_2155"></a><a href="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/201210101729141291.png" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/wangkewei/201210/20121010172918928.png" alt="IMG_2156" title="IMG_2156"></a><br>在没有网络的情况下使用已经Cache过的所有数据：文章、图片、音频等等，用到的主要方案已经在上面介绍了，详细的请看源码：<a href="https://github.com/cubewang/NewsReader" target="_blank" rel="external">https://github.com/cubewang/NewsReader</a>。<br>NewsReader项目因为历史演进的原因已经有些庞大了，需要进一步重构，在之后的项目中我们的客户端结构更精简。<br>另外欢迎加QQ群讨论：161561752<br>作者: 王克伟<br>出处: <a href="http://wangkewei.cnblogs.com/" target="_blank" rel="external">http://wangkewei.cnblogs.com/</a><br>版权声明: 本文的版权归作者与博客园共有。转载时须注明本文的详细链接，否则作者将保留追究其法律责任的权利。<br>您可以从<a href="http://www.cnblogs.com/wangkewei/archive/2009/10/15/1583745.html" target="_blank" rel="external">这里</a>更方便的找到我的文章。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之网络通讯/">iOS应用开发之网络通讯</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-24T09:08:00.000Z"><a href="/2014/02/24/objective-c宏定义/">2月 24 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/24/objective-c宏定义/">objective-c宏定义</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><strong>本文转自:<a href="http://blog.csdn.net/wangqiuyun/article/details/8104698" target="_blank" rel="external">http://blog.csdn.net/wangqiuyun/article/details/8104698</a></strong><br><strong>1、先来几个常用的：</strong></p>
<p><strong>[csharp]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. // 是否高清屏  </p>
<ol>
<li><h1 id="define_isRetina_([UIScreen_instancesRespondToSelector:@selector(currentMode)]_?_CGSizeEqualToSize(CGSizeMake(640,_960),_[[UIScreen_mainScreen]_currentMode]-size)_:_NO)">define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), [[UIScreen mainScreen] currentMode].size) : NO)</h1>
</li>
<li>// 是否模拟器  </li>
<li><h1 id="define_isSimulator_(NSNotFound_!=_[[[UIDevice_currentDevice]_model]_rangeOfString:@”Simulator”]-location)">define isSimulator (NSNotFound != [[[UIDevice currentDevice] model] rangeOfString:@”Simulator”].location)</h1>
</li>
<li>// 是否iPad  </li>
<li><h1 id="define_isPad_(UI_USER_INTERFACE_IDIOM()_==_UIUserInterfaceIdiomPad)">define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)</h1>
</li>
<li>// 是否iPad  </li>
<li><h1 id="define_someThing_(UI_USER_INTERFACE_IDIOM()_==_UIUserInterfaceIdiomPad)?_ipad:_iphone">define someThing (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)? ipad: iphone</h1>
</li>
</ol>
<p><strong>2、基本的使用：</strong></p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. //定义π值 3.1415926    </p>
<ol>
<li><h1 id="define_PI_3-1415926">define PI 3.1415926</h1>
</li>
<li>//则在程序用可以如下使用       </li>
<li>double i=2<em>PI</em>3;     </li>
<li>//效果相当于  double i=2<em>3.1415926</em>3;    </li>
<li></li>
<li>//预处理命令可以定义任何符合格式的形式，例如判断年份是否闰年  </li>
<li><h1 id="define_IS_LEAP_YEAR_year%4==0&amp;&amp;year%100!=0||year%400==0">define  IS_LEAP_YEAR  year%4==0&amp;&amp;year%100!=0||year%400==0</h1>
</li>
<li>//使用时则可以直接    </li>
<li>if(IS_LEAP_YEAR)    </li>
<li></li>
<li>//或者可以定义一个参数      </li>
<li><h1 id="define_IS_LEAP_YEAR(y)_y%4==0&amp;&amp;y%100!=0||y%400==0">define  IS_LEAP_YEAR(y)  y%4==0&amp;&amp;y%100!=0||y%400==0</h1>
</li>
<li>//使用时则可以直接     </li>
<li>int ys=2012;     </li>
<li>if(IS_LEAP_YEAR(ys))       </li>
<li></li>
<li>//通常预处理程序定义在一行 如果好分行 比如说太长需要换行  需要使用“/”符号 表示还有下一行，多行分列也是如此，例：    </li>
<li><h1 id="Define_IS_LEAP_YEAR_year%4==0&amp;&amp;year%100!=0/">Define  IS_LEAP_YEAR  year%4==0&amp;&amp;year%100!=0/</h1>
</li>
<li>||year%400==0     </li>
<li>//宏定义参数后边放一个# 那么在调用该宏时，预处理程序将根据宏参数创建C风格的常量字符串 例：    </li>
<li><h1 id="define_STR(x)_#_x">define STR(x) # x</h1>
</li>
<li>//将会使得 随后调用的      </li>
<li></li>
<li>NSLOG(STR(Programming in Objective-c./n));    </li>
<li>//显示结果为 Programming in Objective-c./n  </li>
</ol>
<p><strong>3、关于#与##的操作符：</strong></p>
<p><1>.宏定义中字符串化操作符#：</1></p>
<h1 id="的功能是将其后面的宏参数进行字符串化操作，意思就是对它所应用的宏变量通过替换后在其左右各加上一个双引号。例如">的功能是将其后面的宏参数进行字符串化操作，意思就是对它所应用的宏变量通过替换后在其左右各加上一个双引号。例如</h1>
<p><strong>[csharp]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. #define WARN_IF(EXPR)\  </p>
<ol>
<li>do {\  </li>
<li>if (EXPR)\  </li>
<li>fprintf(stderr, “Warning: “ #EXPR “\n”);\  </li>
<li>} while(0)  </li>
<li></li>
<li>上面代码中的反斜线\主要用来转译换行符，即屏蔽换行符。  </li>
<li></li>
<li>那么如下的代码调用：  </li>
<li>WARN_IF(divider == 0);  </li>
<li></li>
<li>将被解析为：  </li>
<li>do {\  </li>
<li>if (divider == 0)\  </li>
<li>fprintf(stderr, “Warning: “ “divider == 0” “\n”);\  </li>
<li>} while(0);  </li>
</ol>
<p>注意能够字符串化操作的必须是宏参数，不是随随便便的某个子串（token）都行的。</p>
<p><2>.宏定义中的连接符##：<br>连接符##用来将两个token连接为一个token，但它不可以位于第一个token之前or最后一个token之后。注意这里连接的对象只要是token就行，而不一定是宏参数,但是##又必须位于宏定义中才有效，因其为编译期概念（比较绕）。</2></p>
<p><strong>[html]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. #define LINK<em>MULTIPLE(a, b, c, d) a##</em>##b##<em>##c##</em>##d  </p>
<ol>
<li>typedef struct _record_type LINK_MULTIPLE(name, company, position, salary);  </li>
<li>/*  </li>
<li><ul>
<li>上面的代码将被替换为  </li>
</ul>
</li>
<li><ul>
<li>typedef struct _record_type name_company_position_salary;  </li>
</ul>
</li>
<li>*/  </li>
<li></li>
<li>又如下面的例子：  </li>
<li><h1 id="define_PARSER(N)_printf(“token”_#N_“_=_%d\n”,_token##N)">define PARSER(N) printf(“token” #N “ = %d\n”, token##N)</h1>
</li>
<li></li>
<li>int token64 = 64;  </li>
<li></li>
<li>如下调用宏：  </li>
<li>PARSER(64);  </li>
<li></li>
<li>将被解析为：  </li>
<li>printf(“token” “64” “ = %d\n”, token64);  </li>
<li></li>
<li>在obj-c中，如果我有如下定义：  </li>
<li><h1 id="define__X(A,_B)_(A#B)">define _X(A, B) (A#B)</h1>
</li>
<li><h1 id="define__XX(A,_B)__X([NSString_stringWithFormat:@”%@_c”,_A],_B)">define _XX(A, B) _X([NSString stringWithFormat:@”%@_c”, A], B)</h1>
</li>
<li>gcc将报错！  </li>
<li>正确的写法为：  </li>
<li><h1 id="define__XX(A,_B)__X(([NSString_stringWithFormat:@”%@_c”,_A]),_B)">define _XX(A, B) _X(([NSString stringWithFormat:@”%@_c”, A]), B)</h1>
</li>
</ol>
<p><strong>4、再来个宏定义 object-c 单例</strong></p>
<p><strong>[csharp]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. #define GTMOBJECT<em>SINGLETON_BOILERPLATE(_object_name</em>, <em>shared_obj_name</em>)  </p>
<ol>
<li>static <em>object_name</em> *z##<em>shared_obj_name</em> = nil;   </li>
<li><ul>
<li>(<em>object_name</em> *)<em>shared_obj_name</em> {              </li>
</ul>
</li>
<li>@synchronized(self) {                             </li>
<li>if (z##<em>shared_obj_name</em> == nil) {              </li>
<li>/<em> Note that ‘self’ may not be the same as <em>object_name</em> </em>/                                </li>
<li>/<em> first assignment done in allocWithZone but we must reassign in case init fails </em>/       </li>
<li>z##<em>shared_obj_name</em> = [[self alloc] init];                                                </li>
<li><em>GTMDevAssert((z##_shared_obj_name</em> != nil), @”didn’t catch singleton allocation”);        </li>
<li>}                                               </li>
<li>}                                                 </li>
<li>return z##<em>shared_obj_name</em>;                      </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(id)allocWithZone:(NSZone *)zone {                </li>
</ul>
</li>
<li>@synchronized(self) {                             </li>
<li>if (z##<em>shared_obj_name</em> == nil) {              </li>
<li>z##<em>shared_obj_name</em> = [super allocWithZone:zone];  </li>
<li>return z##<em>shared_obj_name</em>;                  </li>
<li>}                                               </li>
<li>}                                                 </li>
<li></li>
<li>/<em> We can’t return the shared instance, because it’s been init’d </em>/  </li>
<li>_GTMDevAssert(NO, @”use the singleton API, not alloc+init”);         </li>
<li>return nil;                                       </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(id)retain {                                      </li>
</ul>
</li>
<li>return self;                                      </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(NSUInteger)retainCount {                         </li>
</ul>
</li>
<li>return NSUIntegerMax;                             </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(void)release {                                   </li>
</ul>
</li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(id)autorelease {                                 </li>
</ul>
</li>
<li>return self;                                      </li>
<li>}                                                   </li>
<li></li>
<li><ul>
<li>(id)copyWithZone:(NSZone *)zone {                 </li>
</ul>
</li>
<li>return self;                                      </li>
<li>}  </li>
</ol>
<p><strong>5、条件编译：</strong></p>
<p><strong>[csharp]</strong> <a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="view plain" target="_blank" rel="external">view<br> plain</a><a href="http://blog.csdn.net/wangqiuyun/article/details/8104698#" title="copy" target="_blank" rel="external">copy</a>1. #if !defined(FCDebug) || FCDebug == 0  </p>
<ol>
<li><h1 id="define_FCLOG(…)_do_{}_while_(0)">define FCLOG(…) do {} while (0)</h1>
</li>
<li><h1 id="define_FCLOGINFO(…)_do_{}_while_(0)">define FCLOGINFO(…) do {} while (0)</h1>
</li>
<li><h1 id="define_FCLOGERROR(…)_do_{}_while_(0)">define FCLOGERROR(…) do {} while (0)</h1>
</li>
<li></li>
<li><h1 id="elif_FCDebug_==_1">elif FCDebug == 1</h1>
</li>
<li><h1 id="define_FCLOG(…)_NSLog(VA_ARGS)">define FCLOG(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="define_FCLOGERROR(…)_NSLog(VA_ARGS)">define FCLOGERROR(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="define_FCLOGINFO(…)_do_{}_while_(0)-1">define FCLOGINFO(…) do {} while (0)</h1>
</li>
<li></li>
<li><h1 id="elif_FCDebug_&gt;_1">elif FCDebug &gt; 1</h1>
</li>
<li><h1 id="define_FCLOG(…)_NSLog(VA_ARGS)-1">define FCLOG(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="define_FCLOGERROR(…)_NSLog(VA_ARGS)-1">define FCLOGERROR(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="define_FCLOGINFO(…)_NSLog(VA_ARGS)">define FCLOGINFO(…) NSLog(<strong>VA_ARGS</strong>)</h1>
</li>
<li><h1 id="endif">endif</h1>
</li>
</ol>
<p><strong>6、参照C语言的预处理命令简介 ：</strong></p>
<h1 id="define_定义一个预处理宏">define              定义一个预处理宏</h1>
<h1 id="undef_取消宏的定义">undef               取消宏的定义</h1>
<h1 id="include_包含文件命令">include            包含文件命令</h1>
<h1 id="include_next_与#include相似,_但它有着特殊的用途">include_next   与#include相似, 但它有着特殊的用途</h1>
<h1 id="if_编译预处理中的条件命令,_相当于C语法中的if语句">if                      编译预处理中的条件命令, 相当于C语法中的if语句</h1>
<h1 id="ifdef_判断某个宏是否被定义,_若已定义,_执行随后的语句">ifdef                判断某个宏是否被定义, 若已定义, 执行随后的语句</h1>
<h1 id="ifndef_与#ifdef相反,_判断某个宏是否未被定义">ifndef             与#ifdef相反, 判断某个宏是否未被定义</h1>
<h1 id="elif_若#if,_#ifdef,_#ifndef或前面的#elif条件不满足,_则执行#elif之后的语句,_相当于C语法中的else-if">elif                  若#if, #ifdef, #ifndef或前面的#elif条件不满足, 则执行#elif之后的语句, 相当于C语法中的else-if</h1>
<h1 id="else_与#if,_#ifdef,_#ifndef对应,_若这些条件不满足,_则执行#else之后的语句,_相当于C语法中的else">else                与#if, #ifdef, #ifndef对应, 若这些条件不满足, 则执行#else之后的语句, 相当于C语法中的else</h1>
<h1 id="endif_#if,_#ifdef,_#ifndef这些条件命令的结束标志-">endif              #if, #ifdef, #ifndef这些条件命令的结束标志.</h1>
<p>defined            与#if, #elif配合使用, 判断某个宏是否被定义</p>
<h1 id="line_标志该语句所在的行号">line                标志该语句所在的行号</h1>
<h1 id="将宏参数替代为以参数值为内容的字符窜常量">将宏参数替代为以参数值为内容的字符窜常量</h1>
<h2 id="将两个相邻的标记(token)连接为一个单独的标记">将两个相邻的标记(token)连接为一个单独的标记</h2>
<h1 id="pragma_说明编译器信息#warning_显示编译警告信息">pragma        说明编译器信息#warning       显示编译警告信息</h1>
<h1 id="error_显示编译错误信息">error            显示编译错误信息</h1>
<p>参考链接：<a href="http://www.uml.org.cn/c++/200902104.asp" target="_blank" rel="external">http://www.uml.org.cn/c++/200902104.asp</a></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/objective-c/">objective-c</a>, <a href="/tags/宏/">宏</a>, <a href="/tags/iphone开发/">iphone开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-24T05:35:00.000Z"><a href="/2014/02/24/iOS7应用国际化/">2月 24 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/24/iOS7应用国际化/">iOS7应用国际化</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>一 应用名字国际化:1. 新建一个工程test.</p>
<ol>
<li>首先修改应用名字</li>
<li><p>test-&gt;PROJECT-&gt;Info-&gt;Localizations-&gt;+号-&gt;Simplified<img src="http://img.blog.csdn.net/20140224131250015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p>在(English)添加CFBundleDisplayName=”English”;</p>
</li>
<li>在(Simplified)添加CFBundleDisplayName=”中文”;<img src="http://img.blog.csdn.net/20140224131753703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>启动应用就会按照本地语言加载应用的名称.</li>
</ol>
<p>二 应用内容国际化1. New File-&gt;String Flies,文件名字必须写Localizable,否则iOS识别不了,选择Localizable.strings,右边点击Localize…选择语言.<img src="" alt=""></p>
<ol>
<li>添加之后右边的Licalization会列出你支持的语言,全部勾上.</li>
<li><p>Localizable.strings会有你选择的两种语言的Strings文件.</p>
</li>
<li><p>在(English)里添加”key” = “English”;</p>
</li>
<li>在(Simplified)里添加”key” = “中文”;<img src="http://img.blog.csdn.net/20140224132942609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>添加一个Label就可以看到效果了.<img src="http://img.blog.csdn.net/20140224133121703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li>
<li>当然还有获取当前语言的方法    </li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *languages = [NSLocale preferredLanguages];</div><div class="line">    <span class="built_in">NSString</span> *language = [languages objectAtIndex:<span class="number">0</span>];</div><div class="line">    <span class="built_in">NSLog</span> ( <span class="string">@"%@"</span> , language);</div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios国际化/">ios国际化</a>, <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/国际化/">国际化</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-21T08:29:00.000Z"><a href="/2014/02/21/stringByEvaluatingJavaScriptFromString的使用方法/">2月 21 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/21/stringByEvaluatingJavaScriptFromString的使用方法/">stringByEvaluatingJavaScriptFromString的使用方法</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>　来源：　朱祁林 麒麟的blogstringByEvaluatingJavaScriptFromString使用stringByEvaluatingJavaScriptFromString方法，需要等UIWebView中的页面加载完成之后去调用。我们在界面上拖放一个UIWebView控件。在Load中将googlemobile加载到这个控件中，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line"> {</div><div class="line"> [<span class="keyword">super</span> viewDidLoad];</div><div class="line"> webview<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</div><div class="line"> webview<span class="variable">.scalesPageToFit</span> =<span class="literal">YES</span>;</div><div class="line"> webview<span class="variable">.delegate</span> =<span class="keyword">self</span>;</div><div class="line"> <span class="built_in">NSURL</span> *url =[[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"http://www.google.com.hk/m?gl=CN&hl=zh_CN&source=ihp"</span>];</div><div class="line"></div><div class="line"> <span class="built_in">NSURLRequest</span> *request = [[<span class="built_in">NSURLRequest</span> alloc] initWithURL:url];</div><div class="line"> [webview loadRequest:request];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们在webViewDidFinishLoad方法中就可以通过javascript操作界面元素了。1、获取当前页面的url。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView {</div><div class="line"> <span class="built_in">NSString</span> *currentURL = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.location.href"</span>];</div><div class="line"> }</div></pre></td></tr></table></figure>

<p>2、获取页面title：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView {</div><div class="line"> <span class="built_in">NSString</span> *currentURL = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.location.href"</span>];</div><div class="line"></div><div class="line"> <span class="built_in">NSString</span> *title = [webview stringByEvaluatingJavaScriptFromString:<span class="string">@"document.title"</span>];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>3、修改界面元素的值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *js_result = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.getElementsByName('q')[0].value='朱祁林';"</span>];</div></pre></td></tr></table></figure>

<p>4、表单提交：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *js_result2 = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.forms[0].submit(); "</span>];</div></pre></td></tr></table></figure>

<p>这样就实现了在google搜索关键字：“朱祁林”的功能。5、插入js代码上面的功能我们可以封装到一个js函数中，将这个函数插入到页面上执行，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[webView stringByEvaluatingJavaScriptFromString:<span class="string">@"var script = document.createElement('script');"</span></div><div class="line"><span class="string">"script.type = 'text/javascript';"</span></div><div class="line"><span class="string">"script.text = \"function myFunction() { "</span></div><div class="line"><span class="string">"var field = document.getElementsByName('q')[0];"</span></div><div class="line"><span class="string">"field.value='朱祁林';"</span></div><div class="line"><span class="string">"document.forms[0].submit();"</span></div><div class="line"><span class="string">"}\";"</span></div><div class="line"><span class="string">"document.getElementsByTagName('head')[0].appendChild(script);"</span>];</div><div class="line"> [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"myFunction();"</span>];</div></pre></td></tr></table></figure>

<p>看上面的代码：a、首先通过js创建一个script的标签，type为’text/javascript’。b、然后在这个标签中插入一段字符串，这段字符串就是一个函数：myFunction，这个函数实现google自动搜索关键字的功能。c、然后使用stringByEvaluatingJavaScriptFromString执行myFunction函数。演示：第一步打开google mobile网站 第二步输入关键字 第三步搜素 总结：这篇文章主要是讲解了stringByEvaluatingJavaScriptFromString的用法，它的功能非常的强大，用起来非常简单，通过它我们可以很方便的操作uiwebview中的页面元素。</p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之常用方法/">iOS应用开发之常用方法</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>, <a href="/tags/ios开发/">ios开发</a>, <a href="/tags/UIWebView/">UIWebView</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-21T05:05:00.000Z"><a href="/2014/02/21/iOS模拟器未能安装此应用程序怎么解决/">2月 21 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/21/iOS模拟器未能安装此应用程序怎么解决/">iOS模拟器未能安装此应用程序怎么解决</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <ol>
<li><p>一般情况下是因为工程的Targets-&gt;General-&gt;Build为空,设置为1.0</p>
</li>
<li><p>删除模拟器相同的应用或者直接还原模拟器.</p>
</li>
</ol>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之Xcode配置/">iOS应用开发之Xcode配置</a>
  </div>

      
      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-20T09:11:00.000Z"><a href="/2014/02/20/iOS开发常用的类别和宏定义集成frameworkd/">2月 20 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/20/iOS开发常用的类别和宏定义集成frameworkd/">iOS开发常用的类别和宏定义集成frameworkd</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p>自己闲着没事就把在网上搜罗一些常用的宏定义和类别方法,顺便学习Framework的打包,自己用着挺方便的.<br><a href="http://download.csdn.net/download/yinxianwei88/6942209" target="_blank" rel="external">Framework下载</a><br><img src="http://img.blog.csdn.net/20140220170410875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluX3hpYW53ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之第三方框架/">iOS应用开发之第三方框架</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/iphone开发/">iphone开发</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  
    <article class="post">
  
  <div class="post-content">
    <header>
      
      
        <div class="icon"></div>
        <time datetime="2014-02-20T08:54:00.000Z"><a href="/2014/02/20/国人当自强：两岸三地在线编程学习网站大搜罗/">2月 20 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/02/20/国人当自强：两岸三地在线编程学习网站大搜罗/">国人当自强：两岸三地在线编程学习网站大搜罗</a></h1>
  

      
    </header>
    <div class="entry">
      
        
        <p><strong>       本文转自：<a href="http://www.csdn.net/article/2013-12-12/2817782-best-websites-to-learn-mobile-dev-in-china/1" target="_blank" rel="external">http://www.csdn.net/article/2013-12-12/2817782-best-websites-to-learn-mobile-dev-in-china/1</a></strong><br><strong>       摘要：</strong>在本文中，我们介绍了来自两岸三地的编程学习网站，通过它们，不仅可以一窥国内App开发的发展现状，而且这些网站各有特点，无论是主打游戏学习还是视频学习，对于想要自学的开发者而言，都是个好去处。<br>说到国内的在线编程学习网站，很多人都是一脸茫然，即使是资深开发者也是如此。在许多人眼中，尽管国内App开发景象一派繁荣，但教育疲软却是不争的事实。在《<a href="http://www.csdn.net/article/2013-12-05/2817687-best-websites-to-learn-mobile-dev-and-design" target="_blank" rel="external"><strong>移动开发者的自学宝典：十大在线编程学习网站</strong></a>》之后，笔者心生了搜罗国内在线编程学习网站的想法。在本文中，我们介绍了来自两岸三地的编程学习网站，通过它们，不仅可以一窥国内App开发的发展现状，而且在这些网站中，有些主打游戏学习，有些主打视频学习，各有特点，对于想要自学的开发者而言，不可谓不是个好去处。</p>
<h3 id="1-_Fenby">1. <a href="http://www.fenby.com/" target="_blank" rel="external">Fenby</a></h3>
<p>在国内为数不多的几个在线编程学习网站中，Fenby颇有知名度，也深受开发者喜爱。的确，对于一心想要寻找中文在线编程学习平台的用户而言，Fenby确实很好。Fenby是一个免费的在线编程互动编程学习网站，提供在线课程、互动问答、编程大赛和练习等。Fenby的运营理念很类似于Codecademy，强调趣味，而据Fenby官方介绍，他们也正是为了解决厚重乏味的书本、艰涩难搭的运行环境和枯燥冗长的视频这三大难题而生的。<br><a href="http://cms.csdnimg.cn/article/201312/12/52a9612fb5678.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/12/52a9612fb5678_middle.jpg" alt=""></a><br>说到Fenby的知识点讲授方面，则更像Treehouse，通过在视频中加入拟物、拟人等类比的知识点讲解，以及很多可视化的动画元素，让学习也变得生动有趣。而在视频教学之后，就会进入一个课堂练习的环节，用户可以在Fenby的在线编译器中输入代码，进行练习操作。<br><a href="http://cms.csdnimg.cn/article/201312/12/52a964d66d854.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/12/52a964d66d854_middle.jpg" alt=""></a><br>Fenby的这个在线代码编译器还是他们自主开发的，是不是很牛叉？除了课堂练习之外，在Fenby上，还有一个闪电编程的模块，初学者可以直接在这里起步，而开发者，则可以将代码粘贴到这里，运行调试程序。<br><strong>2. <a href="http://www.gkk.cn/" target="_blank" rel="external">中国IT公开课排行榜</a></strong><br>接下来，再介绍一个很赞的网站——中国IT公开课排行榜（以下简称为“GKK.CN”）。GKK.CN是北京尚网旗下的一个视频教程平台，在GKK.CN上，有包括应用开发、网站开发、设计等在内的各种原创IT视频教程，并且还都是免费的。<br><a href="http://cms.csdnimg.cn/article/201312/12/52a983ce5187f.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/12/52a983ce5187f_middle.jpg" alt=""></a><br>GKK.CN视频教学不仅全面，而且还有GKK.CN本身还有Android、iOS客户端，无论是在PC、平板电脑、智能手机上，用户都可以随时随地进行视频学习，此外，对于自己喜欢的视频，用户还可以收藏或下载。<br><strong>3. <a href="http://www.microoh.com/" target="_blank" rel="external">麦可网</a></strong><br>相比其他网站，在移动开发上，麦可网明显要更专业得多，这是一家垂直于移动开发课程、专注于打造以移动开发者为核心的实名生态圈的在线教育网站，于2012年正式上线，其前身为Android开发联盟。在麦可上，只有移动互联网和IT职业英语两类视频课程，其中，移动互联网又按技术种类划分为Android、手游、WP及iOS应用开发。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa67ac08cd8.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa67ac08cd8_middle.jpg" alt=""></a><br>在国内在线教育创业圈子里，麦可网是少数中的少数，能持续盈利，还能将视频价格卖到几千块，麦可的的确确如它的介绍所言，将教育做到极致，当之无愧是国内在线教育中的一匹黑马。如此大受欢迎，麦可自有其独到之处。麦可网上的所有课程都是由具有多年开发经验的自聘讲师制作，用户既可以加入麦可的实名圈子，学习它上面的课程，也可以加入其名师圈子，进行教学授课。         </p>
<p><strong>4. <a href="http://www.kaikeba.com/" target="_blank" rel="external">开课吧</a></strong><br>开课吧是国内首家专注于泛IT学科领域的垂直B2C在线教育服务平台，成立于2013年，是一个全新设计的基于移动云计算的混合式教学平台。集在线课程的创意、设计、前期拍摄、后期制作、综合运营为一体，面向个人、高校和企事业单位提供在线内容服务、在线教育平台运营服务和在线课程制作服务等综合在线教育解决方案。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa6d5a1c434.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa6d5a1c434_middle.jpg" alt=""></a><br>开课吧的课程有云计算、互联网营销、交互设计、大数据及编程开发五大类之分，均来自于世界著名学府、泛IT行业领军企业、泛IT行业知名培训机构及名师大腕之手。以线上学习与线下考试相结合的O2O混合教学模式，并通过提供多个3-10分钟的视频短片，用图像、动画的方式寓教于乐，既能引起学习者的兴趣，也能提高学习效率、增强学习效果。<br><strong>5. <a href="http://www.duobei.com/explore/tag/iOS" target="_blank" rel="external">多贝公开课</a></strong><br>在知乎上，说到在线教育网站，许多人对于多贝网都是颇为赞誉，更有甚者直言“找老师，上多贝”。多贝公开课是一个专注于兴趣培养、技能培训的线上C2C公开课开放平台。在多贝网上，讲师可以快速举办在线互动讲座和公开课，并自动生成回放；学生则可以轻松检索和观看各种课程，并直接与老师取得联系。多贝网所实现的其实很简单，就是零负担学习、零负担授课，让所有人都能体验人人为师、人人为学的线上互动。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa7aaa5203e.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa7aaa5203e_middle.jpg" alt=""></a><br>多贝网的课程类别甚广，有兴趣、健康、考试、职场、互联网（产品、设计、创业等）、IT技术（iOS、Android等）、语言、营销等多个类别，对于想要学习移动应用开发和设计的童鞋而言，修学多贝公开课可能不会让你成为顶级大牛，却可以让你快速起步，一步一步从新手变高手。<br><strong>6. <a href="http://www.ucai.cn/course" target="_blank" rel="external">优才网</a></strong><br>优才网是北京优才创智科技有限公司旗下的一个在线教育服务网站，主要提供互联网和移动互联网的培训。优才网在一定程度上借鉴了Codecademy人机互动的游戏模式，但在本质上却不尽相同。优才网所采用的是“人机互动”与传统在线教育“社区知识教学”相结合的方式去做在线教育。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa80c8314fc.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa80c8314fc_middle.jpg" alt=""></a><br>优才网的课程主要面向个人及院校，分为前端、后端、iOS、Android四大开发方向，涵盖应用、手游、跨平台、HTML5等开发。按学习程度分配班级，学员可以相互交流学习心得，并找到相应“辅导老师”答疑解惑，优才网的教学模式更像是一所完整的“网络大学”，全方位满足学生的学习需求。<br><strong><a href="http://hero.pongo.cn/" target="_blank" rel="external"></a><a href="http://www.csdn.net/" target="_blank" rel="external"></a></strong><br>和一般的在线编程学习网站不同，庞果网的在线编程网站Hero英雄会主打“挑战”二字，面向广大程序员，定期发布挑战题目或比赛。在这里，程序员不仅可以提升自己，与高手切磋。而且，只要赢得挑战，就可以获得头衔、奖品以及名企职位等。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aaa3855e05a.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aaa3855e05a_middle.jpg" alt=""></a><br><strong>8. <a href="http://wanbiancheng.com/" target="_blank" rel="external">玩编程</a></strong><br>对于想要自学编程的人来说，也许玩编程更合适。玩编程是由一群曾经自学过编程的工程师、设计师、产品经理和创业家组成的团队创立的，其实这个创始团队本身就是一个很好的自学编程例子。玩编程联合创始人之一高健凯来自台湾，非技术出身，却能去尝试，并坚持下来，还从举办分享编程经验的公开课到现在创建玩编程，这本身就是件很了不起的事情。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aaaa4bb6ae3.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aaaa4bb6ae3_middle.jpg" alt=""></a><br>事实上，自学编程是一件说起来容易但实践起来却非常困难的事情。因为经历过，了解其中的滋味，玩编程以短视频的互动式教学方式为用户提供更容易、更有趣、更有效的编程学习体验。目前，玩编程尚在内测中，只提供iOS开发课程，都是通过一些最真实有趣的App讲解，让用户在学到知识的同时，也学会如何做出一款最酷的iOS应用。<br><strong>9. <a href="http://codetank.alloyteam.com/" target="_blank" rel="external">代码坦克</a>（CodeTank）</strong><br>代码坦克是腾讯推出的一款相当有趣且极具挑战性的编程对战游戏，通过它，用户可以用JavaScript语言来编写属于自己的坦克机器人，并与其他人的坦克进行战斗。因为游戏是不能直接操控坦克的，所以开发者需要用代码和算法让坦克动起来，并更具战斗力。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aaae0c96bfd.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aaae0c96bfd_middle.jpg" alt=""></a><br>用真正游戏的方式进行编程语言学习，在国内来说很新颖。CodeTank是全球首个JavaScript程序员的在线编程对战游戏，是由腾讯AlloyTeam和HTML5梦工场联合出品的在线坦克仿真游戏平台，采用HTML5、Javascript、CSS3、NodeJS、MongoDB等Web技术来构建一个基于互联网的在线智能坦克机器人战斗仿真引擎。<br><strong>10. <a href="http://code4app.com/" target="_blank" rel="external">Code4App</a></strong><br>此处所介绍的Code4App，从严格意义上来讲，并不属于在线编程学习网站范畴，但它确实是一个对于移动开发者非常有用的网站，是iOS开发者的好帮手。Code4App是一个面向移动开发者的开源代码收集和分享网站，在这里，开发者可以便捷地找到自己所需要的代码，以减少在不同App开发过程中重复造车，从而大大提高开发效率。<br><a href="http://cms.csdnimg.cn/article/201312/13/52aa8d8fc863a.jpg" target="_blank" rel="external"><img src="http://cms.csdnimg.cn/article/201312/13/52aa8d8fc863a_middle.jpg" alt=""></a><br>因“让移动开发者不再重复造轮子”而生，致力于做国内最好的、移动开发平台的开源代码收集网站。Code4App会为每份代码做严格的模拟机和真机测试，并配上文字说明、屏幕截图以及视频演示，除此之外，还允许用户自行上传代码分享给其他用户。也正因为这样，Code4App颇受开发者青睐。目前Code4App只推出了iOS平台，但在未来也会加入Android、WP等其他移动平台。<br><strong>11. <a href="http://www.tutor.compbrother.com/" target="_blank" rel="external">香港电脑补习网</a>、<a href="http://www.systematic.com.hk/iphone-programming.htm" target="_blank" rel="external">Systematic系统电脑教育中心</a></strong><br>不久之前，在微博上看到有人讨论香港的IT行业，让笔者有了一窥香港的App开发的冲动。即使是现在，许多人对于香港的移动互联网还是充满憧憬和向往的。可是，尽管有一些非常不错的移动互联网公司，但整体上却并不如人意。即使因为智能设备在香港的大幅度普及，即使受到内地风生水起的影响，为App开发创造了一些机会，但其环境却已大不如前。<br>在许多香港本土居民的眼中，搞开发是项没有前途的事业。在这种情况下，香港的在线编程教育实在难以雄起，在搜罗过程中，笔者发现，说到应用开发学习，香港的编程学习网站有特点实在是凤毛麟角，更多的是以线上线下相结合的方式，而首推的便是香港电脑补习网、Systematic系统电脑教育中心，都是线下教学，这和我们所推崇的MOOC还是有很大的差距的。<br><strong>结束语</strong><br>在本文中，我们并未介绍诸如网易公开课等比较知名的MOOC网站，只是对更倾向于IT的在线编程学习网站列举出来并进行介绍。其实在国内，说到自学编程资源，还是很多的，除了论坛博客，还有许多视频教学网站，比如专门提供Android开发教学的，也是Android开发者最喜欢的<strong><a href="http://www.android-study.net/" target="_blank" rel="external">Android开发学习网</a>、<a href="http://edu.eoe.cn/" target="_blank" rel="external">eoe在线课堂</a>、<a href="http://www.apkbus.com/heima/" target="_blank" rel="external">安卓巴士</a></strong>等，如果你有好的学习网站，不妨在这里和我们分享一下吧。<br>（文/唐小引 责编/张宁）<br><strong>本文为CSDN原创文章，未经允许不得转载，如需转载请联系market#csdn.net(#换成@)</strong></p>

      
    </div>
    <footer>
      
  
  <div class="categories">
    <a href="/categories/iOS应用开发之学习资源/">iOS应用开发之学习资源</a>
  </div>

      
  
  <div class="tags">
    <a href="/tags/ios/">ios</a>
  </div>

      
        
          <div class="alignright share-box">
  
</div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  

  <nav id="pagination">
  
  
    <a href="/archives/2014/02/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  
    <form>
      <input id="st-search-input" type="search" placeholder="Search">
    </form>
    <div id="st-results-container"></div>
  
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <div class="entry">
    
      <span><a href="/tags/2d/">2d<small>1</small></a></span>
    
      <span><a href="/tags/AFNetworking/">AFNetworking<small>2</small></a></span>
    
      <span><a href="/tags/CoreData/">CoreData<small>2</small></a></span>
    
      <span><a href="/tags/Drawing/">Drawing<small>1</small></a></span>
    
      <span><a href="/tags/MagicalRecord/">MagicalRecord<small>1</small></a></span>
    
      <span><a href="/tags/NSDate/">NSDate<small>1</small></a></span>
    
      <span><a href="/tags/NSString/">NSString<small>1</small></a></span>
    
      <span><a href="/tags/Swift/">Swift<small>9</small></a></span>
    
      <span><a href="/tags/UIAlertView/">UIAlertView<small>1</small></a></span>
    
      <span><a href="/tags/UITabBarController/">UITabBarController<small>1</small></a></span>
    
      <span><a href="/tags/UITableViewControlle/">UITableViewControlle<small>1</small></a></span>
    
      <span><a href="/tags/UIWebView/">UIWebView<small>1</small></a></span>
    
      <span><a href="/tags/URL-Scheme/">URL Scheme<small>1</small></a></span>
    
      <span><a href="/tags/URL编码/">URL编码<small>1</small></a></span>
    
      <span><a href="/tags/XMPP/">XMPP<small>3</small></a></span>
    
      <span><a href="/tags/Xcode5-1/">Xcode5.1<small>1</small></a></span>
    
      <span><a href="/tags/api/">api<small>5</small></a></span>
    
      <span><a href="/tags/appStore审核/">appStore审核<small>1</small></a></span>
    
      <span><a href="/tags/block/">block<small>1</small></a></span>
    
      <span><a href="/tags/bytearray/">bytearray<small>1</small></a></span>
    
      <span><a href="/tags/cell自适应高度/">cell自适应高度<small>1</small></a></span>
    
      <span><a href="/tags/cocos2d/">cocos2d<small>3</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发font/">fontfontiPhone开发font<small>1</small></a></span>
    
      <span><a href="/tags/fontfontiPhone开发fontfont/">fontfontiPhone开发fontfont<small>1</small></a></span>
    
      <span><a href="/tags/fontfontios的fontfont/">fontfontios的fontfont<small>2</small></a></span>
    
      <span><a href="/tags/fontfont动画fontfont/">fontfont动画fontfont<small>1</small></a></span>
    
      <span><a href="/tags/framework/">framework<small>1</small></a></span>
    
      <span><a href="/tags/iOS8/">iOS8<small>2</small></a></span>
    
      <span><a href="/tags/iOS8-1-1/">iOS8.1.1<small>1</small></a></span>
    
      <span><a href="/tags/iOS8定位/">iOS8定位<small>1</small></a></span>
    
      <span><a href="/tags/iOS国际化/">iOS国际化<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之app上架/">iOS应用开发之app上架<small>1</small></a></span>
    
      <span><a href="/tags/iOS应用开发之第三方框架/">iOS应用开发之第三方框架<small>1</small></a></span>
    
      <span><a href="/tags/iOS开发/">iOS开发<small>5</small></a></span>
    
      <span><a href="/tags/iOS自定义Tabbar/">iOS自定义Tabbar<small>1</small></a></span>
    
      <span><a href="/tags/ios/">ios<small>53</small></a></span>
    
      <span><a href="/tags/ios7/">ios7<small>1</small></a></span>
    
      <span><a href="/tags/ios7适配/">ios7适配<small>1</small></a></span>
    
      <span><a href="/tags/ios国际化/">ios国际化<small>1</small></a></span>
    
      <span><a href="/tags/ios开发/">ios开发<small>27</small></a></span>
    
      <span><a href="/tags/iphone/">iphone<small>4</small></a></span>
    
      <span><a href="/tags/iphone开发/">iphone开发<small>59</small></a></span>
    
      <span><a href="/tags/itunes/">itunes<small>1</small></a></span>
    
      <span><a href="/tags/objective-c/">objective-c<small>1</small></a></span>
    
      <span><a href="/tags/svn/">svn<small>1</small></a></span>
    
      <span><a href="/tags/uiimage/">uiimage<small>2</small></a></span>
    
      <span><a href="/tags/uitableview/">uitableview<small>1</small></a></span>
    
      <span><a href="/tags/uitableviewcell/">uitableviewcell<small>1</small></a></span>
    
      <span><a href="/tags/uitextfield/">uitextfield<small>1</small></a></span>
    
      <span><a href="/tags/uiview/">uiview<small>3</small></a></span>
    
      <span><a href="/tags/uiviewcontroller/">uiviewcontroller<small>1</small></a></span>
    
      <span><a href="/tags/uiwebview/">uiwebview<small>1</small></a></span>
    
      <span><a href="/tags/xcode/">xcode<small>2</small></a></span>
    
      <span><a href="/tags/xmpp/">xmpp<small>1</small></a></span>
    
      <span><a href="/tags/二维码/">二维码<small>1</small></a></span>
    
      <span><a href="/tags/企业/">企业<small>1</small></a></span>
    
      <span><a href="/tags/动画/">动画<small>5</small></a></span>
    
      <span><a href="/tags/国际化/">国际化<small>1</small></a></span>
    
      <span><a href="/tags/在线工具/">在线工具<small>1</small></a></span>
    
      <span><a href="/tags/多线程/">多线程<small>1</small></a></span>
    
      <span><a href="/tags/存储/">存储<small>1</small></a></span>
    
      <span><a href="/tags/宏/">宏<small>1</small></a></span>
    
      <span><a href="/tags/导航/">导航<small>1</small></a></span>
    
      <span><a href="/tags/屏幕旋转/">屏幕旋转<small>2</small></a></span>
    
      <span><a href="/tags/应用程序/">应用程序<small>2</small></a></span>
    
      <span><a href="/tags/微信开放平台ios/">微信开放平台ios<small>1</small></a></span>
    
      <span><a href="/tags/打开AppStore/">打开AppStore<small>1</small></a></span>
    
      <span><a href="/tags/数据库/">数据库<small>1</small></a></span>
    
      <span><a href="/tags/缓存/">缓存<small>1</small></a></span>
    
      <span><a href="/tags/聊天/">聊天<small>1</small></a></span>
    
      <span><a href="/tags/苹果应用商店/">苹果应用商店<small>1</small></a></span>
    
      <span><a href="/tags/获取iP地址/">获取iP地址<small>1</small></a></span>
    
  </div>
</div>




  <script type="text/javascript">
    (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
    })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

    _st('install','6xH6jcZvsZxn2a9rcU4t');
  </script>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div id="foot-nav">
  <ul class="social">
    
      <li><a class="github" href="https://github.com/DaiXiang" title="github">github</a></li>
    
      <li><a class="rss" href="/atom.xml" title="rss">rss</a></li>
    
  </ul>
</div>
<div>
  
    &copy; 2014 尹现伟
  
</div>
<div class="clearfix"></div></footer>
  


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<script type="text/javascript">
  function navbar() {
    var top = $('#nav-top').innerHeight();
    $('#header').css('min-height', top);
  }
  navbar();
  $(window).resize(navbar);
</script>
<div id="totop" class="footer-btn">
  <a title="Return to Top"><img src="/img/scrollup.png"/></a>
</div>

<script type="text/javascript">
  $(function(){ 
	// When to show the scroll link
	// higher number = scroll link appears further down the page   
	var upperLimit = 800;
	
	// Our scroll link element
	var scrollElem = $('#totop');
   
	// Scroll to top speed
	var scrollSpeed = 500;
   
	// Show and hide the scroll to top link based on scroll position   
	scrollElem.hide();
	$(window).scroll(function () {            
		var scrollTop = $(document).scrollTop();       
		if ( scrollTop > upperLimit ) {
		  $(scrollElem).stop().fadeTo(300, 1); // fade back in
		  $(scrollElem).animate({bottom: "50px"}, { queue: false, duration: 10 });
		} else {
		  $(scrollElem).stop().fadeTo(300, 0); // fade out
	      $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
			
		}
	});

	// Scroll to top animation on click
	$(scrollElem).click(function(){
	  $('html, body').animate({scrollTop:0}, scrollSpeed);
	  $(scrollElem).animate({bottom: "-200px"}, { queue: false, duration: 10 });
	  return false;
	});
  });
</script>
</body>
</html>